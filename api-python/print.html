<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Polars - Python Reference Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/css/style.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="polars.html">polars</a></li><li class="chapter-item "><a href="polars/cfg.html">cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/cfg/Config.html">Config</a></li></ol></li><li class="chapter-item "><a href="polars/convert.html">convert</a></li><li class="chapter-item "><a href="polars/datatypes.html">datatypes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/datatypes/DataType.html">DataType</a></li><li class="chapter-item "><a href="polars/datatypes/Int8.html">Int8</a></li><li class="chapter-item "><a href="polars/datatypes/Int16.html">Int16</a></li><li class="chapter-item "><a href="polars/datatypes/Int32.html">Int32</a></li><li class="chapter-item "><a href="polars/datatypes/Int64.html">Int64</a></li><li class="chapter-item "><a href="polars/datatypes/UInt8.html">UInt8</a></li><li class="chapter-item "><a href="polars/datatypes/UInt16.html">UInt16</a></li><li class="chapter-item "><a href="polars/datatypes/UInt32.html">UInt32</a></li><li class="chapter-item "><a href="polars/datatypes/UInt64.html">UInt64</a></li><li class="chapter-item "><a href="polars/datatypes/Float32.html">Float32</a></li><li class="chapter-item "><a href="polars/datatypes/Float64.html">Float64</a></li><li class="chapter-item "><a href="polars/datatypes/Boolean.html">Boolean</a></li><li class="chapter-item "><a href="polars/datatypes/Utf8.html">Utf8</a></li><li class="chapter-item "><a href="polars/datatypes/List.html">List</a></li><li class="chapter-item "><a href="polars/datatypes/Date.html">Date</a></li><li class="chapter-item "><a href="polars/datatypes/Datetime.html">Datetime</a></li><li class="chapter-item "><a href="polars/datatypes/Time.html">Time</a></li><li class="chapter-item "><a href="polars/datatypes/Object.html">Object</a></li><li class="chapter-item "><a href="polars/datatypes/Categorical.html">Categorical</a></li></ol></li><li class="chapter-item "><a href="polars/datatypes_constructor.html">datatypes_constructor</a></li><li class="chapter-item "><a href="polars/internals.html">internals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/internals/construction.html">construction</a></li><li class="chapter-item "><a href="polars/internals/expr.html">expr</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/internals/expr/Expr.html">Expr</a></li><li class="chapter-item "><a href="polars/internals/expr/ExprListNameSpace.html">ExprListNameSpace</a></li><li class="chapter-item "><a href="polars/internals/expr/ExprStringNameSpace.html">ExprStringNameSpace</a></li><li class="chapter-item "><a href="polars/internals/expr/ExprDateTimeNameSpace.html">ExprDateTimeNameSpace</a></li></ol></li><li class="chapter-item "><a href="polars/internals/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/internals/frame/DataFrame.html">DataFrame</a></li><li class="chapter-item "><a href="polars/internals/frame/GroupBy.html">GroupBy</a></li><li class="chapter-item "><a href="polars/internals/frame/PivotOps.html">PivotOps</a></li><li class="chapter-item "><a href="polars/internals/frame/GBSelection.html">GBSelection</a></li></ol></li><li class="chapter-item "><a href="polars/internals/functions.html">functions</a></li><li class="chapter-item "><a href="polars/internals/lazy_frame.html">lazy_frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/internals/lazy_frame/LazyFrame.html">LazyFrame</a></li><li class="chapter-item "><a href="polars/internals/lazy_frame/LazyGroupBy.html">LazyGroupBy</a></li></ol></li><li class="chapter-item "><a href="polars/internals/lazy_functions.html">lazy_functions</a></li><li class="chapter-item "><a href="polars/internals/series.html">series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/internals/series/Series.html">Series</a></li><li class="chapter-item "><a href="polars/internals/series/StringNameSpace.html">StringNameSpace</a></li><li class="chapter-item "><a href="polars/internals/series/ListNameSpace.html">ListNameSpace</a></li><li class="chapter-item "><a href="polars/internals/series/DateTimeNameSpace.html">DateTimeNameSpace</a></li><li class="chapter-item "><a href="polars/internals/series/SeriesIter.html">SeriesIter</a></li></ol></li><li class="chapter-item "><a href="polars/internals/whenthen.html">whenthen</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/internals/whenthen/WhenThenThen.html">WhenThenThen</a></li><li class="chapter-item "><a href="polars/internals/whenthen/WhenThen.html">WhenThen</a></li><li class="chapter-item "><a href="polars/internals/whenthen/When.html">When</a></li></ol></li></ol></li><li class="chapter-item "><a href="polars/io.html">io</a></li><li class="chapter-item "><a href="polars/string_cache.html">string_cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="polars/string_cache/StringCache.html">StringCache</a></li></ol></li><li class="chapter-item "><a href="polars/testing.html">testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - Python Reference Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="module-polars"><a class="header" href="#module-polars">Module <code>polars</code></a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarscfg"><a class="header" href="#module-polarscfg">Module <code>polars.cfg</code></a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarscfgconfig"><a class="header" href="#polarscfgconfig"><code>polars.cfg.Config</code></a></h1>
<p>Configure polars</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/cfg/Config.html#polarscfgconfigset_utf8_tables"><code>set_utf8_tables()</code></a>: Use utf8 characters to print tables</li>
<li><a href="polars/cfg/Config.html#polarscfgconfigset_ascii_tables"><code>set_ascii_tables()</code></a>: Use ascii characters to print tables</li>
<li><a href="polars/cfg/Config.html#polarscfgconfigset_tbl_width_chars"><code>set_tbl_width_chars()</code></a>: Set the number of character used to draw the table</li>
<li><a href="polars/cfg/Config.html#polarscfgconfigset_tbl_rows"><code>set_tbl_rows()</code></a>: Set the number of rows used to print tables</li>
<li><a href="polars/cfg/Config.html#polarscfgconfigset_tbl_cols"><code>set_tbl_cols()</code></a>: Set the number of columns used to print tables</li>
<li><a href="polars/cfg/Config.html#polarscfgconfigset_global_string_cache"><code>set_global_string_cache()</code></a>: Turn on the global string cache</li>
<li><a href="polars/cfg/Config.html#polarscfgconfigunset_global_string_cache"><code>unset_global_string_cache()</code></a>: Turn off the global string cache</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Config:
    &quot;&quot;&quot;
    Configure polars
    &quot;&quot;&quot;

    @classmethod
    def set_utf8_tables(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Use utf8 characters to print tables
        &quot;&quot;&quot;
        os.environ.unsetenv(&quot;POLARS_FMT_NO_UTF8&quot;)  # type: ignore
        return cls

    @classmethod
    def set_ascii_tables(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Use ascii characters to print tables
        &quot;&quot;&quot;
        os.environ[&quot;POLARS_FMT_NO_UTF8&quot;] = &quot;1&quot;
        return cls

    @classmethod
    def set_tbl_width_chars(cls, width: int) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Set the number of character used to draw the table

        Parameters
        ----------
        width
            number of chars
        &quot;&quot;&quot;
        os.environ[&quot;POLARS_TABLE_WIDTH&quot;] = str(width)
        return cls

    @classmethod
    def set_tbl_rows(cls, n: int) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Set the number of rows used to print tables

        Parameters
        ----------
        n
            number of rows to print
        &quot;&quot;&quot;

        os.environ[&quot;POLARS_FMT_MAX_ROWS&quot;] = str(n)
        return cls

    @classmethod
    def set_tbl_cols(cls, n: int) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Set the number of columns used to print tables

        Parameters
        ----------
        n
            number of columns to print
        &quot;&quot;&quot;

        os.environ[&quot;POLARS_FMT_MAX_COLS&quot;] = str(n)
        return cls

    @classmethod
    def set_global_string_cache(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Turn on the global string cache
        &quot;&quot;&quot;
        toggle_string_cache(True)
        return cls

    @classmethod
    def unset_global_string_cache(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Turn off the global string cache
        &quot;&quot;&quot;
        toggle_string_cache(False)
        return cls
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-python">Config()
</code></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigset_utf8_tables"><a class="header" href="#polarscfgconfigset_utf8_tables"><code>polars.cfg.Config.set_utf8_tables</code></a></h3>
<pre><code class="language-python">set_utf8_tables(cls) -&gt; Type[Config]:
</code></pre>
<p>Use utf8 characters to print tables</p>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_utf8_tables(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Use utf8 characters to print tables
        &quot;&quot;&quot;
        os.environ.unsetenv(&quot;POLARS_FMT_NO_UTF8&quot;)  # type: ignore
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigset_ascii_tables"><a class="header" href="#polarscfgconfigset_ascii_tables"><code>polars.cfg.Config.set_ascii_tables</code></a></h3>
<pre><code class="language-python">set_ascii_tables(cls) -&gt; Type[Config]:
</code></pre>
<p>Use ascii characters to print tables</p>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_ascii_tables(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Use ascii characters to print tables
        &quot;&quot;&quot;
        os.environ[&quot;POLARS_FMT_NO_UTF8&quot;] = &quot;1&quot;
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigset_tbl_width_chars"><a class="header" href="#polarscfgconfigset_tbl_width_chars"><code>polars.cfg.Config.set_tbl_width_chars</code></a></h3>
<pre><code class="language-python">set_tbl_width_chars(cls, width: int) -&gt; Type[Config]:
</code></pre>
<p>Set the number of character used to draw the table</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>width</code>]: number of chars</li>
</ul>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_tbl_width_chars(cls, width: int) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Set the number of character used to draw the table

        Parameters
        ----------
        width
            number of chars
        &quot;&quot;&quot;
        os.environ[&quot;POLARS_TABLE_WIDTH&quot;] = str(width)
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigset_tbl_rows"><a class="header" href="#polarscfgconfigset_tbl_rows"><code>polars.cfg.Config.set_tbl_rows</code></a></h3>
<pre><code class="language-python">set_tbl_rows(cls, n: int) -&gt; Type[Config]:
</code></pre>
<p>Set the number of rows used to print tables</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: number of rows to print</li>
</ul>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_tbl_rows(cls, n: int) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Set the number of rows used to print tables

        Parameters
        ----------
        n
            number of rows to print
        &quot;&quot;&quot;

        os.environ[&quot;POLARS_FMT_MAX_ROWS&quot;] = str(n)
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigset_tbl_cols"><a class="header" href="#polarscfgconfigset_tbl_cols"><code>polars.cfg.Config.set_tbl_cols</code></a></h3>
<pre><code class="language-python">set_tbl_cols(cls, n: int) -&gt; Type[Config]:
</code></pre>
<p>Set the number of columns used to print tables</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: number of columns to print</li>
</ul>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_tbl_cols(cls, n: int) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Set the number of columns used to print tables

        Parameters
        ----------
        n
            number of columns to print
        &quot;&quot;&quot;

        os.environ[&quot;POLARS_FMT_MAX_COLS&quot;] = str(n)
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigset_global_string_cache"><a class="header" href="#polarscfgconfigset_global_string_cache"><code>polars.cfg.Config.set_global_string_cache</code></a></h3>
<pre><code class="language-python">set_global_string_cache(cls) -&gt; Type[Config]:
</code></pre>
<p>Turn on the global string cache</p>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_global_string_cache(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Turn on the global string cache
        &quot;&quot;&quot;
        toggle_string_cache(True)
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarscfgconfigunset_global_string_cache"><a class="header" href="#polarscfgconfigunset_global_string_cache"><code>polars.cfg.Config.unset_global_string_cache</code></a></h3>
<pre><code class="language-python">unset_global_string_cache(cls) -&gt; Type[Config]:
</code></pre>
<p>Turn off the global string cache</p>
<p><strong>Decoration</strong> via <code>@classmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unset_global_string_cache(cls) -&gt; &quot;Type[Config]&quot;:
        &quot;&quot;&quot;
        Turn off the global string cache
        &quot;&quot;&quot;
        toggle_string_cache(False)
        return cls
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsconvert"><a class="header" href="#module-polarsconvert">Module <code>polars.convert</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/convert.html#polarsconvertfrom_dict"><code>from_dict()</code></a>: Construct a DataFrame from a dictionary of sequences.</li>
<li><a href="polars/convert.html#polarsconvertfrom_records"><code>from_records()</code></a>: Construct a DataFrame from a numpy ndarray or sequence of sequences.</li>
<li><a href="polars/convert.html#polarsconvertfrom_dicts"><code>from_dicts()</code></a>: Construct a DataFrame from a sequence of dictionaries.</li>
<li><a href="polars/convert.html#polarsconvertfrom_arrow"><code>from_arrow()</code></a>: Create a DataFrame or Series from an Arrow Table or Array.</li>
<li><a href="polars/convert.html#polarsconvertfrom_pandas"><code>from_pandas()</code></a>: Construct a Polars DataFrame or Series from a pandas DataFrame or Series.</li>
</ul>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsconvertfrom_dict"><a class="header" href="#polarsconvertfrom_dict"><code>polars.convert.from_dict</code></a></h3>
<pre><code class="language-python">from_dict(
    data: Dict[str, SequenceAny], 
    columns: OptionalSequencestr,
) -&gt; DataFrame:
</code></pre>
<p>Construct a DataFrame from a dictionary of sequences.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> [<code>dict of sequences</code>]: Two-dimensional data represented as a dictionary. dict must contain
Sequences.</li>
<li><code>columns</code> [<code>Sequence of str, default None</code>]: Column labels to use for resulting DataFrame. If specified, overrides any
labels already present in the data. Must match data dimensions.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>data = {'a': [1, 2], 'b': [3, 4]}
df = pl.from_dict(data)
df
shape: (2, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 4   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def from_dict(
    data: Dict[str, Sequence[Any]],
    columns: Optional[Sequence[str]] = None,
) -&gt; DataFrame:
    &quot;&quot;&quot;
    Construct a DataFrame from a dictionary of sequences.

    Parameters
    ----------
    data : dict of sequences
        Two-dimensional data represented as a dictionary. dict must contain
        Sequences.
    columns : Sequence of str, default None
        Column labels to use for resulting DataFrame. If specified, overrides any
        labels already present in the data. Must match data dimensions.

    Returns
    -------
    DataFrame

    Examples
    --------

    &gt;&gt;&gt; data = {'a': [1, 2], 'b': [3, 4]}
    &gt;&gt;&gt; df = pl.from_dict(data)
    &gt;&gt;&gt; df
    shape: (2, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 4   │
    ╰─────┴─────╯
    &quot;&quot;&quot;
    return DataFrame._from_dict(data=data, columns=columns)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsconvertfrom_records"><a class="header" href="#polarsconvertfrom_records"><code>polars.convert.from_records</code></a></h3>
<pre><code class="language-python">from_records(
    data: Union[np.ndarray, SequenceSequenceAny], 
    columns: OptionalSequencestr, 
    orient: Optionalstr,
) -&gt; DataFrame:
</code></pre>
<p>Construct a DataFrame from a numpy ndarray or sequence of sequences.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> [<code>numpy ndarray or Sequence of sequences</code>]: Two-dimensional data represented as numpy ndarray or sequence of sequences.</li>
<li><code>columns</code> [<code>Sequence of str, default None</code>]: Column labels to use for resulting DataFrame. Must match data dimensions.
If not specified, columns will be named <code>column_0</code>, <code>column_1</code>, etc.
orient : {'col', 'row'}, default None
Whether to interpret two-dimensional data as columns or as rows. If None,
the orientation is inferred by matching the columns and data dimensions. If
this does not yield conclusive results, column orientation is used.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [[1, 2, 3], [4, 5, 6]]
df = pl.from_records(data, columns=['a', 'b'])
df
shape: (3, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 4   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 5   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 6   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def from_records(
    data: Union[np.ndarray, Sequence[Sequence[Any]]],
    columns: Optional[Sequence[str]] = None,
    orient: Optional[str] = None,
) -&gt; DataFrame:
    &quot;&quot;&quot;
    Construct a DataFrame from a numpy ndarray or sequence of sequences.

    Parameters
    ----------
    data : numpy ndarray or Sequence of sequences
        Two-dimensional data represented as numpy ndarray or sequence of sequences.
    columns : Sequence of str, default None
        Column labels to use for resulting DataFrame. Must match data dimensions.
        If not specified, columns will be named `column_0`, `column_1`, etc.
    orient : {'col', 'row'}, default None
        Whether to interpret two-dimensional data as columns or as rows. If None,
        the orientation is inferred by matching the columns and data dimensions. If
        this does not yield conclusive results, column orientation is used.

    Returns
    -------
    DataFrame

    Examples
    --------

    &gt;&gt;&gt; data = [[1, 2, 3], [4, 5, 6]]
    &gt;&gt;&gt; df = pl.from_records(data, columns=['a', 'b'])
    &gt;&gt;&gt; df
    shape: (3, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 4   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 5   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 3   ┆ 6   │
    ╰─────┴─────╯
    &quot;&quot;&quot;
    return DataFrame._from_records(data, columns=columns, orient=orient)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsconvertfrom_dicts"><a class="header" href="#polarsconvertfrom_dicts"><code>polars.convert.from_dicts</code></a></h3>
<pre><code class="language-python">from_dicts(dicts: SequenceDict[str, Any]) -&gt; DataFrame:
</code></pre>
<p>Construct a DataFrame from a sequence of dictionaries.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dicts</code>]: Sequence with dictionaries mapping column name to value
<strong>Returns:</strong></li>
</ul>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [{&quot;a&quot;: 1, &quot;b&quot;: 4}, {&quot;a&quot;: 2, &quot;b&quot;: 5}, {&quot;a&quot;: 3, &quot;b&quot;: 6}]
df = pl.from_dicts(data)
df
shape: (3, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 4   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 5   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 6   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def from_dicts(dicts: Sequence[Dict[str, Any]]) -&gt; DataFrame:
    &quot;&quot;&quot;
    Construct a DataFrame from a sequence of dictionaries.

    Parameters
    ----------
    dicts
        Sequence with dictionaries mapping column name to value
    Returns
    -------
    DataFrame

    Examples
    --------

    &gt;&gt;&gt; data = [{&quot;a&quot;: 1, &quot;b&quot;: 4}, {&quot;a&quot;: 2, &quot;b&quot;: 5}, {&quot;a&quot;: 3, &quot;b&quot;: 6}]
    &gt;&gt;&gt; df = pl.from_dicts(data)
    &gt;&gt;&gt; df
    shape: (3, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 4   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 5   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 3   ┆ 6   │
    ╰─────┴─────╯
    &quot;&quot;&quot;
    return DataFrame._from_dicts(dicts)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsconvertfrom_arrow"><a class="header" href="#polarsconvertfrom_arrow"><code>polars.convert.from_arrow</code></a></h3>
<pre><code class="language-python">from_arrow(
    a: Union[pa.Table, pa.Array, pa.ChunkedArray], 
    rechunk: bool,
) -&gt; Union[DataFrame, Series]:
</code></pre>
<p>Create a DataFrame or Series from an Arrow Table or Array.</p>
<p>This operation will be zero copy for the most part. Types that are not
supported by Polars may be cast to the closest supported type.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>a</code> [<code>Arrow Table or Array</code>]: Data represented as Arrow Table or Array.</li>
<li><code>rechunk</code> [<code>bool, default True</code>]: Make sure that all data is contiguous.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame or Series</p>
<p><strong>Examples:</strong></p>
<p>Constructing a DataFrame from an Arrow Table:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = pa.table({'a': [1, 2, 3], 'b': [4, 5, 6]})
df = pl.from_arrow(data)
df
shape: (3, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 4   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 5   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 6   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a Series from an Arrow Array:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = pa.array([1, 2, 3])
series = pl.from_arrow(data)
series
shape: (3,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def from_arrow(
    a: Union[&quot;pa.Table&quot;, &quot;pa.Array&quot;, &quot;pa.ChunkedArray&quot;], rechunk: bool = True
) -&gt; Union[DataFrame, Series]:
    &quot;&quot;&quot;
    Create a DataFrame or Series from an Arrow Table or Array.

    This operation will be zero copy for the most part. Types that are not
    supported by Polars may be cast to the closest supported type.

    Parameters
    ----------
    a : Arrow Table or Array
        Data represented as Arrow Table or Array.
    rechunk : bool, default True
        Make sure that all data is contiguous.

    Returns
    -------
    DataFrame or Series

    Examples
    --------
    Constructing a DataFrame from an Arrow Table:

    &gt;&gt;&gt; data = pa.table({'a': [1, 2, 3], 'b': [4, 5, 6]})
    &gt;&gt;&gt; df = pl.from_arrow(data)
    &gt;&gt;&gt; df
    shape: (3, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 4   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 5   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 3   ┆ 6   │
    ╰─────┴─────╯

    Constructing a Series from an Arrow Array:

    &gt;&gt;&gt; data = pa.array([1, 2, 3])
    &gt;&gt;&gt; series = pl.from_arrow(data)
    &gt;&gt;&gt; series
    shape: (3,)
    Series: '' [i64]
    [
            1
            2
            3
    ]
    &quot;&quot;&quot;
    if not _PYARROW_AVAILABLE:
        raise ImportError(
            &quot;'pyarrow' is required when using from_arrow().&quot;
        )  # pragma: no cover
    if isinstance(a, pa.Table):
        return DataFrame._from_arrow(a, rechunk=rechunk)
    elif isinstance(a, (pa.Array, pa.ChunkedArray)):
        return Series._from_arrow(&quot;&quot;, a)
    else:
        raise ValueError(f&quot;Expected Arrow Table or Array, got {type(a)}.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsconvertfrom_pandas"><a class="header" href="#polarsconvertfrom_pandas"><code>polars.convert.from_pandas</code></a></h3>
<pre><code class="language-python">from_pandas(
    df: Union[pd.DataFrame, pd.Series, pd.DatetimeIndex], 
    rechunk: bool, 
    nan_to_none: bool,
) -&gt; Union[DataFrame, Series]:
</code></pre>
<p>Construct a Polars DataFrame or Series from a pandas DataFrame or Series.</p>
<p>Requires the pandas package to be installed.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>df</code> [<code>pandas DataFrame, Series, or DatetimeIndex</code>]: Data represented as a pandas DataFrame, Series, or DatetimeIndex.</li>
<li><code>rechunk</code> [<code>bool, default True</code>]: Make sure that all data is contiguous.</li>
<li><code>nan_to_none</code> [<code>bool, default True</code>]: If data contains NaN values PyArrow will convert the NaN to None</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<p>Constructing a DataFrame from a pandas DataFrame:</p>
<blockquote>
<blockquote>
<blockquote>
<p>pd_df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=['a', 'b', 'c'])
df = pl.from_pandas(pd_df)
df
shape: (2, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 5   ┆ 6   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a Series from a pandas Series:</p>
<blockquote>
<blockquote>
<blockquote>
<p>pd_series = pd.Series([1,2,3], name='pd')
df = pl.from_pandas(pd_series)
df
shape: (3,)
Series: 'pd' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def from_pandas(
    df: Union[&quot;pd.DataFrame&quot;, &quot;pd.Series&quot;, &quot;pd.DatetimeIndex&quot;],
    rechunk: bool = True,
    nan_to_none: bool = True,
) -&gt; Union[DataFrame, Series]:
    &quot;&quot;&quot;
    Construct a Polars DataFrame or Series from a pandas DataFrame or Series.

    Requires the pandas package to be installed.

    Parameters
    ----------
    df : pandas DataFrame, Series, or DatetimeIndex
        Data represented as a pandas DataFrame, Series, or DatetimeIndex.
    rechunk : bool, default True
        Make sure that all data is contiguous.
    nan_to_none : bool, default True
        If data contains NaN values PyArrow will convert the NaN to None

    Returns
    -------
    DataFrame

    Examples
    --------
    Constructing a DataFrame from a pandas DataFrame:

    &gt;&gt;&gt; pd_df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=['a', 'b', 'c'])
    &gt;&gt;&gt; df = pl.from_pandas(pd_df)
    &gt;&gt;&gt; df
    shape: (2, 3)
    ╭─────┬─────┬─────╮
    │ a   ┆ b   ┆ c   │
    │ --- ┆ --- ┆ --- │
    │ i64 ┆ i64 ┆ i64 │
    ╞═════╪═════╪═════╡
    │ 1   ┆ 2   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
    │ 4   ┆ 5   ┆ 6   │
    ╰─────┴─────┴─────╯

    Constructing a Series from a pandas Series:

    &gt;&gt;&gt; pd_series = pd.Series([1,2,3], name='pd')
    &gt;&gt;&gt; df = pl.from_pandas(pd_series)
    &gt;&gt;&gt; df
    shape: (3,)
    Series: 'pd' [i64]
    [
            1
            2
            3
    ]
    &quot;&quot;&quot;
    try:
        import pandas as pd
    except ImportError as e:  # pragma: no cover
        raise ImportError(&quot;'pandas' is required when using from_pandas().&quot;) from e

    if isinstance(df, (pd.Series, pd.DatetimeIndex)):
        return Series._from_pandas(&quot;&quot;, df, nan_to_none=nan_to_none)
    elif isinstance(df, pd.DataFrame):
        return DataFrame._from_pandas(df, rechunk=rechunk, nan_to_none=nan_to_none)
    else:
        raise ValueError(f&quot;Expected pandas DataFrame or Series, got {type(df)}.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsdatatypes"><a class="header" href="#module-polarsdatatypes">Module <code>polars.datatypes</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/datatypes.html#polarsdatatypesdtype_to_ctype"><code>dtype_to_ctype()</code></a>: </li>
<li><a href="polars/datatypes.html#polarsdatatypesdtype_to_ffiname"><code>dtype_to_ffiname()</code></a>: </li>
<li><a href="polars/datatypes.html#polarsdatatypesdtype_to_py_type"><code>dtype_to_py_type()</code></a>: </li>
<li><a href="polars/datatypes.html#polarsdatatypespy_type_to_dtype"><code>py_type_to_dtype()</code></a>: </li>
<li><a href="polars/datatypes.html#polarsdatatypespy_type_to_arrow_type"><code>py_type_to_arrow_type()</code></a>: Convert a Python dtype to an Arrow dtype.</li>
<li><a href="polars/datatypes.html#polarsdatatypesmaybe_cast"><code>maybe_cast()</code></a>: </li>
</ul>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsdatatypesdtype_to_ctype"><a class="header" href="#polarsdatatypesdtype_to_ctype"><code>polars.datatypes.dtype_to_ctype</code></a></h3>
<pre><code class="language-python">dtype_to_ctype(dtype: TypeDataType) -&gt; Type_SimpleCData:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def dtype_to_ctype(dtype: Type[DataType]) -&gt; Type[_SimpleCData]:
    try:
        return _DTYPE_TO_CTYPE[dtype]
    except KeyError:  # pragma: no cover
        raise NotImplementedError
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypesdtype_to_ffiname"><a class="header" href="#polarsdatatypesdtype_to_ffiname"><code>polars.datatypes.dtype_to_ffiname</code></a></h3>
<pre><code class="language-python">dtype_to_ffiname(dtype: TypeDataType) -&gt; str:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def dtype_to_ffiname(dtype: Type[DataType]) -&gt; str:
    try:
        return _DTYPE_TO_FFINAME[dtype]
    except KeyError:  # pragma: no cover
        raise NotImplementedError
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypesdtype_to_py_type"><a class="header" href="#polarsdatatypesdtype_to_py_type"><code>polars.datatypes.dtype_to_py_type</code></a></h3>
<pre><code class="language-python">dtype_to_py_type(dtype: TypeDataType) -&gt; Type:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def dtype_to_py_type(dtype: Type[DataType]) -&gt; Type:
    try:
        return _DTYPE_TO_PY_TYPE[dtype]
    except KeyError:  # pragma: no cover
        raise NotImplementedError
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypespy_type_to_dtype"><a class="header" href="#polarsdatatypespy_type_to_dtype"><code>polars.datatypes.py_type_to_dtype</code></a></h3>
<pre><code class="language-python">py_type_to_dtype(data_type: TypeAny) -&gt; TypeDataType:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def py_type_to_dtype(data_type: Type[Any]) -&gt; Type[DataType]:
    # when the passed in is already a Polars datatype, return that
    if issubclass(data_type, DataType):
        return data_type

    try:
        return _PY_TYPE_TO_DTYPE[data_type]
    except KeyError:  # pragma: no cover
        raise NotImplementedError
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypespy_type_to_arrow_type"><a class="header" href="#polarsdatatypespy_type_to_arrow_type"><code>polars.datatypes.py_type_to_arrow_type</code></a></h3>
<pre><code class="language-python">py_type_to_arrow_type(dtype: TypeAny) -&gt; pa.lib.DataType:
</code></pre>
<p>Convert a Python dtype to an Arrow dtype.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def py_type_to_arrow_type(dtype: Type[Any]) -&gt; &quot;pa.lib.DataType&quot;:
    &quot;&quot;&quot;
    Convert a Python dtype to an Arrow dtype.
    &quot;&quot;&quot;
    try:
        return _PY_TYPE_TO_ARROW_TYPE[dtype]
    except KeyError:  # pragma: no cover
        raise ValueError(f&quot;Cannot parse dtype {dtype} into Arrow dtype.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypesmaybe_cast"><a class="header" href="#polarsdatatypesmaybe_cast"><code>polars.datatypes.maybe_cast</code></a></h3>
<pre><code class="language-python">maybe_cast(el: TypeDataType, dtype: Type) -&gt; TypeDataType:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def maybe_cast(el: Type[DataType], dtype: Type) -&gt; Type[DataType]:
    # cast el if it doesn't match
    py_type = dtype_to_py_type(dtype)
    if not isinstance(el, py_type):
        el = py_type(el)
    return el
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesdatatype"><a class="header" href="#polarsdatatypesdatatype"><code>polars.datatypes.DataType</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class DataType:
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesint8"><a class="header" href="#polarsdatatypesint8"><code>polars.datatypes.Int8</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Int8(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesint16"><a class="header" href="#polarsdatatypesint16"><code>polars.datatypes.Int16</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Int16(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesint32"><a class="header" href="#polarsdatatypesint32"><code>polars.datatypes.Int32</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Int32(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesint64"><a class="header" href="#polarsdatatypesint64"><code>polars.datatypes.Int64</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Int64(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesuint8"><a class="header" href="#polarsdatatypesuint8"><code>polars.datatypes.UInt8</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class UInt8(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesuint16"><a class="header" href="#polarsdatatypesuint16"><code>polars.datatypes.UInt16</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class UInt16(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesuint32"><a class="header" href="#polarsdatatypesuint32"><code>polars.datatypes.UInt32</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class UInt32(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesuint64"><a class="header" href="#polarsdatatypesuint64"><code>polars.datatypes.UInt64</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class UInt64(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesfloat32"><a class="header" href="#polarsdatatypesfloat32"><code>polars.datatypes.Float32</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Float32(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesfloat64"><a class="header" href="#polarsdatatypesfloat64"><code>polars.datatypes.Float64</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Float64(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesboolean"><a class="header" href="#polarsdatatypesboolean"><code>polars.datatypes.Boolean</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Boolean(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesutf8"><a class="header" href="#polarsdatatypesutf8"><code>polars.datatypes.Utf8</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Utf8(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypeslist"><a class="header" href="#polarsdatatypeslist"><code>polars.datatypes.List</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class List(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesdate"><a class="header" href="#polarsdatatypesdate"><code>polars.datatypes.Date</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Date(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesdatetime"><a class="header" href="#polarsdatatypesdatetime"><code>polars.datatypes.Datetime</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Datetime(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypestime"><a class="header" href="#polarsdatatypestime"><code>polars.datatypes.Time</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Time(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypesobject"><a class="header" href="#polarsdatatypesobject"><code>polars.datatypes.Object</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Object(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsdatatypescategorical"><a class="header" href="#polarsdatatypescategorical"><code>polars.datatypes.Categorical</code></a></h1>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Categorical(DataType):
    pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsdatatypes_constructor"><a class="header" href="#module-polarsdatatypes_constructor">Module <code>polars.datatypes_constructor</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/datatypes_constructor.html#polarsdatatypes_constructorpolars_type_to_constructor"><code>polars_type_to_constructor()</code></a>: Get the right PySeries constructor for the given Polars dtype.</li>
<li><a href="polars/datatypes_constructor.html#polarsdatatypes_constructornumpy_type_to_constructor"><code>numpy_type_to_constructor()</code></a>: Get the right PySeries constructor for the given Polars dtype.</li>
<li><a href="polars/datatypes_constructor.html#polarsdatatypes_constructorpy_type_to_constructor"><code>py_type_to_constructor()</code></a>: Get the right PySeries constructor for the given Python dtype.</li>
</ul>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsdatatypes_constructorpolars_type_to_constructor"><a class="header" href="#polarsdatatypes_constructorpolars_type_to_constructor"><code>polars.datatypes_constructor.polars_type_to_constructor</code></a></h3>
<pre><code class="language-python">polars_type_to_constructor(
    dtype: TypeDataType,
) -&gt; Callable[[str, SequenceAny, bool], PySeries]:
</code></pre>
<p>Get the right PySeries constructor for the given Polars dtype.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def polars_type_to_constructor(
    dtype: Type[DataType],
) -&gt; Callable[[str, Sequence[Any], bool], &quot;PySeries&quot;]:
    &quot;&quot;&quot;
    Get the right PySeries constructor for the given Polars dtype.
    &quot;&quot;&quot;
    try:
        return _POLARS_TYPE_TO_CONSTRUCTOR[dtype]
    except KeyError:  # pragma: no cover
        raise ValueError(f&quot;Cannot construct PySeries for type {dtype}.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypes_constructornumpy_type_to_constructor"><a class="header" href="#polarsdatatypes_constructornumpy_type_to_constructor"><code>polars.datatypes_constructor.numpy_type_to_constructor</code></a></h3>
<pre><code class="language-python">numpy_type_to_constructor(
    dtype: Typenp.dtype,
) -&gt; Callable[, PySeries]:
</code></pre>
<p>Get the right PySeries constructor for the given Polars dtype.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def numpy_type_to_constructor(dtype: Type[np.dtype]) -&gt; Callable[..., &quot;PySeries&quot;]:
    &quot;&quot;&quot;
    Get the right PySeries constructor for the given Polars dtype.
    &quot;&quot;&quot;
    try:
        return _NUMPY_TYPE_TO_CONSTRUCTOR[dtype]
    except KeyError:
        return PySeries.new_object
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsdatatypes_constructorpy_type_to_constructor"><a class="header" href="#polarsdatatypes_constructorpy_type_to_constructor"><code>polars.datatypes_constructor.py_type_to_constructor</code></a></h3>
<pre><code class="language-python">py_type_to_constructor(
    dtype: TypeAny,
) -&gt; Callable[, PySeries]:
</code></pre>
<p>Get the right PySeries constructor for the given Python dtype.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def py_type_to_constructor(dtype: Type[Any]) -&gt; Callable[..., &quot;PySeries&quot;]:
    &quot;&quot;&quot;
    Get the right PySeries constructor for the given Python dtype.
    &quot;&quot;&quot;
    try:
        return _PY_TYPE_TO_CONSTRUCTOR[dtype]
    except KeyError:
        return PySeries.new_object
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternals"><a class="header" href="#module-polarsinternals">Module <code>polars.internals</code></a></h1>
<p>The modules within <code>polars.internals</code> are interdependent. To prevent cyclical imports, they all import from each other
via this <strong>init</strong> file using <code>import polars.internals as pli</code>. The imports below are being shared across this module.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalsconstruction"><a class="header" href="#module-polarsinternalsconstruction">Module <code>polars.internals.construction</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionseries_to_pyseries"><code>series_to_pyseries()</code></a>: Construct a PySeries from a Polars Series.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionarrow_to_pyseries"><code>arrow_to_pyseries()</code></a>: Construct a PySeries from an Arrow array.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionnumpy_to_pyseries"><code>numpy_to_pyseries()</code></a>: Construct a PySeries from a numpy array.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionsequence_to_pyseries"><code>sequence_to_pyseries()</code></a>: Construct a PySeries from a sequence.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionpandas_to_pyseries"><code>pandas_to_pyseries()</code></a>: Construct a PySeries from a pandas Series or DatetimeIndex.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructiondict_to_pydf"><code>dict_to_pydf()</code></a>: Construct a PyDataFrame from a dictionary of sequences.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionnumpy_to_pydf"><code>numpy_to_pydf()</code></a>: Construct a PyDataFrame from a numpy ndarray.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionsequence_to_pydf"><code>sequence_to_pydf()</code></a>: Construct a PyDataFrame from a sequence.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionarrow_to_pydf"><code>arrow_to_pydf()</code></a>: Construct a PyDataFrame from an Arrow Table.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionseries_to_pydf"><code>series_to_pydf()</code></a>: Construct a PyDataFrame from a Polars Series.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructionpandas_to_pydf"><code>pandas_to_pydf()</code></a>: Construct a PyDataFrame from a pandas DataFrame.</li>
<li><a href="polars/internals/construction.html#polarsinternalsconstructioncoerce_arrow"><code>coerce_arrow()</code></a>: </li>
</ul>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionseries_to_pyseries"><a class="header" href="#polarsinternalsconstructionseries_to_pyseries"><code>polars.internals.construction.series_to_pyseries</code></a></h3>
<pre><code class="language-python">series_to_pyseries(
    name: str, 
    values: pli.Series,
) -&gt; PySeries:
</code></pre>
<p>Construct a PySeries from a Polars Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def series_to_pyseries(
    name: str,
    values: &quot;pli.Series&quot;,
) -&gt; &quot;PySeries&quot;:
    &quot;&quot;&quot;
    Construct a PySeries from a Polars Series.
    &quot;&quot;&quot;
    values.rename(name, in_place=True)
    return values.inner()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionarrow_to_pyseries"><a class="header" href="#polarsinternalsconstructionarrow_to_pyseries"><code>polars.internals.construction.arrow_to_pyseries</code></a></h3>
<pre><code class="language-python">arrow_to_pyseries(name: str, values: pa.Array) -&gt; PySeries:
</code></pre>
<p>Construct a PySeries from an Arrow array.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def arrow_to_pyseries(name: str, values: &quot;pa.Array&quot;) -&gt; &quot;PySeries&quot;:
    &quot;&quot;&quot;
    Construct a PySeries from an Arrow array.
    &quot;&quot;&quot;
    array = coerce_arrow(values)
    return PySeries.from_arrow(name, array)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionnumpy_to_pyseries"><a class="header" href="#polarsinternalsconstructionnumpy_to_pyseries"><code>polars.internals.construction.numpy_to_pyseries</code></a></h3>
<pre><code class="language-python">numpy_to_pyseries(
    name: str, 
    values: np.ndarray, 
    strict: bool, 
    nan_to_null: bool,
) -&gt; PySeries:
</code></pre>
<p>Construct a PySeries from a numpy array.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def numpy_to_pyseries(
    name: str, values: np.ndarray, strict: bool = True, nan_to_null: bool = False
) -&gt; &quot;PySeries&quot;:
    &quot;&quot;&quot;
    Construct a PySeries from a numpy array.
    &quot;&quot;&quot;
    if not values.flags[&quot;C_CONTIGUOUS&quot;]:
        values = np.array(values)

    if len(values.shape) == 1:
        dtype = values.dtype.type
        constructor = numpy_type_to_constructor(dtype)
        if dtype == np.float32 or dtype == np.float64:
            return constructor(name, values, nan_to_null)
        else:
            return constructor(name, values, strict)
    else:
        return PySeries.new_object(name, values, strict)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionsequence_to_pyseries"><a class="header" href="#polarsinternalsconstructionsequence_to_pyseries"><code>polars.internals.construction.sequence_to_pyseries</code></a></h3>
<pre><code class="language-python">sequence_to_pyseries(
    name: str, 
    values: SequenceAny, 
    dtype: OptionalTypeDataType, 
    strict: bool,
) -&gt; PySeries:
</code></pre>
<p>Construct a PySeries from a sequence.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def sequence_to_pyseries(
    name: str,
    values: Sequence[Any],
    dtype: Optional[Type[DataType]] = None,
    strict: bool = True,
) -&gt; &quot;PySeries&quot;:
    &quot;&quot;&quot;
    Construct a PySeries from a sequence.
    &quot;&quot;&quot;
    # Empty sequence defaults to Float32 type
    if not values and dtype is None:
        dtype = Float32

    if dtype is not None:
        constructor = polars_type_to_constructor(dtype)
        pyseries = constructor(name, values, strict)
        if dtype == Date:
            pyseries = pyseries.cast(str(Date), True)
        elif dtype == Datetime:
            pyseries = pyseries.cast(str(Datetime), True)
        elif dtype == Time:
            pyseries = pyseries.cast(str(Time), True)
        elif dtype == Categorical:
            pyseries = pyseries.cast(str(Categorical), True)

        return pyseries

    else:
        value = _get_first_non_none(values)
        dtype_ = type(value) if value is not None else float

        if dtype_ == date or dtype_ == datetime:
            if not _PYARROW_AVAILABLE:  # pragma: no cover
                raise ImportError(
                    &quot;'pyarrow' is required for converting a Sequence of date or datetime values to a PySeries.&quot;
                )
            return arrow_to_pyseries(name, pa.array(values))

        elif dtype_ == list or dtype_ == tuple or dtype_ == pli.Series:
            nested_value = _get_first_non_none(value)
            nested_dtype = type(nested_value) if value is not None else float

            # logs will show a panic if we infer wrong dtype
            # and its hard to error from rust side
            # to reduce the likelihood of this happening
            # we infer the dtype of first 100 elements
            # if all() fails, we will hit the PySeries.new_object
            if not _PYARROW_AVAILABLE:
                if all(
                    isinstance(val, nested_dtype)
                    for val in values[: min(100, len(values))]
                ):  # pragma: no cover
                    dtype = py_type_to_dtype(nested_dtype)
                    try:
                        return PySeries.new_list(name, values, dtype)
                    except BaseException:
                        pass
                # pass we create an object if we get here
            else:
                try:
                    nested_arrow_dtype = py_type_to_arrow_type(nested_dtype)
                except ValueError as e:
                    raise ValueError(
                        f&quot;Cannot construct Series from sequence of {nested_dtype}.&quot;
                    ) from e

                try:
                    arrow_values = pa.array(values, pa.large_list(nested_arrow_dtype))
                    return arrow_to_pyseries(name, arrow_values)
                except pa.lib.ArrowInvalid:
                    pass

            # Convert mixed sequences like `[[12], &quot;foo&quot;, 9]`
            return PySeries.new_object(name, values, strict)
        else:
            constructor = py_type_to_constructor(dtype_)
            return constructor(name, values, strict)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionpandas_to_pyseries"><a class="header" href="#polarsinternalsconstructionpandas_to_pyseries"><code>polars.internals.construction.pandas_to_pyseries</code></a></h3>
<pre><code class="language-python">pandas_to_pyseries(
    name: str, 
    values: Union[pd.Series, pd.DatetimeIndex], 
    nan_to_none: bool,
) -&gt; PySeries:
</code></pre>
<p>Construct a PySeries from a pandas Series or DatetimeIndex.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def pandas_to_pyseries(
    name: str, values: Union[&quot;pd.Series&quot;, &quot;pd.DatetimeIndex&quot;], nan_to_none: bool = True
) -&gt; &quot;PySeries&quot;:
    &quot;&quot;&quot;
    Construct a PySeries from a pandas Series or DatetimeIndex.
    &quot;&quot;&quot;
    if not _PYARROW_AVAILABLE:  # pragma: no cover
        raise ImportError(
            &quot;'pyarrow' is required when constructing a PySeries from a pandas Series.&quot;
        )
    # TODO: Change `if not name` to `if name is not None` once name is Optional[str]
    if not name and values.name is not None:
        name = str(values.name)
    return arrow_to_pyseries(
        name, _pandas_series_to_arrow(values, nan_to_none=nan_to_none)
    )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructiondict_to_pydf"><a class="header" href="#polarsinternalsconstructiondict_to_pydf"><code>polars.internals.construction.dict_to_pydf</code></a></h3>
<pre><code class="language-python">dict_to_pydf(
    data: Dict[str, SequenceAny], 
    columns: OptionalSequencestr,
) -&gt; PyDataFrame:
</code></pre>
<p>Construct a PyDataFrame from a dictionary of sequences.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def dict_to_pydf(
    data: Dict[str, Sequence[Any]],
    columns: Optional[Sequence[str]] = None,
) -&gt; &quot;PyDataFrame&quot;:
    &quot;&quot;&quot;
    Construct a PyDataFrame from a dictionary of sequences.
    &quot;&quot;&quot;
    data_series = [pli.Series(name, values).inner() for name, values in data.items()]
    data_series = _handle_columns_arg(data_series, columns=columns)
    return PyDataFrame(data_series)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionnumpy_to_pydf"><a class="header" href="#polarsinternalsconstructionnumpy_to_pydf"><code>polars.internals.construction.numpy_to_pydf</code></a></h3>
<pre><code class="language-python">numpy_to_pydf(
    data: np.ndarray, 
    columns: OptionalSequencestr, 
    orient: Optionalstr,
) -&gt; PyDataFrame:
</code></pre>
<p>Construct a PyDataFrame from a numpy ndarray.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def numpy_to_pydf(
    data: np.ndarray,
    columns: Optional[Sequence[str]] = None,
    orient: Optional[str] = None,
) -&gt; &quot;PyDataFrame&quot;:
    &quot;&quot;&quot;
    Construct a PyDataFrame from a numpy ndarray.
    &quot;&quot;&quot;
    shape = data.shape

    if shape == (0,):
        data_series = []

    elif len(shape) == 1:
        s = pli.Series(&quot;column_0&quot;, data).inner()
        data_series = [s]

    elif len(shape) == 2:
        # Infer orientation
        if orient is None:
            warnings.warn(
                &quot;Default orientation for constructing DataFrame from numpy &quot;
                'array will change from &quot;row&quot; to &quot;column&quot; in a future version. '
                &quot;Specify orientation explicitly to silence this warning.&quot;,
                DeprecationWarning,
                stacklevel=2,
            )
            orient = &quot;row&quot;
        # Exchange if-block above for block below when removing warning
        # if orientation is None and columns is not None:
        #     orientation = &quot;col&quot; if len(columns) == shape[0] else &quot;row&quot;

        if orient == &quot;row&quot;:
            data_series = [
                pli.Series(f&quot;column_{i}&quot;, data[:, i]).inner() for i in range(shape[1])
            ]
        else:
            data_series = [
                pli.Series(f&quot;column_{i}&quot;, data[i]).inner() for i in range(shape[0])
            ]
    else:
        raise ValueError(&quot;A numpy array should not have more than two dimensions.&quot;)

    data_series = _handle_columns_arg(data_series, columns=columns)

    return PyDataFrame(data_series)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionsequence_to_pydf"><a class="header" href="#polarsinternalsconstructionsequence_to_pydf"><code>polars.internals.construction.sequence_to_pydf</code></a></h3>
<pre><code class="language-python">sequence_to_pydf(
    data: SequenceAny, 
    columns: OptionalSequencestr, 
    orient: Optionalstr,
) -&gt; PyDataFrame:
</code></pre>
<p>Construct a PyDataFrame from a sequence.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def sequence_to_pydf(
    data: Sequence[Any],
    columns: Optional[Sequence[str]] = None,
    orient: Optional[str] = None,
) -&gt; &quot;PyDataFrame&quot;:
    &quot;&quot;&quot;
    Construct a PyDataFrame from a sequence.
    &quot;&quot;&quot;
    data_series: List[&quot;PySeries&quot;]
    if len(data) == 0:
        data_series = []

    elif isinstance(data[0], pli.Series):
        data_series = []
        for i, s in enumerate(data):
            if not s.name:  # TODO: Replace by `if s.name is None` once allowed
                s.rename(f&quot;column_{i}&quot;, in_place=True)
            data_series.append(s.inner())

    elif isinstance(data[0], dict):
        pydf = PyDataFrame.read_dicts(data)
        if columns is not None:
            pydf.set_column_names(columns)
        return pydf

    elif isinstance(data[0], Sequence) and not isinstance(data[0], str):
        # Infer orientation
        if orient is None and columns is not None:
            orient = &quot;col&quot; if len(columns) == len(data) else &quot;row&quot;

        if orient == &quot;row&quot;:
            pydf = PyDataFrame.read_rows(data)
            if columns is not None:
                pydf.set_column_names(columns)
            return pydf
        else:
            data_series = [
                pli.Series(f&quot;column_{i}&quot;, data[i]).inner() for i in range(len(data))
            ]

    else:
        s = pli.Series(&quot;column_0&quot;, data).inner()
        data_series = [s]

    data_series = _handle_columns_arg(data_series, columns=columns)
    return PyDataFrame(data_series)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionarrow_to_pydf"><a class="header" href="#polarsinternalsconstructionarrow_to_pydf"><code>polars.internals.construction.arrow_to_pydf</code></a></h3>
<pre><code class="language-python">arrow_to_pydf(
    data: pa.Table, 
    columns: OptionalSequencestr, 
    rechunk: bool,
) -&gt; PyDataFrame:
</code></pre>
<p>Construct a PyDataFrame from an Arrow Table.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def arrow_to_pydf(
    data: &quot;pa.Table&quot;, columns: Optional[Sequence[str]] = None, rechunk: bool = True
) -&gt; &quot;PyDataFrame&quot;:
    &quot;&quot;&quot;
    Construct a PyDataFrame from an Arrow Table.
    &quot;&quot;&quot;
    if not _PYARROW_AVAILABLE:  # pragma: no cover
        raise ImportError(
            &quot;'pyarrow' is required when constructing a PyDataFrame from an Arrow Table.&quot;
        )
    if columns is not None:
        try:
            data = data.rename_columns(columns)
        except pa.lib.ArrowInvalid as e:
            raise ValueError(
                &quot;Dimensions of columns arg must match data dimensions.&quot;
            ) from e

    data_dict = {}
    for i, column in enumerate(data):
        # extract the name before casting
        if column._name is None:
            name = f&quot;column_{i}&quot;
        else:
            name = column._name

        column = coerce_arrow(column)
        data_dict[name] = column

    batches = pa.table(data_dict).to_batches()
    pydf = PyDataFrame.from_arrow_record_batches(batches)
    if rechunk:
        pydf = pydf.rechunk()
    return pydf
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionseries_to_pydf"><a class="header" href="#polarsinternalsconstructionseries_to_pydf"><code>polars.internals.construction.series_to_pydf</code></a></h3>
<pre><code class="language-python">series_to_pydf(
    data: pli.Series, 
    columns: OptionalSequencestr,
) -&gt; PyDataFrame:
</code></pre>
<p>Construct a PyDataFrame from a Polars Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def series_to_pydf(
    data: &quot;pli.Series&quot;,
    columns: Optional[Sequence[str]] = None,
) -&gt; &quot;PyDataFrame&quot;:
    &quot;&quot;&quot;
    Construct a PyDataFrame from a Polars Series.
    &quot;&quot;&quot;
    data_series = [data.inner()]
    data_series = _handle_columns_arg(data_series, columns=columns)
    return PyDataFrame(data_series)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructionpandas_to_pydf"><a class="header" href="#polarsinternalsconstructionpandas_to_pydf"><code>polars.internals.construction.pandas_to_pydf</code></a></h3>
<pre><code class="language-python">pandas_to_pydf(
    data: pd.DataFrame, 
    columns: OptionalSequencestr, 
    rechunk: bool, 
    nan_to_none: bool,
) -&gt; PyDataFrame:
</code></pre>
<p>Construct a PyDataFrame from a pandas DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def pandas_to_pydf(
    data: &quot;pd.DataFrame&quot;,
    columns: Optional[Sequence[str]] = None,
    rechunk: bool = True,
    nan_to_none: bool = True,
) -&gt; &quot;PyDataFrame&quot;:
    &quot;&quot;&quot;
    Construct a PyDataFrame from a pandas DataFrame.
    &quot;&quot;&quot;
    if not _PYARROW_AVAILABLE:  # pragma: no cover
        raise ImportError(
            &quot;'pyarrow' is required when constructing a PyDataFrame from a pandas DataFrame.&quot;
        )
    len = data.shape[0]
    arrow_dict = {
        str(col): _pandas_series_to_arrow(
            data[col], nan_to_none=nan_to_none, min_len=len
        )
        for col in data.columns
    }
    arrow_table = pa.table(arrow_dict)
    return arrow_to_pydf(arrow_table, columns=columns, rechunk=rechunk)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsconstructioncoerce_arrow"><a class="header" href="#polarsinternalsconstructioncoerce_arrow"><code>polars.internals.construction.coerce_arrow</code></a></h3>
<pre><code class="language-python">coerce_arrow(array: pa.Array) -&gt; pa.Array:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def coerce_arrow(array: &quot;pa.Array&quot;) -&gt; &quot;pa.Array&quot;:
    # also coerces timezone to naive representation
    # units are accounted for by pyarrow
    if isinstance(array, pa.TimestampArray):
        if array.type.tz is not None:
            warnings.warn(
                &quot;Conversion of timezone aware to naive datetimes. TZ information may be lost&quot;,
            )
        ts_ms = pa.compute.cast(array, pa.timestamp(&quot;ms&quot;), safe=False)
        ms = pa.compute.cast(ts_ms, pa.int64())
        del ts_ms
        array = pa.compute.cast(ms, pa.timestamp(&quot;ms&quot;))
        del ms
    # note: Decimal256 could not be cast to float
    elif isinstance(array.type, pa.Decimal128Type):
        array = pa.compute.cast(array, pa.float64())

    if hasattr(array, &quot;num_chunks&quot;) and array.num_chunks &gt; 1:
        # we have to coerce before combining chunks, because pyarrow panics if
        # offsets overflow
        if pa.types.is_string(array.type):
            array = pa.compute.cast(array, pa.large_utf8())
        elif pa.types.is_list(array.type):
            # pyarrow does not seem to support casting from list to largelist
            # so we use convert to large list ourselves and do the re-alloc on polars/arrow side
            chunks = []
            for arr in array.iterchunks():
                chunks.append(pli.Series._from_arrow(&quot;&quot;, arr).to_arrow())
            array = pa.chunked_array(chunks)

        array = array.combine_chunks()
    return array
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalsexpr"><a class="header" href="#module-polarsinternalsexpr">Module <code>polars.internals.expr</code></a></h1>
<p><strong>Functions:</strong></p>
<p>: 
: Helper function that converts args to expressions.</p>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprwrap_expr"><a class="header" href="#polarsinternalsexprwrap_expr"><code>polars.internals.expr.wrap_expr</code></a></h3>
<pre><code class="language-python">wrap_expr(pyexpr: PyExpr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def wrap_expr(pyexpr: &quot;PyExpr&quot;) -&gt; &quot;Expr&quot;:
    return Expr._from_pyexpr(pyexpr)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpr_to_lit_or_expr"><a class="header" href="#polarsinternalsexprexpr_to_lit_or_expr"><code>polars.internals.expr.expr_to_lit_or_expr</code></a></h3>
<pre><code class="language-python">expr_to_lit_or_expr(
    expr: Union[Expr, bool, int, float, str, tp.List[Expr], tp.List[str], pli.Series], 
    str_to_lit: bool,
) -&gt; Expr:
</code></pre>
<p>Helper function that converts args to expressions.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>expr</code>]: Any argument.</li>
<li>[<code>str_to_lit</code>]: If True string argument <code>&quot;foo&quot;</code> will be converted to <code>lit(&quot;foo&quot;)</code>,
If False it will be converted to <code>col(&quot;foo&quot;)</code></li>
</ul>
<p><strong>Returns:</strong></p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def expr_to_lit_or_expr(
    expr: Union[Expr, bool, int, float, str, tp.List[Expr], tp.List[str], &quot;pli.Series&quot;],
    str_to_lit: bool = True,
) -&gt; Expr:
    &quot;&quot;&quot;
    Helper function that converts args to expressions.

    Parameters
    ----------
    expr
        Any argument.
    str_to_lit
        If True string argument `&quot;foo&quot;` will be converted to `lit(&quot;foo&quot;)`,
        If False it will be converted to `col(&quot;foo&quot;)`

    Returns
    -------

    &quot;&quot;&quot;
    if isinstance(expr, str) and not str_to_lit:
        return pli.col(expr)
    elif (
        isinstance(expr, (int, float, str, pli.Series, datetime, date)) or expr is None
    ):
        return pli.lit(expr)
    elif isinstance(expr, list):
        return [expr_to_lit_or_expr(e, str_to_lit=str_to_lit) for e in expr]  # type: ignore[return-value]
    else:
        return expr
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsexprexpr"><a class="header" href="#polarsinternalsexprexpr"><code>polars.internals.expr.Expr</code></a></h1>
<p>Expressions that can be used in various contexts.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpreq"><code>eq()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprneq"><code>neq()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprgt"><code>gt()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprgt_eq"><code>gt_eq()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprlt_eq"><code>lt_eq()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprlt"><code>lt()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpr__array_ufunc__function"><code>function()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprsqrt"><code>sqrt()</code></a>: Compute the square root of the elements</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpralias"><code>alias()</code></a>: Rename the output of an expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprexclude"><code>exclude()</code></a>: Exclude certain columns from a wildcard/regex selection.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprkeep_name"><code>keep_name()</code></a>: Keep the original root name of the expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprprefix"><code>prefix()</code></a>: Add a prefix the to root column name of the expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprsuffix"><code>suffix()</code></a>: Add a suffix the to root column name of the expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_not"><code>is_not()</code></a>: Negate a boolean expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_null"><code>is_null()</code></a>: Create a boolean expression returning <code>True</code> where the expression contains null values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_not_null"><code>is_not_null()</code></a>: Create a boolean expression returning <code>True</code> where the expression does not contain null values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_finite"><code>is_finite()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are finite.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_infinite"><code>is_infinite()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are infinite.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_nan"><code>is_nan()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are NaN (Not A Number).</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_not_nan"><code>is_not_nan()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are not NaN (Not A Number).</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpragg_groups"><code>agg_groups()</code></a>: Get the group indexes of the group by operation.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcount"><code>count()</code></a>: Count the number of values in this expression</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprlen"><code>len()</code></a>: Alias for count</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprslice"><code>slice()</code></a>: Slice the Series.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprdrop_nulls"><code>drop_nulls()</code></a>: Syntactic sugar for:</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcumsum"><code>cumsum()</code></a>: Get an array with the cumulative sum computed at every element.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcumprod"><code>cumprod()</code></a>: Get an array with the cumulative product computed at every element.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcummin"><code>cummin()</code></a>: Get an array with the cumulative min computed at every element.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcummax"><code>cummax()</code></a>: Get an array with the cumulative max computed at every element.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprfloor"><code>floor()</code></a>: Floor underlying floating point array to the lowest integers smaller or equal to the float value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprround"><code>round()</code></a>: Round underlying floating point data by <code>decimals</code> digits.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprdot"><code>dot()</code></a>: Compute the dot/inner product between two Expressions</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprmode"><code>mode()</code></a>: Compute the most occurring value(s). Can return multiple Values</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcast"><code>cast()</code></a>: Cast between data types.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprsort"><code>sort()</code></a>: Sort this column. In projection/ selection context the whole column is sorted.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarg_sort"><code>arg_sort()</code></a>: Get the index values that would sort this column.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarg_max"><code>arg_max()</code></a>: Get the index of the maximal value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarg_min"><code>arg_min()</code></a>: Get the index of the minimal value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprsort_by"><code>sort_by()</code></a>: Sort this column by the ordering of another column, or multiple other columns.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprtake"><code>take()</code></a>: Take values by index.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprfill_null"><code>fill_null()</code></a>: Fill none value with a fill value or strategy</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprfill_nan"><code>fill_nan()</code></a>: Fill none value with a fill value</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprforward_fill"><code>forward_fill()</code></a>: Fill missing values with the latest seen values</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprbackward_fill"><code>backward_fill()</code></a>: Fill missing values with the next to be seen values</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprreverse"><code>reverse()</code></a>: Reverse the selection.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprstd"><code>std()</code></a>: Get standard deviation.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprvar"><code>var()</code></a>: Get variance.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprmax"><code>max()</code></a>: Get maximum value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprmin"><code>min()</code></a>: Get minimum value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprsum"><code>sum()</code></a>: Get sum value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprmean"><code>mean()</code></a>: Get mean value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprmedian"><code>median()</code></a>: Get median value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprn_unique"><code>n_unique()</code></a>: Count unique values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarg_unique"><code>arg_unique()</code></a>: Get index of first unique value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprunique"><code>unique()</code></a>: Get unique values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprfirst"><code>first()</code></a>: Get the first value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprlast"><code>last()</code></a>: Get the last value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprlist"><code>list()</code></a>: Aggregate to list.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprover"><code>over()</code></a>: Apply window function over a subgroup.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_unique"><code>is_unique()</code></a>: Get mask of unique values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_first"><code>is_first()</code></a>: Get a mask of the first unique value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_duplicated"><code>is_duplicated()</code></a>: Get mask of duplicated values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprquantile"><code>quantile()</code></a>: Get quantile value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprfilter"><code>filter()</code></a>: Filter a single column.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprwhere"><code>where()</code></a>: Alias for filter</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprmap"><code>map()</code></a>: Apply a custom python function. This function must produce a <code>Series</code>. Any other value will be stored as</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprapply"><code>apply()</code></a>: Apply a custom function in a GroupBy or Projection context.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprapplywrap_f"><code>wrap_f()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprflatten"><code>flatten()</code></a>: Alias for explode.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprexplode"><code>explode()</code></a>: Explode a list or utf8 Series. This means that every item is expanded to a new row.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprtake_every"><code>take_every()</code></a>: Take every nth value in the Series and return as a new Series.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprhead"><code>head()</code></a>: Take the first n values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprtail"><code>tail()</code></a>: Take the last n values.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprpow"><code>pow()</code></a>: Raise expression to the power of exponent.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_in"><code>is_in()</code></a>: Check if elements of this Series are in the right Series, or List values of the right Series.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrepeat_by"><code>repeat_by()</code></a>: Repeat the elements in this Series <code>n</code> times by dictated by the number given by <code>by</code>.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexpris_between"><code>is_between()</code></a>: Check if this expression is between start and end.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprdt"><code>dt()</code></a>: Create an object namespace of all datetime related methods.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprstr"><code>str()</code></a>: Create an object namespace of all string related methods.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarr"><code>arr()</code></a>: Create an object namespace of all datetime related methods.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprhash"><code>hash()</code></a>: Hash the Series.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprreinterpret"><code>reinterpret()</code></a>: Reinterpret the underlying bits as a signed/unsigned integer.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprinspect"><code>inspect()</code></a>: Prints the value that this expression evaluates to and passes on the value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprinspectinspect"><code>inspect()</code></a>: </li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_min"><code>rolling_min()</code></a>: apply a rolling min (moving min) over the values in this array.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_max"><code>rolling_max()</code></a>: Apply a rolling max (moving max) over the values in this array.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_mean"><code>rolling_mean()</code></a>: Apply a rolling mean (moving mean) over the values in this array.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_sum"><code>rolling_sum()</code></a>: Apply a rolling sum (moving sum) over the values in this array.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_std"><code>rolling_std()</code></a>: Compute a rolling std dev</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_var"><code>rolling_var()</code></a>: Compute a rolling variance.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_apply"><code>rolling_apply()</code></a>: Allows a custom rolling window function.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_median"><code>rolling_median()</code></a>: Compute a rolling median</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_quantile"><code>rolling_quantile()</code></a>: Compute a rolling quantile</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrolling_skew"><code>rolling_skew()</code></a>: Compute a rolling skew</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprabs"><code>abs()</code></a>: Take absolute values</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprargsort"><code>argsort()</code></a>: Index location of the sorted variant of this Series.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprrank"><code>rank()</code></a>: Assign ranks to data, dealing with ties appropriately.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprdiff"><code>diff()</code></a>: Calculate the n-th discrete difference.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprskew"><code>skew()</code></a>: Compute the sample skewness of a data set.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprkurtosis"><code>kurtosis()</code></a>: Compute the kurtosis (Fisher or Pearson) of a dataset.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprclip"><code>clip()</code></a>: Clip (limit) the values in an array.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprlower_bound"><code>lower_bound()</code></a>: Returns a unit Series with the lowest value possible for the dtype of this expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprupper_bound"><code>upper_bound()</code></a>: Returns a unit Series with the highest value possible for the dtype of this expression.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprstr_concat"><code>str_concat()</code></a>: Vertically concat the values in the Series to a single string value.</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprsin"><code>sin()</code></a>: Compute the element-wise value for Trigonometric sine on an array</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprcos"><code>cos()</code></a>: Compute the element-wise value for Trigonometric cosine on an array</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprtan"><code>tan()</code></a>: Compute the element-wise value for Trigonometric tangent on an array</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarcsin"><code>arcsin()</code></a>: Compute the element-wise value for Trigonometric sine on an array</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarccos"><code>arccos()</code></a>: Compute the element-wise value for Trigonometric cosine on an array</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprarctan"><code>arctan()</code></a>: Compute the element-wise value for Trigonometric tangent on an array</li>
<li><a href="polars/internals/expr/Expr.html#polarsinternalsexprexprreshape"><code>reshape()</code></a>: Reshape this Expr to a flat series, shape: (len,)</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Expr:
    &quot;&quot;&quot;
    Expressions that can be used in various contexts.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._pyexpr: PyExpr

    @staticmethod
    def _from_pyexpr(pyexpr: &quot;PyExpr&quot;) -&gt; &quot;Expr&quot;:
        self = Expr.__new__(Expr)
        self._pyexpr = pyexpr
        return self

    def __to_pyexpr(self, other: Any) -&gt; &quot;PyExpr&quot;:
        return self.__to_expr(other)._pyexpr

    def __to_expr(self, other: Any) -&gt; &quot;Expr&quot;:
        if isinstance(other, Expr):
            return other
        return pli.lit(other)

    def __bool__(self) -&gt; &quot;Expr&quot;:
        raise ValueError(
            &quot;Since Expr are lazy, the truthiness of an Expr is ambiguous. \
            Hint: use '&amp;' or '|' to chain Expr together, not and/or.&quot;
        )

    def __invert__(self) -&gt; &quot;Expr&quot;:
        return self.is_not()

    def __xor__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._xor(self.__to_pyexpr(other)))

    def __rxor__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._xor(self.__to_pyexpr(other)))

    def __and__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._and(self.__to_pyexpr(other)))

    def __rand__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._and(self.__to_pyexpr(other)))

    def __or__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._or(self.__to_pyexpr(other)))

    def __ror__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other)._or(self._pyexpr))

    def __add__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr + self.__to_pyexpr(other))

    def __radd__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) + self._pyexpr)

    def __sub__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr - self.__to_pyexpr(other))

    def __rsub__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) - self._pyexpr)

    def __mul__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr * self.__to_pyexpr(other))

    def __rmul__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) * self._pyexpr)

    def __truediv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr / self.__to_pyexpr(other))

    def __rtruediv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) / self._pyexpr)

    def __floordiv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr // self.__to_pyexpr(other))

    def __rfloordiv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) // self._pyexpr)

    def __mod__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr % self.__to_pyexpr(other))

    def __rmod__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) % self._pyexpr)

    def __pow__(self, power: float, modulo: None = None) -&gt; &quot;Expr&quot;:
        return self.pow(power)

    def __ge__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.gt_eq(self.__to_expr(other))

    def __le__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.lt_eq(self.__to_expr(other))

    def __eq__(self, other: Any) -&gt; &quot;Expr&quot;:  # type: ignore[override]
        return self.eq(self.__to_expr(other))

    def __ne__(self, other: Any) -&gt; &quot;Expr&quot;:  # type: ignore[override]
        return self.neq(self.__to_expr(other))

    def __lt__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.lt(self.__to_expr(other))

    def __gt__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.gt(self.__to_expr(other))

    def eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.eq(other._pyexpr))

    def neq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.neq(other._pyexpr))

    def gt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt(other._pyexpr))

    def gt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt_eq(other._pyexpr))

    def lt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt_eq(other._pyexpr))

    def lt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt(other._pyexpr))

    def __neg__(self) -&gt; &quot;Expr&quot;:
        return pli.lit(0) - self  # type: ignore

    def __array_ufunc__(
        self, ufunc: Callable[..., Any], method: str, *inputs: Any, **kwargs: Any
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Numpy universal functions.
        &quot;&quot;&quot;
        out_type = ufunc(np.array([1])).dtype
        if &quot;float&quot; in str(out_type):
            dtype = Float64  # type: ignore
        else:
            dtype = None  # type: ignore

        args = [inp for inp in inputs if not isinstance(inp, Expr)]

        def function(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return ufunc(s, *args, **kwargs)  # pragma: no cover

        if &quot;dtype&quot; in kwargs:
            dtype = kwargs[&quot;dtype&quot;]

        return self.map(function, return_dtype=dtype)

    def sqrt(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements
        &quot;&quot;&quot;
        return self ** 0.5

    def alias(self, name: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Rename the output of an expression.

        Parameters
        ----------
        name
            New name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (3, 2)
        ╭─────┬──────╮
        │ a   ┆ b    │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     col(&quot;a&quot;).alias(&quot;bar&quot;),
        &gt;&gt;&gt;     col(&quot;b&quot;).alias(&quot;foo&quot;)
        &gt;&gt;&gt; ])
        shape: (3, 2)
        ╭─────┬──────╮
        │ bar ┆ foo  │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.alias(name))

    def exclude(self, columns: Union[str, tp.List[str]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
         Exclude certain columns from a wildcard/regex selection.

         You may also use regexes int he exclude list. They must start with `^` and end with `$`.

         Parameters
         ----------
         columns
             Column(s) to exclude from selection

         Examples
         --------

         &gt;&gt;&gt; df = pl.DataFrame({
         &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
         &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
         &gt;&gt;&gt;     &quot;c&quot;: [None, 2, 1]
         &gt;&gt;&gt; })
         &gt;&gt;&gt; df
         shape: (3, 3)
         ╭─────┬──────┬──────╮
         │ a   ┆ b    ┆ c    │
         │ --- ┆ ---  ┆ ---  │
         │ i64 ┆ str  ┆ i64  │
         ╞═════╪══════╪══════╡
         │ 1   ┆ &quot;a&quot;  ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ &quot;b&quot;  ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ null ┆ 1    │
         ╰─────┴──────┴──────╯
         &gt;&gt;&gt; df.select(col(&quot;*&quot;).exclude(&quot;b&quot;))
        shape: (3, 2)
         ╭─────┬──────╮
         │ a   ┆ c    │
         │ --- ┆ ---  │
         │ i64 ┆ i64  │
         ╞═════╪══════╡
         │ 1   ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ 1    │
         ╰─────┴──────╯
        &quot;&quot;&quot;
        if isinstance(columns, str):
            columns = [columns]
        return wrap_expr(self._pyexpr.exclude(columns))

    def keep_name(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Keep the original root name of the expression.

        Examples
        --------

        A groupby aggregation often changes the name of a column.
        With `keep_name` we can keep the original name of the column

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt; &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt; &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b_agg_list │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯
        &gt;&gt;&gt; # keep the original column name
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list().keep_name())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b          │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯

        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.keep_name())

    def prefix(self, prefix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a prefix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().suffix(&quot;_reverse&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ A_reverse ┆ fruits_reverse ┆ B_reverse ┆ cars_reverse │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.prefix(prefix))

    def suffix(self, suffix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a suffix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().prefix(&quot;reverse_&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ reverse_A ┆ reverse_fruits ┆ reverse_B ┆ reverse_cars │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.suffix(suffix))

    def is_not(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Negate a boolean expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [True, False, False],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
        &gt;&gt;&gt; })
        shape: (3, 2)
        ╭───────┬──────╮
        │ a     ┆ b    │
        │ ---   ┆ ---  │
        │ bool  ┆ str  │
        ╞═══════╪══════╡
        │ true  ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ null │
        ╰───────┴──────╯
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).is_not())
        shape: (3, 1)
        ╭───────╮
        │ a     │
        │ ---   │
        │ bool  │
        ╞═══════╡
        │ false │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ╰───────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not())

    def is_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression contains null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_null())

    def is_not_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression does not contain null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_null())

    def is_finite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are finite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_finite())

    def is_infinite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are infinite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_infinite())

    def is_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_nan())

    def is_not_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are not NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_nan())

    def agg_groups(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the group indexes of the group by operation.
        Should be used in aggregation context only.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.agg_groups())

    def count(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count the number of values in this expression&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.count())

    def len(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for count
        Count the number of values in this expression
        &quot;&quot;&quot;
        return self.count()

    def slice(self, offset: int, length: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Slice the Series.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.slice(offset, length))

    def drop_nulls(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Syntactic sugar for:

        &gt;&gt;&gt; pl.col(&quot;foo&quot;).filter(pl.col(&quot;foo&quot;).is_not_null())
        &quot;&quot;&quot;
        return self.filter(self.is_not_null())

    def cumsum(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumsum(reverse))

    def cumprod(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumprod(reverse))

    def cummin(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummin(reverse))

    def cummax(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummax(reverse))

    def floor(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.floor())

    def round(self, decimals: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            Number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.round(decimals))

    def dot(self, other: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Expressions

        Parameters
        ----------
        other
            Expression to compute dot product with
        &quot;&quot;&quot;
        other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.dot(other._pyexpr))

    def mode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mode())

    def cast(self, dtype: Type[Any], strict: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow
        &quot;&quot;&quot;
        dtype = py_type_to_dtype(dtype)
        return wrap_expr(self._pyexpr.cast(dtype, strict))

    def sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column. In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sort(reverse))

    def arg_sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index values that would sort this column.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.

        Returns
        -------
        out
            Series of type UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_sort(reverse))

    def arg_max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_max())

    def arg_min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_min())

    def sort_by(
        self,
        by: Union[&quot;Expr&quot;, str, tp.List[Union[&quot;Expr&quot;, str]]],
        reverse: Union[bool, tp.List[bool]] = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column by the ordering of another column, or multiple other columns.
        In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        by
            The column(s) used for sorting.
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        if not isinstance(by, list):
            by = [by]
        if not isinstance(reverse, list):
            reverse = [reverse]
        by = _selection_to_pyexpr_list(by)

        return wrap_expr(self._pyexpr.sort_by(by, reverse))

    def take(
        self, index: Union[tp.List[int], &quot;Expr&quot;, &quot;pli.Series&quot;, np.ndarray]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        index
            An expression that leads to a UInt32 dtyped Series.

        Returns
        -------
        Values taken by index
        &quot;&quot;&quot;
        if isinstance(index, (list, np.ndarray)):
            index = pli.lit(pli.Series(&quot;&quot;, index, dtype=UInt32))  # type: ignore
        elif isinstance(index, pli.Series):
            index = pli.lit(index)  # type: ignore
        else:
            index = pli.expr_to_lit_or_expr(index, str_to_lit=False)  # type: ignore
        return pli.wrap_expr(self._pyexpr.take(index._pyexpr))  # type: ignore

    def shift(self, periods: int = 1) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift(periods))

    def shift_and_fill(self, periods: int, fill_value: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.shift_and_fill(periods, fill_value._pyexpr))

    def fill_null(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value or strategy

        fill_value
            Fill null strategy or a value
                   * &quot;backward&quot;
                   * &quot;forward&quot;
                   * &quot;min&quot;
                   * &quot;max&quot;
                   * &quot;mean&quot;
                   * &quot;one&quot;
                   * &quot;zero&quot;
        &quot;&quot;&quot;
        # we first must check if it is not an expr, as expr does not implement __bool__
        # and thus leads to a value error in the second comparisson.
        if not isinstance(fill_value, Expr) and fill_value in [
            &quot;backward&quot;,
            &quot;forward&quot;,
            &quot;min&quot;,
            &quot;max&quot;,
            &quot;mean&quot;,
            &quot;zero&quot;,
            &quot;one&quot;,
        ]:
            return wrap_expr(self._pyexpr.fill_null_with_strategy(fill_value))

        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_null(fill_value._pyexpr))

    def fill_nan(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_nan(fill_value._pyexpr))

    def forward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the latest seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.forward_fill())

    def backward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the next to be seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.backward_fill())

    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the selection.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reverse())

    def std(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get standard deviation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.std())

    def var(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get variance.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.var())

    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get maximum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.max())

    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get minimum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.min())

    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get sum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sum())

    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mean value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mean())

    def median(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get median value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.median())

    def n_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.n_unique())

    def arg_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get index of first unique value.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_unique())

    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.unique())

    def first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the first value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.first())

    def last(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the last value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.last())

    def list(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Aggregate to list.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.list())

    def over(self, expr: Union[str, &quot;Expr&quot;, tp.List[Union[&quot;Expr&quot;, str]]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply window function over a subgroup.
        This is similar to a groupby + aggregation + self join.
        Or similar to [window functions in Postgres](https://www.postgresql.org/docs/9.1/tutorial-window.html)

        Parameters
        ----------
        expr
            Column(s) to group by.

        Examples
        --------

        &gt;&gt;&gt; df = DataFrame({
        &gt;&gt;&gt;    &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
        &gt;&gt;&gt;    &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
        &gt;&gt;&gt;})
        &gt;&gt;&gt; (df.lazy()
        &gt;&gt;&gt;    .select([
        &gt;&gt;&gt;       pl.col(&quot;groups&quot;)
        &gt;&gt;&gt;       sum(&quot;values&quot;).over(&quot;groups&quot;)
        &gt;&gt;&gt;   ]).collect())
            ╭────────┬────────╮
            │ groups ┆ values │
            │ ---    ┆ ---    │
            │ i32    ┆ i32    │
            ╞════════╪════════╡
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ ...    ┆ ...    │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ╰────────┴────────╯

        &quot;&quot;&quot;

        pyexprs = _selection_to_pyexpr_list(expr)

        return wrap_expr(self._pyexpr.over(pyexprs))

    def is_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of unique values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_unique())

    def is_first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_first())

    def is_duplicated(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of duplicated values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_duplicated())

    def quantile(self, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get quantile value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.quantile(quantile))

    def filter(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Filter a single column.
        Mostly useful in in aggregation context. If you want to filter on a DataFrame level, use `LazyFrame.filter`.

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.filter(predicate._pyexpr))

    def where(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for filter

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return self.filter(predicate)

    def map(
        self,
        f: Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;],
        return_dtype: Optional[Type[DataType]] = None,
        agg_list: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom python function. This function must produce a `Series`. Any other value will be stored as
        null/missing. If you want to apply a function over single values, consider using `apply`.

        [read more in the book](https://pola-rs.github.io/polars-book/user-guide/howcani/apply/udfs.html)

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.
        agg_list

        &quot;&quot;&quot;
        if return_dtype is not None:
            return_dtype = py_type_to_dtype(return_dtype)
        return wrap_expr(self._pyexpr.map(f, return_dtype, agg_list))

    def apply(
        self,
        f: Union[Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;], Callable[[Any], Any]],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom function in a GroupBy or Projection context.

        Depending on the context it has the following behavior:

        ## Context

        * Select/Project
            expected type `f`: Callable[[Any], Any]
            Applies a python function over each individual value in the column.
        * GroupBy
            expected type `f`: Callable[[Series], Series]
            Applies a python function over each group.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
                   &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})
        &gt;&gt;&gt; df
         .lazy()
         .groupby(&quot;b&quot;)
         .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
         .collect()
        )
        shape: (3, 2)
        ╭─────┬─────╮
        │ b   ┆ a   │
        │ --- ┆ --- │
        │ str ┆ i64 │
        ╞═════╪═════╡
        │ a   ┆ 1   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 2   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ c   ┆ 2   │
        ╰─────┴─────╯

        &quot;&quot;&quot;

        # input x: Series of type list containing the group values
        def wrap_f(x: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)

        return self.map(wrap_f, agg_list=True)

    def flatten(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for explode.

        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.explode())

    def explode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.explode())

    def take_every(self, n: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as a new Series.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take_every(n))

    def head(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the first n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.head(n))

    def tail(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the last n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.tail(n))

    def pow(self, exponent: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Raise expression to the power of exponent.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.pow(exponent))

    def is_in(self, other: Union[&quot;Expr&quot;, tp.List[Any]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Parameters
        ----------
        other
            Series of primitive type or List type.

        Returns
        -------
        Expr that evaluates to a Boolean Series.
        &quot;&quot;&quot;
        if isinstance(other, list):
            other = pli.lit(pli.Series(other))
        else:
            other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.is_in(other._pyexpr))

    def repeat_by(self, by: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Repeat the elements in this Series `n` times by dictated by the number given by `by`.
        The elements are expanded into a `List`

        Parameters
        ----------
        by
            Numeric column that determines how often the values will be repeated.
            The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.

        Returns
        -------
        Series of type List
        &quot;&quot;&quot;
        by = expr_to_lit_or_expr(by, False)
        return wrap_expr(self._pyexpr.repeat_by(by._pyexpr))

    def is_between(
        self, start: Union[&quot;Expr&quot;, datetime], end: Union[&quot;Expr&quot;, datetime]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if this expression is between start and end.
        &quot;&quot;&quot;
        cast_to_datetime = False
        if isinstance(start, datetime):
            start = pli.lit(start)
            cast_to_datetime = True
        if isinstance(end, datetime):
            end = pli.lit(end)
            cast_to_datetime = True
        if cast_to_datetime:
            expr = self.cast(Datetime)
        else:
            expr = self
        return ((expr &gt; start) &amp; (expr &lt; end)).alias(&quot;is_between&quot;)

    @property
    def dt(self) -&gt; &quot;ExprDateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprDateTimeNameSpace(self)

    @property
    def str(self) -&gt; &quot;ExprStringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return ExprStringNameSpace(self)

    @property
    def arr(self) -&gt; &quot;ExprListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprListNameSpace(self)

    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `Datetime`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hash(k0, k1, k2, k3))

    def reinterpret(self, signed: bool) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reinterpret(signed))

    def inspect(self, fmt: str = &quot;{}&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Prints the value that this expression evaluates to and passes on the value.

        &gt;&gt;&gt; df.select(pl.col(&quot;foo&quot;).cumsum().inspect(&quot;value is: {}&quot;).alias(&quot;bar&quot;))
        &quot;&quot;&quot;

        def inspect(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            print(fmt.format(s))  # type: ignore
            return s

        return self.map(inspect, return_dtype=None, agg_list=True)

    def interpolate(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.interpolate())

    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_min(window_size, weights, min_periods, center)
        )

    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_max(window_size, weights, min_periods, center)
        )

    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0]
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_mean(window_size=2)
        &gt;&gt;&gt; ])
        shape: (6, 1)
        ┌──────┐
        │ A    │
        │ ---  │
        │ f64  │
        ╞══════╡
        │ null │
        ├╌╌╌╌╌╌┤
        │ 4.5  │
        ├╌╌╌╌╌╌┤
        │ 7    │
        ├╌╌╌╌╌╌┤
        │ 4    │
        ├╌╌╌╌╌╌┤
        │ 9    │
        ├╌╌╌╌╌╌┤
        │ 13   │
        └──────┘

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_mean(window_size, weights, min_periods, center)
        )

    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_sum(window_size, weights, min_periods, center)
        )

    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_std(window_size, weights, min_periods, center)
        )

    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_var(window_size, weights, min_periods, center)
        )

    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.

        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum

        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function


        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 2.0, 9.0, 2.0, 13.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_apply(3, lambda s: s.std())
        &gt;&gt;&gt; ])
        shape: (5, 1)
        ┌────────────────────┐
        │ A                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.358898943540674  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.041451884327381  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5.5677643628300215 │
        └────────────────────┘

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_apply(window_size, function))

    def rolling_median(self, window_size: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_median(window_size))

    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_quantile(window_size, quantile))

    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_skew(window_size, bias))

    def abs(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.abs())

    def argsort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.
        Parameters
        ----------
        reverse
            Reverse the ordering. Default is from low to high.
        &quot;&quot;&quot;
        return pli.argsort_by([self], [reverse])

    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rank(method))

    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.diff(n, null_behavior))

    def skew(self, bias: bool = True) -&gt; &quot;Expr&quot;:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.skew(bias))

    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.kurtosis(fisher, bias))

    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        min_val = pli.lit(min_val)  # type: ignore
        max_val = pli.lit(max_val)  # type: ignore

        return (
            pli.when(self &lt; min_val)  # type: ignore
            .then(min_val)
            .when(self &gt; max_val)
            .then(max_val)
            .otherwise(self)
        ).keep_name()

    def lower_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the lowest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lower_bound())

    def upper_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the highest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.upper_bound())

    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, None, 2]})
        &gt;&gt;&gt; df = df.select(pl.col(&quot;foo&quot;).str_concat(&quot;-&quot;))
        shape: (1, 1)
        ┌──────────┐
        │ foo      │
        │ ---      │
        │ str      │
        ╞══════════╡
        │ 1-null-2 │
        └──────────┘
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_concat(delimiter))

    def sin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).sin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.8414709848078965 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore

    def cos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).cos())
        shape: (1, 1)
        ┌─────┐
        │ a   │
        │ --- │
        │ f64 │
        ╞═════╡
        │ 1   │
        └─────┘
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore

    def tan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).tan())
        shape: (1, 1)
        ┌───────────────────┐
        │ a                 │
        │ ---               │
        │ f64               │
        ╞═══════════════════╡
        │ 1.557407724654902 │
        └───────────────────┘
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore

    def arcsin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arcsin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore

    def arccos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arccos())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore

    def arctan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arctan())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.7853981633974483 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore

    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reshape this Expr to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Expr
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-1"><a class="header" href="#constructor-1">Constructor</a></h2>
<pre><code class="language-python">Expr()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self) -&gt; None:
        self._pyexpr: PyExpr
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-1"><a class="header" href="#methods-1">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpreq"><a class="header" href="#polarsinternalsexprexpreq"><code>polars.internals.expr.Expr.eq</code></a></h3>
<pre><code class="language-python">eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprneq"><a class="header" href="#polarsinternalsexprexprneq"><code>polars.internals.expr.Expr.neq</code></a></h3>
<pre><code class="language-python">neq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def neq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.neq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprgt"><a class="header" href="#polarsinternalsexprexprgt"><code>polars.internals.expr.Expr.gt</code></a></h3>
<pre><code class="language-python">gt(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def gt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprgt_eq"><a class="header" href="#polarsinternalsexprexprgt_eq"><code>polars.internals.expr.Expr.gt_eq</code></a></h3>
<pre><code class="language-python">gt_eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def gt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt_eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlt_eq"><a class="header" href="#polarsinternalsexprexprlt_eq"><code>polars.internals.expr.Expr.lt_eq</code></a></h3>
<pre><code class="language-python">lt_eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt_eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlt"><a class="header" href="#polarsinternalsexprexprlt"><code>polars.internals.expr.Expr.lt</code></a></h3>
<pre><code class="language-python">lt(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpr__array_ufunc__function"><a class="header" href="#polarsinternalsexprexpr__array_ufunc__function"><code>polars.internals.expr.Expr.__array_ufunc__.function</code></a></h3>
<pre><code class="language-python">function(s: pli.Series) -&gt; pli.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def function(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return ufunc(s, *args, **kwargs)  # pragma: no cover
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsqrt"><a class="header" href="#polarsinternalsexprexprsqrt"><code>polars.internals.expr.Expr.sqrt</code></a></h3>
<pre><code class="language-python">sqrt() -&gt; Expr:
</code></pre>
<p>Compute the square root of the elements</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sqrt(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements
        &quot;&quot;&quot;
        return self ** 0.5
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpralias"><a class="header" href="#polarsinternalsexprexpralias"><code>polars.internals.expr.Expr.alias</code></a></h3>
<pre><code class="language-python">alias(name: str) -&gt; Expr:
</code></pre>
<p>Rename the output of an expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
})
df
shape: (3, 2)
╭─────┬──────╮
│ a   ┆ b    │
│ --- ┆ ---  │
│ i64 ┆ str  │
╞═════╪══════╡
│ 1   ┆ &quot;a&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null │
╰─────┴──────╯
df.select([
col(&quot;a&quot;).alias(&quot;bar&quot;),
col(&quot;b&quot;).alias(&quot;foo&quot;)
])
shape: (3, 2)
╭─────┬──────╮
│ bar ┆ foo  │
│ --- ┆ ---  │
│ i64 ┆ str  │
╞═════╪══════╡
│ 1   ┆ &quot;a&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null │
╰─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def alias(self, name: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Rename the output of an expression.

        Parameters
        ----------
        name
            New name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (3, 2)
        ╭─────┬──────╮
        │ a   ┆ b    │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     col(&quot;a&quot;).alias(&quot;bar&quot;),
        &gt;&gt;&gt;     col(&quot;b&quot;).alias(&quot;foo&quot;)
        &gt;&gt;&gt; ])
        shape: (3, 2)
        ╭─────┬──────╮
        │ bar ┆ foo  │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.alias(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprexclude"><a class="header" href="#polarsinternalsexprexprexclude"><code>polars.internals.expr.Expr.exclude</code></a></h3>
<pre><code class="language-python">exclude(columns: Union[str, tp.List[str]]) -&gt; Expr:
</code></pre>
<p>Exclude certain columns from a wildcard/regex selection.</p>
<p>You may also use regexes int he exclude list. They must start with <code>^</code> and end with <code>$</code>.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li>[<code> columns</code>]: Column(s) to exclude from selection</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
&quot;c&quot;: [None, 2, 1]
})
df
shape: (3, 3)
╭─────┬──────┬──────╮
│ a   ┆ b    ┆ c    │
│ --- ┆ ---  ┆ ---  │
│ i64 ┆ str  ┆ i64  │
╞═════╪══════╪══════╡
│ 1   ┆ &quot;a&quot;  ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  ┆ 2    │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null ┆ 1    │
╰─────┴──────┴──────╯
df.select(col(&quot;*&quot;).exclude(&quot;b&quot;))
shape: (3, 2)
╭─────┬──────╮
│ a   ┆ c    │
│ --- ┆ ---  │
│ i64 ┆ i64  │
╞═════╪══════╡
│ 1   ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ 2    │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ 1    │
╰─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def exclude(self, columns: Union[str, tp.List[str]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
         Exclude certain columns from a wildcard/regex selection.

         You may also use regexes int he exclude list. They must start with `^` and end with `$`.

         Parameters
         ----------
         columns
             Column(s) to exclude from selection

         Examples
         --------

         &gt;&gt;&gt; df = pl.DataFrame({
         &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
         &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
         &gt;&gt;&gt;     &quot;c&quot;: [None, 2, 1]
         &gt;&gt;&gt; })
         &gt;&gt;&gt; df
         shape: (3, 3)
         ╭─────┬──────┬──────╮
         │ a   ┆ b    ┆ c    │
         │ --- ┆ ---  ┆ ---  │
         │ i64 ┆ str  ┆ i64  │
         ╞═════╪══════╪══════╡
         │ 1   ┆ &quot;a&quot;  ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ &quot;b&quot;  ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ null ┆ 1    │
         ╰─────┴──────┴──────╯
         &gt;&gt;&gt; df.select(col(&quot;*&quot;).exclude(&quot;b&quot;))
        shape: (3, 2)
         ╭─────┬──────╮
         │ a   ┆ c    │
         │ --- ┆ ---  │
         │ i64 ┆ i64  │
         ╞═════╪══════╡
         │ 1   ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ 1    │
         ╰─────┴──────╯
        &quot;&quot;&quot;
        if isinstance(columns, str):
            columns = [columns]
        return wrap_expr(self._pyexpr.exclude(columns))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprkeep_name"><a class="header" href="#polarsinternalsexprexprkeep_name"><code>polars.internals.expr.Expr.keep_name</code></a></h3>
<pre><code class="language-python">keep_name() -&gt; Expr:
</code></pre>
<p>Keep the original root name of the expression.</p>
<p><strong>Examples:</strong></p>
<p>A groupby aggregation often changes the name of a column.
With <code>keep_name</code> we can keep the original name of the column</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
})
(df.groupby(&quot;a&quot;)
.agg(col(&quot;b&quot;).list())
.sort(by=&quot;a&quot;)
)
shape: (3, 2)
╭─────┬────────────╮
│ a   ┆ b_agg_list │
│ --- ┆ ---        │
│ i64 ┆ list [str] │
╞═════╪════════════╡
│ 1   ┆ [a]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ [b]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ [null]     │
╰─────┴────────────╯</p>
<h1 id="keep-the-original-column-name"><a class="header" href="#keep-the-original-column-name">keep the original column name</a></h1>
<p>(df.groupby(&quot;a&quot;)
.agg(col(&quot;b&quot;).list().keep_name())
.sort(by=&quot;a&quot;)
)
shape: (3, 2)
╭─────┬────────────╮
│ a   ┆ b          │
│ --- ┆ ---        │
│ i64 ┆ list [str] │
╞═════╪════════════╡
│ 1   ┆ [a]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ [b]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ [null]     │
╰─────┴────────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def keep_name(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Keep the original root name of the expression.

        Examples
        --------

        A groupby aggregation often changes the name of a column.
        With `keep_name` we can keep the original name of the column

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt; &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt; &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b_agg_list │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯
        &gt;&gt;&gt; # keep the original column name
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list().keep_name())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b          │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯

        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.keep_name())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprprefix"><a class="header" href="#polarsinternalsexprexprprefix"><code>polars.internals.expr.Expr.prefix</code></a></h3>
<pre><code class="language-python">prefix(prefix: str) -&gt; Expr:
</code></pre>
<p>Add a prefix the to root column name of the expression.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1, 2, 3, 4, 5],
&quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
&quot;B&quot;: [5, 4, 3, 2, 1],
&quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
})
shape: (5, 4)
╭─────┬──────────┬─────┬──────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     │
│ --- ┆ ---      ┆ --- ┆ ---      │
│ i64 ┆ str      ┆ i64 ┆ str      │
╞═════╪══════════╪═════╪══════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
╰─────┴──────────┴─────┴──────────╯
(df.select([
pl.all(),
pl.all().reverse().suffix(&quot;_reverse&quot;)
]))
shape: (5, 8)
╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     ┆ A_reverse ┆ fruits_reverse ┆ B_reverse ┆ cars_reverse │
│ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
│ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def prefix(self, prefix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a prefix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().suffix(&quot;_reverse&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ A_reverse ┆ fruits_reverse ┆ B_reverse ┆ cars_reverse │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.prefix(prefix))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsuffix"><a class="header" href="#polarsinternalsexprexprsuffix"><code>polars.internals.expr.Expr.suffix</code></a></h3>
<pre><code class="language-python">suffix(suffix: str) -&gt; Expr:
</code></pre>
<p>Add a suffix the to root column name of the expression.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1, 2, 3, 4, 5],
&quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
&quot;B&quot;: [5, 4, 3, 2, 1],
&quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
})
shape: (5, 4)
╭─────┬──────────┬─────┬──────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     │
│ --- ┆ ---      ┆ --- ┆ ---      │
│ i64 ┆ str      ┆ i64 ┆ str      │
╞═════╪══════════╪═════╪══════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
╰─────┴──────────┴─────┴──────────╯
(df.select([
pl.all(),
pl.all().reverse().prefix(&quot;reverse_&quot;)
]))
shape: (5, 8)
╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     ┆ reverse_A ┆ reverse_fruits ┆ reverse_B ┆ reverse_cars │
│ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
│ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def suffix(self, suffix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a suffix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().prefix(&quot;reverse_&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ reverse_A ┆ reverse_fruits ┆ reverse_B ┆ reverse_cars │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.suffix(suffix))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_not"><a class="header" href="#polarsinternalsexprexpris_not"><code>polars.internals.expr.Expr.is_not</code></a></h3>
<pre><code class="language-python">is_not() -&gt; Expr:
</code></pre>
<p>Negate a boolean expression.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [True, False, False],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
})
shape: (3, 2)
╭───────┬──────╮
│ a     ┆ b    │
│ ---   ┆ ---  │
│ bool  ┆ str  │
╞═══════╪══════╡
│ true  ┆ &quot;a&quot;  │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ false ┆ &quot;b&quot;  │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ false ┆ null │
╰───────┴──────╯
df.select(pl.col(&quot;a&quot;).is_not())
shape: (3, 1)
╭───────╮
│ a     │
│ ---   │
│ bool  │
╞═══════╡
│ false │
├╌╌╌╌╌╌╌┤
│ true  │
├╌╌╌╌╌╌╌┤
│ true  │
╰───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Negate a boolean expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [True, False, False],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
        &gt;&gt;&gt; })
        shape: (3, 2)
        ╭───────┬──────╮
        │ a     ┆ b    │
        │ ---   ┆ ---  │
        │ bool  ┆ str  │
        ╞═══════╪══════╡
        │ true  ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ null │
        ╰───────┴──────╯
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).is_not())
        shape: (3, 1)
        ╭───────╮
        │ a     │
        │ ---   │
        │ bool  │
        ╞═══════╡
        │ false │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ╰───────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_null"><a class="header" href="#polarsinternalsexprexpris_null"><code>polars.internals.expr.Expr.is_null</code></a></h3>
<pre><code class="language-python">is_null() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression contains null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression contains null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_not_null"><a class="header" href="#polarsinternalsexprexpris_not_null"><code>polars.internals.expr.Expr.is_not_null</code></a></h3>
<pre><code class="language-python">is_not_null() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression does not contain null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression does not contain null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_finite"><a class="header" href="#polarsinternalsexprexpris_finite"><code>polars.internals.expr.Expr.is_finite</code></a></h3>
<pre><code class="language-python">is_finite() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are finite.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_finite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are finite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_finite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_infinite"><a class="header" href="#polarsinternalsexprexpris_infinite"><code>polars.internals.expr.Expr.is_infinite</code></a></h3>
<pre><code class="language-python">is_infinite() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are infinite.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_infinite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are infinite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_infinite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_nan"><a class="header" href="#polarsinternalsexprexpris_nan"><code>polars.internals.expr.Expr.is_nan</code></a></h3>
<pre><code class="language-python">is_nan() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are NaN (Not A Number).</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_not_nan"><a class="header" href="#polarsinternalsexprexpris_not_nan"><code>polars.internals.expr.Expr.is_not_nan</code></a></h3>
<pre><code class="language-python">is_not_nan() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are not NaN (Not A Number).</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are not NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpragg_groups"><a class="header" href="#polarsinternalsexprexpragg_groups"><code>polars.internals.expr.Expr.agg_groups</code></a></h3>
<pre><code class="language-python">agg_groups() -&gt; Expr:
</code></pre>
<p>Get the group indexes of the group by operation.
Should be used in aggregation context only.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg_groups(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the group indexes of the group by operation.
        Should be used in aggregation context only.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.agg_groups())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcount"><a class="header" href="#polarsinternalsexprexprcount"><code>polars.internals.expr.Expr.count</code></a></h3>
<pre><code class="language-python">count() -&gt; Expr:
</code></pre>
<p>Count the number of values in this expression</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def count(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count the number of values in this expression&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.count())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlen"><a class="header" href="#polarsinternalsexprexprlen"><code>polars.internals.expr.Expr.len</code></a></h3>
<pre><code class="language-python">len() -&gt; Expr:
</code></pre>
<p>Alias for count
Count the number of values in this expression</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def len(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for count
        Count the number of values in this expression
        &quot;&quot;&quot;
        return self.count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprslice"><a class="header" href="#polarsinternalsexprexprslice"><code>polars.internals.expr.Expr.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; Expr:
</code></pre>
<p>Slice the Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Start index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Slice the Series.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdrop_nulls"><a class="header" href="#polarsinternalsexprexprdrop_nulls"><code>polars.internals.expr.Expr.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls() -&gt; Expr:
</code></pre>
<p>Syntactic sugar for:</p>
<blockquote>
<blockquote>
<blockquote>
<p>pl.col(&quot;foo&quot;).filter(pl.col(&quot;foo&quot;).is_not_null())</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Syntactic sugar for:

        &gt;&gt;&gt; pl.col(&quot;foo&quot;).filter(pl.col(&quot;foo&quot;).is_not_null())
        &quot;&quot;&quot;
        return self.filter(self.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcumsum"><a class="header" href="#polarsinternalsexprexprcumsum"><code>polars.internals.expr.Expr.cumsum</code></a></h3>
<pre><code class="language-python">cumsum(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative sum computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumsum(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumsum(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcumprod"><a class="header" href="#polarsinternalsexprexprcumprod"><code>polars.internals.expr.Expr.cumprod</code></a></h3>
<pre><code class="language-python">cumprod(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative product computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumprod(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumprod(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcummin"><a class="header" href="#polarsinternalsexprexprcummin"><code>polars.internals.expr.Expr.cummin</code></a></h3>
<pre><code class="language-python">cummin(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative min computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummin(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummin(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcummax"><a class="header" href="#polarsinternalsexprexprcummax"><code>polars.internals.expr.Expr.cummax</code></a></h3>
<pre><code class="language-python">cummax(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative max computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummax(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummax(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfloor"><a class="header" href="#polarsinternalsexprexprfloor"><code>polars.internals.expr.Expr.floor</code></a></h3>
<pre><code class="language-python">floor() -&gt; Expr:
</code></pre>
<p>Floor underlying floating point array to the lowest integers smaller or equal to the float value.</p>
<p>Only works on floating point Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def floor(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.floor())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprround"><a class="header" href="#polarsinternalsexprexprround"><code>polars.internals.expr.Expr.round</code></a></h3>
<pre><code class="language-python">round(decimals: int) -&gt; Expr:
</code></pre>
<p>Round underlying floating point data by <code>decimals</code> digits.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>decimals</code>]: Number of decimals to round by.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, decimals: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            Number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.round(decimals))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdot"><a class="header" href="#polarsinternalsexprexprdot"><code>polars.internals.expr.Expr.dot</code></a></h3>
<pre><code class="language-python">dot(other: Union[Expr, str]) -&gt; Expr:
</code></pre>
<p>Compute the dot/inner product between two Expressions</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Expression to compute dot product with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dot(self, other: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Expressions

        Parameters
        ----------
        other
            Expression to compute dot product with
        &quot;&quot;&quot;
        other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.dot(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmode"><a class="header" href="#polarsinternalsexprexprmode"><code>polars.internals.expr.Expr.mode</code></a></h3>
<pre><code class="language-python">mode() -&gt; Expr:
</code></pre>
<p>Compute the most occurring value(s). Can return multiple Values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcast"><a class="header" href="#polarsinternalsexprexprcast"><code>polars.internals.expr.Expr.cast</code></a></h3>
<pre><code class="language-python">cast(dtype: TypeAny, strict: bool) -&gt; Expr:
</code></pre>
<p>Cast between data types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dtype</code>]: DataType to cast to</li>
<li>[<code>strict</code>]: Throw an error if a cast could not be done for instance due to an overflow</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cast(self, dtype: Type[Any], strict: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow
        &quot;&quot;&quot;
        dtype = py_type_to_dtype(dtype)
        return wrap_expr(self._pyexpr.cast(dtype, strict))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsort"><a class="header" href="#polarsinternalsexprexprsort"><code>polars.internals.expr.Expr.sort</code></a></h3>
<pre><code class="language-python">sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Sort this column. In projection/ selection context the whole column is sorted.
If used in a groupby context, the groups are sorted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column. In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_sort"><a class="header" href="#polarsinternalsexprexprarg_sort"><code>polars.internals.expr.Expr.arg_sort</code></a></h3>
<pre><code class="language-python">arg_sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get the index values that would sort this column.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>out</code>]: Series of type UInt32</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index values that would sort this column.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.

        Returns
        -------
        out
            Series of type UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_max"><a class="header" href="#polarsinternalsexprexprarg_max"><code>polars.internals.expr.Expr.arg_max</code></a></h3>
<pre><code class="language-python">arg_max() -&gt; Expr:
</code></pre>
<p>Get the index of the maximal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_min"><a class="header" href="#polarsinternalsexprexprarg_min"><code>polars.internals.expr.Expr.arg_min</code></a></h3>
<pre><code class="language-python">arg_min() -&gt; Expr:
</code></pre>
<p>Get the index of the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsort_by"><a class="header" href="#polarsinternalsexprexprsort_by"><code>polars.internals.expr.Expr.sort_by</code></a></h3>
<pre><code class="language-python">sort_by(by: Union[Expr, str, tp.List[Union[Expr, str]]], 
    reverse: Union[bool, tp.List[bool]],) -&gt; Expr:
</code></pre>
<p>Sort this column by the ordering of another column, or multiple other columns.
In projection/ selection context the whole column is sorted.
If used in a groupby context, the groups are sorted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: The column(s) used for sorting.</li>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort_by(
        self,
        by: Union[&quot;Expr&quot;, str, tp.List[Union[&quot;Expr&quot;, str]]],
        reverse: Union[bool, tp.List[bool]] = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column by the ordering of another column, or multiple other columns.
        In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        by
            The column(s) used for sorting.
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        if not isinstance(by, list):
            by = [by]
        if not isinstance(reverse, list):
            reverse = [reverse]
        by = _selection_to_pyexpr_list(by)

        return wrap_expr(self._pyexpr.sort_by(by, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtake"><a class="header" href="#polarsinternalsexprexprtake"><code>polars.internals.expr.Expr.take</code></a></h3>
<pre><code class="language-python">take(index: Union[tp.List[int], Expr, pli.Series, np.ndarray],) -&gt; Expr:
</code></pre>
<p>Take values by index.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: An expression that leads to a UInt32 dtyped Series.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Values taken by index</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take(
        self, index: Union[tp.List[int], &quot;Expr&quot;, &quot;pli.Series&quot;, np.ndarray]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        index
            An expression that leads to a UInt32 dtyped Series.

        Returns
        -------
        Values taken by index
        &quot;&quot;&quot;
        if isinstance(index, (list, np.ndarray)):
            index = pli.lit(pli.Series(&quot;&quot;, index, dtype=UInt32))  # type: ignore
        elif isinstance(index, pli.Series):
            index = pli.lit(index)  # type: ignore
        else:
            index = pli.expr_to_lit_or_expr(index, str_to_lit=False)  # type: ignore
        return pli.wrap_expr(self._pyexpr.take(index._pyexpr))  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprshift"><a class="header" href="#polarsinternalsexprexprshift"><code>polars.internals.expr.Expr.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; Expr:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int = 1) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprshift_and_fill"><a class="header" href="#polarsinternalsexprexprshift_and_fill"><code>polars.internals.expr.Expr.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, fill_value: Expr) -&gt; Expr:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: Fill None values with the result of this expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(self, periods: int, fill_value: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.shift_and_fill(periods, fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfill_null"><a class="header" href="#polarsinternalsexprexprfill_null"><code>polars.internals.expr.Expr.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(fill_value: Union[str, int, float, Expr],) -&gt; Expr:
</code></pre>
<p>Fill none value with a fill value or strategy</p>
<ul>
<li>[<code>fill_value</code>]: Fill null strategy or a value
* &quot;backward&quot;
* &quot;forward&quot;
* &quot;min&quot;
* &quot;max&quot;
* &quot;mean&quot;
* &quot;one&quot;
* &quot;zero&quot;</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value or strategy

        fill_value
            Fill null strategy or a value
                   * &quot;backward&quot;
                   * &quot;forward&quot;
                   * &quot;min&quot;
                   * &quot;max&quot;
                   * &quot;mean&quot;
                   * &quot;one&quot;
                   * &quot;zero&quot;
        &quot;&quot;&quot;
        # we first must check if it is not an expr, as expr does not implement __bool__
        # and thus leads to a value error in the second comparisson.
        if not isinstance(fill_value, Expr) and fill_value in [
            &quot;backward&quot;,
            &quot;forward&quot;,
            &quot;min&quot;,
            &quot;max&quot;,
            &quot;mean&quot;,
            &quot;zero&quot;,
            &quot;one&quot;,
        ]:
            return wrap_expr(self._pyexpr.fill_null_with_strategy(fill_value))

        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_null(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfill_nan"><a class="header" href="#polarsinternalsexprexprfill_nan"><code>polars.internals.expr.Expr.fill_nan</code></a></h3>
<pre><code class="language-python">fill_nan(fill_value: Union[str, int, float, Expr],) -&gt; Expr:
</code></pre>
<p>Fill none value with a fill value</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_nan(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_nan(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprforward_fill"><a class="header" href="#polarsinternalsexprexprforward_fill"><code>polars.internals.expr.Expr.forward_fill</code></a></h3>
<pre><code class="language-python">forward_fill() -&gt; Expr:
</code></pre>
<p>Fill missing values with the latest seen values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def forward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the latest seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.forward_fill())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprbackward_fill"><a class="header" href="#polarsinternalsexprexprbackward_fill"><code>polars.internals.expr.Expr.backward_fill</code></a></h3>
<pre><code class="language-python">backward_fill() -&gt; Expr:
</code></pre>
<p>Fill missing values with the next to be seen values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def backward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the next to be seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.backward_fill())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprreverse"><a class="header" href="#polarsinternalsexprexprreverse"><code>polars.internals.expr.Expr.reverse</code></a></h3>
<pre><code class="language-python">reverse() -&gt; Expr:
</code></pre>
<p>Reverse the selection.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the selection.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reverse())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstd"><a class="header" href="#polarsinternalsexprexprstd"><code>polars.internals.expr.Expr.std</code></a></h3>
<pre><code class="language-python">std() -&gt; Expr:
</code></pre>
<p>Get standard deviation.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get standard deviation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.std())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprvar"><a class="header" href="#polarsinternalsexprexprvar"><code>polars.internals.expr.Expr.var</code></a></h3>
<pre><code class="language-python">var() -&gt; Expr:
</code></pre>
<p>Get variance.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get variance.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.var())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmax"><a class="header" href="#polarsinternalsexprexprmax"><code>polars.internals.expr.Expr.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Expr:
</code></pre>
<p>Get maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get maximum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmin"><a class="header" href="#polarsinternalsexprexprmin"><code>polars.internals.expr.Expr.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Expr:
</code></pre>
<p>Get minimum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get minimum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsum"><a class="header" href="#polarsinternalsexprexprsum"><code>polars.internals.expr.Expr.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Expr:
</code></pre>
<p>Get sum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get sum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sum())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmean"><a class="header" href="#polarsinternalsexprexprmean"><code>polars.internals.expr.Expr.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Expr:
</code></pre>
<p>Get mean value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mean value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mean())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmedian"><a class="header" href="#polarsinternalsexprexprmedian"><code>polars.internals.expr.Expr.median</code></a></h3>
<pre><code class="language-python">median() -&gt; Expr:
</code></pre>
<p>Get median value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get median value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.median())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprn_unique"><a class="header" href="#polarsinternalsexprexprn_unique"><code>polars.internals.expr.Expr.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; Expr:
</code></pre>
<p>Count unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.n_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_unique"><a class="header" href="#polarsinternalsexprexprarg_unique"><code>polars.internals.expr.Expr.arg_unique</code></a></h3>
<pre><code class="language-python">arg_unique() -&gt; Expr:
</code></pre>
<p>Get index of first unique value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get index of first unique value.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprunique"><a class="header" href="#polarsinternalsexprexprunique"><code>polars.internals.expr.Expr.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Expr:
</code></pre>
<p>Get unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfirst"><a class="header" href="#polarsinternalsexprexprfirst"><code>polars.internals.expr.Expr.first</code></a></h3>
<pre><code class="language-python">first() -&gt; Expr:
</code></pre>
<p>Get the first value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the first value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlast"><a class="header" href="#polarsinternalsexprexprlast"><code>polars.internals.expr.Expr.last</code></a></h3>
<pre><code class="language-python">last() -&gt; Expr:
</code></pre>
<p>Get the last value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def last(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the last value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.last())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlist"><a class="header" href="#polarsinternalsexprexprlist"><code>polars.internals.expr.Expr.list</code></a></h3>
<pre><code class="language-python">list() -&gt; Expr:
</code></pre>
<p>Aggregate to list.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def list(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Aggregate to list.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.list())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprover"><a class="header" href="#polarsinternalsexprexprover"><code>polars.internals.expr.Expr.over</code></a></h3>
<pre><code class="language-python">over(expr: Union[str, Expr, tp.List[Union[Expr, str]]],) -&gt; Expr:
</code></pre>
<p>Apply window function over a subgroup.
This is similar to a groupby + aggregation + self join.
Or similar to <a href="https:/www.postgresql.org/docs/9.1/tutorial-window.html">window functions in Postgres</a></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>expr</code>]: Column(s) to group by.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = DataFrame({
&quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
&quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
})
(df.lazy()
.select([
pl.col(&quot;groups&quot;)
sum(&quot;values&quot;).over(&quot;groups&quot;)
]).collect())
╭────────┬────────╮
│ groups ┆ values │
│ ---    ┆ ---    │
│ i32    ┆ i32    │
╞════════╪════════╡
│ 1      ┆ 16     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1      ┆ 16     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2      ┆ 13     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2      ┆ 13     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ ...    ┆ ...    │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1      ┆ 16     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2      ┆ 13     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3      ┆ 15     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3      ┆ 15     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1      ┆ 16     │
╰────────┴────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def over(self, expr: Union[str, &quot;Expr&quot;, tp.List[Union[&quot;Expr&quot;, str]]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply window function over a subgroup.
        This is similar to a groupby + aggregation + self join.
        Or similar to [window functions in Postgres](https://www.postgresql.org/docs/9.1/tutorial-window.html)

        Parameters
        ----------
        expr
            Column(s) to group by.

        Examples
        --------

        &gt;&gt;&gt; df = DataFrame({
        &gt;&gt;&gt;    &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
        &gt;&gt;&gt;    &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
        &gt;&gt;&gt;})
        &gt;&gt;&gt; (df.lazy()
        &gt;&gt;&gt;    .select([
        &gt;&gt;&gt;       pl.col(&quot;groups&quot;)
        &gt;&gt;&gt;       sum(&quot;values&quot;).over(&quot;groups&quot;)
        &gt;&gt;&gt;   ]).collect())
            ╭────────┬────────╮
            │ groups ┆ values │
            │ ---    ┆ ---    │
            │ i32    ┆ i32    │
            ╞════════╪════════╡
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ ...    ┆ ...    │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ╰────────┴────────╯

        &quot;&quot;&quot;

        pyexprs = _selection_to_pyexpr_list(expr)

        return wrap_expr(self._pyexpr.over(pyexprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_unique"><a class="header" href="#polarsinternalsexprexpris_unique"><code>polars.internals.expr.Expr.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; Expr:
</code></pre>
<p>Get mask of unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of unique values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_first"><a class="header" href="#polarsinternalsexprexpris_first"><code>polars.internals.expr.Expr.is_first</code></a></h3>
<pre><code class="language-python">is_first() -&gt; Expr:
</code></pre>
<p>Get a mask of the first unique value.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_duplicated"><a class="header" href="#polarsinternalsexprexpris_duplicated"><code>polars.internals.expr.Expr.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; Expr:
</code></pre>
<p>Get mask of duplicated values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of duplicated values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprquantile"><a class="header" href="#polarsinternalsexprexprquantile"><code>polars.internals.expr.Expr.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; Expr:
</code></pre>
<p>Get quantile value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get quantile value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.quantile(quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfilter"><a class="header" href="#polarsinternalsexprexprfilter"><code>polars.internals.expr.Expr.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Expr) -&gt; Expr:
</code></pre>
<p>Filter a single column.
Mostly useful in in aggregation context. If you want to filter on a DataFrame level, use <code>LazyFrame.filter</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Filter a single column.
        Mostly useful in in aggregation context. If you want to filter on a DataFrame level, use `LazyFrame.filter`.

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.filter(predicate._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprwhere"><a class="header" href="#polarsinternalsexprexprwhere"><code>polars.internals.expr.Expr.where</code></a></h3>
<pre><code class="language-python">where(predicate: Expr) -&gt; Expr:
</code></pre>
<p>Alias for filter</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def where(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for filter

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return self.filter(predicate)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmap"><a class="header" href="#polarsinternalsexprexprmap"><code>polars.internals.expr.Expr.map</code></a></h3>
<pre><code class="language-python">map(f: Callable[[pli.Series], pli.Series], 
    return_dtype: OptionalTypeDataType, 
    agg_list: bool,) -&gt; Expr:
</code></pre>
<p>Apply a custom python function. This function must produce a <code>Series</code>. Any other value will be stored as
null/missing. If you want to apply a function over single values, consider using <code>apply</code>.</p>
<p><a href="https:/pola-rs.github.io/polars-book/user-guide/howcani/apply/udfs.html">read more in the book</a></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>return_dtype</code>]: Dtype of the output Series.
agg_list</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def map(
        self,
        f: Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;],
        return_dtype: Optional[Type[DataType]] = None,
        agg_list: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom python function. This function must produce a `Series`. Any other value will be stored as
        null/missing. If you want to apply a function over single values, consider using `apply`.

        [read more in the book](https://pola-rs.github.io/polars-book/user-guide/howcani/apply/udfs.html)

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.
        agg_list

        &quot;&quot;&quot;
        if return_dtype is not None:
            return_dtype = py_type_to_dtype(return_dtype)
        return wrap_expr(self._pyexpr.map(f, return_dtype, agg_list))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprapply"><a class="header" href="#polarsinternalsexprexprapply"><code>polars.internals.expr.Expr.apply</code></a></h3>
<pre><code class="language-python">apply(f: Union[Callable[[pli.Series], pli.Series], Callable[[Any], Any]], 
    return_dtype: OptionalTypeDataType,) -&gt; Expr:
</code></pre>
<p>Apply a custom function in a GroupBy or Projection context.</p>
<p>Depending on the context it has the following behavior:</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<ul>
<li>Select/Project
expected type <code>f</code>: Callable[[Any], Any]
Applies a python function over each individual value in the column.</li>
<li>GroupBy
expected type <code>f</code>: Callable[[Series], Series]
Applies a python function over each group.</li>
</ul>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>return_dtype</code>]: Dtype of the output Series.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})
df
.lazy()
.groupby(&quot;b&quot;)
.agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
.collect()
)
shape: (3, 2)
╭─────┬─────╮
│ b   ┆ a   │
│ --- ┆ --- │
│ str ┆ i64 │
╞═════╪═════╡
│ a   ┆ 1   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ b   ┆ 2   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ c   ┆ 2   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        f: Union[Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;], Callable[[Any], Any]],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom function in a GroupBy or Projection context.

        Depending on the context it has the following behavior:

        ## Context

        * Select/Project
            expected type `f`: Callable[[Any], Any]
            Applies a python function over each individual value in the column.
        * GroupBy
            expected type `f`: Callable[[Series], Series]
            Applies a python function over each group.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
                   &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})
        &gt;&gt;&gt; df
         .lazy()
         .groupby(&quot;b&quot;)
         .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
         .collect()
        )
        shape: (3, 2)
        ╭─────┬─────╮
        │ b   ┆ a   │
        │ --- ┆ --- │
        │ str ┆ i64 │
        ╞═════╪═════╡
        │ a   ┆ 1   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 2   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ c   ┆ 2   │
        ╰─────┴─────╯

        &quot;&quot;&quot;

        # input x: Series of type list containing the group values
        def wrap_f(x: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)

        return self.map(wrap_f, agg_list=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprapplywrap_f"><a class="header" href="#polarsinternalsexprexprapplywrap_f"><code>polars.internals.expr.Expr.apply.wrap_f</code></a></h3>
<pre><code class="language-python">wrap_f(x: pli.Series) -&gt; pli.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def wrap_f(x: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprflatten"><a class="header" href="#polarsinternalsexprexprflatten"><code>polars.internals.expr.Expr.flatten</code></a></h3>
<pre><code class="language-python">flatten() -&gt; Expr:
</code></pre>
<p>Alias for explode.</p>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def flatten(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for explode.

        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprexplode"><a class="header" href="#polarsinternalsexprexprexplode"><code>polars.internals.expr.Expr.explode</code></a></h3>
<pre><code class="language-python">explode() -&gt; Expr:
</code></pre>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtake_every"><a class="header" href="#polarsinternalsexprexprtake_every"><code>polars.internals.expr.Expr.take_every</code></a></h3>
<pre><code class="language-python">take_every(n: int) -&gt; Expr:
</code></pre>
<p>Take every nth value in the Series and return as a new Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take_every(self, n: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as a new Series.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take_every(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprhead"><a class="header" href="#polarsinternalsexprexprhead"><code>polars.internals.expr.Expr.head</code></a></h3>
<pre><code class="language-python">head(n: Optionalint) -&gt; Expr:
</code></pre>
<p>Take the first n values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the first n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.head(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtail"><a class="header" href="#polarsinternalsexprexprtail"><code>polars.internals.expr.Expr.tail</code></a></h3>
<pre><code class="language-python">tail(n: Optionalint) -&gt; Expr:
</code></pre>
<p>Take the last n values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the last n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.tail(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprpow"><a class="header" href="#polarsinternalsexprexprpow"><code>polars.internals.expr.Expr.pow</code></a></h3>
<pre><code class="language-python">pow(exponent: float) -&gt; Expr:
</code></pre>
<p>Raise expression to the power of exponent.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pow(self, exponent: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Raise expression to the power of exponent.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.pow(exponent))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_in"><a class="header" href="#polarsinternalsexprexpris_in"><code>polars.internals.expr.Expr.is_in</code></a></h3>
<pre><code class="language-python">is_in(other: Union[Expr, tp.List[Any]]) -&gt; Expr:
</code></pre>
<p>Check if elements of this Series are in the right Series, or List values of the right Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series of primitive type or List type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr that evaluates to a Boolean Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_in(self, other: Union[&quot;Expr&quot;, tp.List[Any]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Parameters
        ----------
        other
            Series of primitive type or List type.

        Returns
        -------
        Expr that evaluates to a Boolean Series.
        &quot;&quot;&quot;
        if isinstance(other, list):
            other = pli.lit(pli.Series(other))
        else:
            other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.is_in(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrepeat_by"><a class="header" href="#polarsinternalsexprexprrepeat_by"><code>polars.internals.expr.Expr.repeat_by</code></a></h3>
<pre><code class="language-python">repeat_by(by: Union[Expr, str]) -&gt; Expr:
</code></pre>
<p>Repeat the elements in this Series <code>n</code> times by dictated by the number given by <code>by</code>.
The elements are expanded into a <code>List</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Numeric column that determines how often the values will be repeated.
The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series of type List</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def repeat_by(self, by: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Repeat the elements in this Series `n` times by dictated by the number given by `by`.
        The elements are expanded into a `List`

        Parameters
        ----------
        by
            Numeric column that determines how often the values will be repeated.
            The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.

        Returns
        -------
        Series of type List
        &quot;&quot;&quot;
        by = expr_to_lit_or_expr(by, False)
        return wrap_expr(self._pyexpr.repeat_by(by._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_between"><a class="header" href="#polarsinternalsexprexpris_between"><code>polars.internals.expr.Expr.is_between</code></a></h3>
<pre><code class="language-python">is_between(start: Union[Expr, datetime], 
    end: Union[Expr, datetime],) -&gt; Expr:
</code></pre>
<p>Check if this expression is between start and end.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_between(
        self, start: Union[&quot;Expr&quot;, datetime], end: Union[&quot;Expr&quot;, datetime]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if this expression is between start and end.
        &quot;&quot;&quot;
        cast_to_datetime = False
        if isinstance(start, datetime):
            start = pli.lit(start)
            cast_to_datetime = True
        if isinstance(end, datetime):
            end = pli.lit(end)
            cast_to_datetime = True
        if cast_to_datetime:
            expr = self.cast(Datetime)
        else:
            expr = self
        return ((expr &gt; start) &amp; (expr &lt; end)).alias(&quot;is_between&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdt"><a class="header" href="#polarsinternalsexprexprdt"><code>polars.internals.expr.Expr.dt</code></a></h3>
<pre><code class="language-python">dt() -&gt; ExprDateTimeNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dt(self) -&gt; &quot;ExprDateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprDateTimeNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstr"><a class="header" href="#polarsinternalsexprexprstr"><code>polars.internals.expr.Expr.str</code></a></h3>
<pre><code class="language-python">str() -&gt; ExprStringNameSpace:
</code></pre>
<p>Create an object namespace of all string related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str(self) -&gt; &quot;ExprStringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return ExprStringNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarr"><a class="header" href="#polarsinternalsexprexprarr"><code>polars.internals.expr.Expr.arr</code></a></h3>
<pre><code class="language-python">arr() -&gt; ExprListNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arr(self) -&gt; &quot;ExprListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprListNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprhash"><a class="header" href="#polarsinternalsexprexprhash"><code>polars.internals.expr.Expr.hash</code></a></h3>
<pre><code class="language-python">hash(k0: int, k1: int, k2: int, k3: int) -&gt; Expr:
</code></pre>
<p>Hash the Series.</p>
<p>The hash value is of type <code>Datetime</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `Datetime`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hash(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprreinterpret"><a class="header" href="#polarsinternalsexprexprreinterpret"><code>polars.internals.expr.Expr.reinterpret</code></a></h3>
<pre><code class="language-python">reinterpret(signed: bool) -&gt; Expr:
</code></pre>
<p>Reinterpret the underlying bits as a signed/unsigned integer.
This operation is only allowed for 64bit integers. For lower bits integers,
you can safely use that cast operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>signed</code>]: True -&gt; pl.Int64
False -&gt; pl.UInt64</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reinterpret(self, signed: bool) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprinspect"><a class="header" href="#polarsinternalsexprexprinspect"><code>polars.internals.expr.Expr.inspect</code></a></h3>
<pre><code class="language-python">inspect(fmt: str) -&gt; Expr:
</code></pre>
<p>Prints the value that this expression evaluates to and passes on the value.</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.select(pl.col(&quot;foo&quot;).cumsum().inspect(&quot;value is: {}&quot;).alias(&quot;bar&quot;))</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def inspect(self, fmt: str = &quot;{}&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Prints the value that this expression evaluates to and passes on the value.

        &gt;&gt;&gt; df.select(pl.col(&quot;foo&quot;).cumsum().inspect(&quot;value is: {}&quot;).alias(&quot;bar&quot;))
        &quot;&quot;&quot;

        def inspect(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            print(fmt.format(s))  # type: ignore
            return s

        return self.map(inspect, return_dtype=None, agg_list=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprinspectinspect"><a class="header" href="#polarsinternalsexprexprinspectinspect"><code>polars.internals.expr.Expr.inspect.inspect</code></a></h3>
<pre><code class="language-python">inspect(s: pli.Series) -&gt; pli.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def inspect(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            print(fmt.format(s))  # type: ignore
            return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprinterpolate"><a class="header" href="#polarsinternalsexprexprinterpolate"><code>polars.internals.expr.Expr.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; Expr:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.interpolate())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_min"><a class="header" href="#polarsinternalsexprexprrolling_min"><code>polars.internals.expr.Expr.rolling_min</code></a></h3>
<pre><code class="language-python">rolling_min(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>apply a rolling min (moving min) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_min(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_max"><a class="header" href="#polarsinternalsexprexprrolling_max"><code>polars.internals.expr.Expr.rolling_max</code></a></h3>
<pre><code class="language-python">rolling_max(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Apply a rolling max (moving max) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_max(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_mean"><a class="header" href="#polarsinternalsexprexprrolling_mean"><code>polars.internals.expr.Expr.rolling_mean</code></a></h3>
<pre><code class="language-python">rolling_mean(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Apply a rolling mean (moving mean) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0]
}
)
df.select([
pl.col(&quot;A&quot;).rolling_mean(window_size=2)
])
shape: (6, 1)
┌──────┐
│ A    │
│ ---  │
│ f64  │
╞══════╡
│ null │
├╌╌╌╌╌╌┤
│ 4.5  │
├╌╌╌╌╌╌┤
│ 7    │
├╌╌╌╌╌╌┤
│ 4    │
├╌╌╌╌╌╌┤
│ 9    │
├╌╌╌╌╌╌┤
│ 13   │
└──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0]
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_mean(window_size=2)
        &gt;&gt;&gt; ])
        shape: (6, 1)
        ┌──────┐
        │ A    │
        │ ---  │
        │ f64  │
        ╞══════╡
        │ null │
        ├╌╌╌╌╌╌┤
        │ 4.5  │
        ├╌╌╌╌╌╌┤
        │ 7    │
        ├╌╌╌╌╌╌┤
        │ 4    │
        ├╌╌╌╌╌╌┤
        │ 9    │
        ├╌╌╌╌╌╌┤
        │ 13   │
        └──────┘

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_mean(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_sum"><a class="header" href="#polarsinternalsexprexprrolling_sum"><code>polars.internals.expr.Expr.rolling_sum</code></a></h3>
<pre><code class="language-python">rolling_sum(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Apply a rolling sum (moving sum) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_sum(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_std"><a class="header" href="#polarsinternalsexprexprrolling_std"><code>polars.internals.expr.Expr.rolling_std</code></a></h3>
<pre><code class="language-python">rolling_std(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Compute a rolling std dev</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_std(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_var"><a class="header" href="#polarsinternalsexprexprrolling_var"><code>polars.internals.expr.Expr.rolling_var</code></a></h3>
<pre><code class="language-python">rolling_var(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Compute a rolling variance.</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_var(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_apply"><a class="header" href="#polarsinternalsexprexprrolling_apply"><code>polars.internals.expr.Expr.rolling_apply</code></a></h3>
<pre><code class="language-python">rolling_apply(window_size: int, 
    function: Callable[[pli.Series], Any],) -&gt; Expr:
</code></pre>
<p>Allows a custom rolling window function.
Prefer the specific rolling window functions over this one, as they are faster.</p>
<p>Prefer:
* rolling_min
* rolling_max
* rolling_mean
* rolling_sum</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>function</code>]: Aggregation function</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1.0, 2.0, 9.0, 2.0, 13.0],
}
)
df.select([
pl.col(&quot;A&quot;).rolling_apply(3, lambda s: s.std())
])
shape: (5, 1)
┌────────────────────┐
│ A                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ null               │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ null               │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4.358898943540674  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4.041451884327381  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5.5677643628300215 │
└────────────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.

        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum

        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function


        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 2.0, 9.0, 2.0, 13.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_apply(3, lambda s: s.std())
        &gt;&gt;&gt; ])
        shape: (5, 1)
        ┌────────────────────┐
        │ A                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.358898943540674  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.041451884327381  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5.5677643628300215 │
        └────────────────────┘

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_apply(window_size, function))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_median"><a class="header" href="#polarsinternalsexprexprrolling_median"><code>polars.internals.expr.Expr.rolling_median</code></a></h3>
<pre><code class="language-python">rolling_median(window_size: int) -&gt; Expr:
</code></pre>
<p>Compute a rolling median</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_median(self, window_size: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_median(window_size))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_quantile"><a class="header" href="#polarsinternalsexprexprrolling_quantile"><code>polars.internals.expr.Expr.rolling_quantile</code></a></h3>
<pre><code class="language-python">rolling_quantile(window_size: int, 
    quantile: float,) -&gt; Expr:
</code></pre>
<p>Compute a rolling quantile</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>quantile</code>]: quantile to compute</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_quantile(window_size, quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_skew"><a class="header" href="#polarsinternalsexprexprrolling_skew"><code>polars.internals.expr.Expr.rolling_skew</code></a></h3>
<pre><code class="language-python">rolling_skew(window_size: int, bias: bool) -&gt; Expr:
</code></pre>
<p>Compute a rolling skew</p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>bias</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_skew(window_size, bias))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprabs"><a class="header" href="#polarsinternalsexprexprabs"><code>polars.internals.expr.Expr.abs</code></a></h3>
<pre><code class="language-python">abs() -&gt; Expr:
</code></pre>
<p>Take absolute values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def abs(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.abs())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprargsort"><a class="header" href="#polarsinternalsexprexprargsort"><code>polars.internals.expr.Expr.argsort</code></a></h3>
<pre><code class="language-python">argsort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Index location of the sorted variant of this Series.
<strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the ordering. Default is from low to high.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def argsort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.
        Parameters
        ----------
        reverse
            Reverse the ordering. Default is from low to high.
        &quot;&quot;&quot;
        return pli.argsort_by([self], [reverse])
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrank"><a class="header" href="#polarsinternalsexprexprrank"><code>polars.internals.expr.Expr.rank</code></a></h3>
<pre><code class="language-python">rank(method: str) -&gt; Expr:
</code></pre>
<p>Assign ranks to data, dealing with ties appropriately.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>method</code>]: {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
The method used to assign ranks to tied elements.
The following methods are available (default is 'average'):
* 'average': The average of the ranks that would have been assigned to
all the tied values is assigned to each value.
* 'min': The minimum of the ranks that would have been assigned to all
the tied values is assigned to each value.  (This is also
referred to as &quot;competition&quot; ranking.)
* 'max': The maximum of the ranks that would have been assigned to all
the tied values is assigned to each value.
* 'dense': Like 'min', but the rank of the next highest element is</li>
<li>
<pre><code>* 'ordinal': All values are given a distinct rank, corresponding to
  the order that the values occur in `a`.
* 'random': Like 'ordinal', but the rank for ties is not dependent
  on the order that the values occur in `a`.
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rank(method))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdiff"><a class="header" href="#polarsinternalsexprexprdiff"><code>polars.internals.expr.Expr.diff</code></a></h3>
<pre><code class="language-python">diff(n: int, null_behavior: str) -&gt; Expr:
</code></pre>
<p>Calculate the n-th discrete difference.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: number of slots to shift</li>
<li>[<code>null_behavior</code>]: {'ignore', 'drop'}</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.diff(n, null_behavior))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprskew"><a class="header" href="#polarsinternalsexprexprskew"><code>polars.internals.expr.Expr.skew</code></a></h3>
<pre><code class="language-python">skew(bias: bool) -&gt; Expr:
</code></pre>
<p>Compute the sample skewness of a data set.
For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function <code>skewtest</code> can be used to determine if the skewness value
is close enough to zero, statistically speaking.</p>
<p>See scipy.stats for more information.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p><strong>Notes:</strong></p>
<p>The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.
.. math::
g_1=\frac{m_3}{m_2^{3/2}}
where
.. math::
m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
is the biased sample :math:<code>i\texttt{th}</code> central moment, and
:math:<code>\bar{x}</code> is
the sample mean.  If <code>bias</code> is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.
.. math::
G_1=\frac{k_3}{k_2^{3/2}}=
\frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def skew(self, bias: bool = True) -&gt; &quot;Expr&quot;:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.skew(bias))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprkurtosis"><a class="header" href="#polarsinternalsexprexprkurtosis"><code>polars.internals.expr.Expr.kurtosis</code></a></h3>
<pre><code class="language-python">kurtosis(fisher: bool, bias: bool) -&gt; Expr:
</code></pre>
<p>Compute the kurtosis (Fisher or Pearson) of a dataset.
Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.
If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators</p>
<p>See scipy.stats for more information</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fisher</code> [<code>bool, optional</code>]: If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
Pearson's definition is used (normal ==&gt; 3.0).</li>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.kurtosis(fisher, bias))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprclip"><a class="header" href="#polarsinternalsexprexprclip"><code>polars.internals.expr.Expr.clip</code></a></h3>
<pre><code class="language-python">clip(min_val: Union[int, float], 
    max_val: Union[int, float],) -&gt; Expr:
</code></pre>
<p>Clip (limit) the values in an array.</p>
<p><strong>Parameters:</strong></p>
<p>min_val, max_val
Minimum and maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        min_val = pli.lit(min_val)  # type: ignore
        max_val = pli.lit(max_val)  # type: ignore

        return (
            pli.when(self &lt; min_val)  # type: ignore
            .then(min_val)
            .when(self &gt; max_val)
            .then(max_val)
            .otherwise(self)
        ).keep_name()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlower_bound"><a class="header" href="#polarsinternalsexprexprlower_bound"><code>polars.internals.expr.Expr.lower_bound</code></a></h3>
<pre><code class="language-python">lower_bound() -&gt; Expr:
</code></pre>
<p>Returns a unit Series with the lowest value possible for the dtype of this expression.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lower_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the lowest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lower_bound())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprupper_bound"><a class="header" href="#polarsinternalsexprexprupper_bound"><code>polars.internals.expr.Expr.upper_bound</code></a></h3>
<pre><code class="language-python">upper_bound() -&gt; Expr:
</code></pre>
<p>Returns a unit Series with the highest value possible for the dtype of this expression.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def upper_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the highest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.upper_bound())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstr_concat"><a class="header" href="#polarsinternalsexprexprstr_concat"><code>polars.internals.expr.Expr.str_concat</code></a></h3>
<pre><code class="language-python">str_concat(delimiter: str) -&gt; Expr:
</code></pre>
<p>Vertically concat the values in the Series to a single string value.</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Utf8</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, None, 2]})
&gt;&gt;&gt; df = df.select(pl.col(&quot;foo&quot;).str_concat(&quot;-&quot;))
shape: (1, 1)
┌──────────┐
│ foo      │
│ ---      │
│ str      │
╞══════════╡
│ 1-null-2 │
└──────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, None, 2]})
        &gt;&gt;&gt; df = df.select(pl.col(&quot;foo&quot;).str_concat(&quot;-&quot;))
        shape: (1, 1)
        ┌──────────┐
        │ foo      │
        │ ---      │
        │ str      │
        ╞══════════╡
        │ 1-null-2 │
        └──────────┘
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_concat(delimiter))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsin"><a class="header" href="#polarsinternalsexprexprsin"><code>polars.internals.expr.Expr.sin</code></a></h3>
<pre><code class="language-python">sin() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric sine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).sin())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 0.8414709848078965 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).sin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.8414709848078965 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcos"><a class="header" href="#polarsinternalsexprexprcos"><code>polars.internals.expr.Expr.cos</code></a></h3>
<pre><code class="language-python">cos() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric cosine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).cos())
shape: (1, 1)
┌─────┐
│ a   │
│ --- │
│ f64 │
╞═════╡
│ 1   │
└─────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).cos())
        shape: (1, 1)
        ┌─────┐
        │ a   │
        │ --- │
        │ f64 │
        ╞═════╡
        │ 1   │
        └─────┘
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtan"><a class="header" href="#polarsinternalsexprexprtan"><code>polars.internals.expr.Expr.tan</code></a></h3>
<pre><code class="language-python">tan() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric tangent on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).tan())
shape: (1, 1)
┌───────────────────┐
│ a                 │
│ ---               │
│ f64               │
╞═══════════════════╡
│ 1.557407724654902 │
└───────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).tan())
        shape: (1, 1)
        ┌───────────────────┐
        │ a                 │
        │ ---               │
        │ f64               │
        ╞═══════════════════╡
        │ 1.557407724654902 │
        └───────────────────┘
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarcsin"><a class="header" href="#polarsinternalsexprexprarcsin"><code>polars.internals.expr.Expr.arcsin</code></a></h3>
<pre><code class="language-python">arcsin() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric sine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arcsin())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 1.5707963267948966 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arcsin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arcsin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarccos"><a class="header" href="#polarsinternalsexprexprarccos"><code>polars.internals.expr.Expr.arccos</code></a></h3>
<pre><code class="language-python">arccos() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric cosine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arccos())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 1.5707963267948966 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arccos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arccos())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarctan"><a class="header" href="#polarsinternalsexprexprarctan"><code>polars.internals.expr.Expr.arctan</code></a></h3>
<pre><code class="language-python">arctan() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric tangent on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arctan())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 0.7853981633974483 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arctan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arctan())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.7853981633974483 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprreshape"><a class="header" href="#polarsinternalsexprexprreshape"><code>polars.internals.expr.Expr.reshape</code></a></h3>
<pre><code class="language-python">reshape(dims: tp.Tuple[int, ]) -&gt; Expr:
</code></pre>
<p>Reshape this Expr to a flat series, shape: (len,)
or a List series, shape: (rows, cols)</p>
<p>if a -1 is used in any of the dimensions, that dimension is inferred.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dims</code>]: Tuple of the dimension sizes</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reshape this Expr to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Expr
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsexprexprlistnamespace"><a class="header" href="#polarsinternalsexprexprlistnamespace"><code>polars.internals.expr.ExprListNameSpace</code></a></h1>
<p>Namespace for list related expressions</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacelengths"><code>lengths()</code></a>: Get the length of the arrays as UInt32.</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacesum"><code>sum()</code></a>: Sum all the arrays in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacemax"><code>max()</code></a>: Compute the max value of the arrays in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacemin"><code>min()</code></a>: Compute the min value of the arrays in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacemean"><code>mean()</code></a>: Compute the mean value of the arrays in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacesort"><code>sort()</code></a>: Sort the arrays in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespacereverse"><code>reverse()</code></a>: Reverse the arrays in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespaceunique"><code>unique()</code></a>: Get the unique/distinct values in the list</li>
<li><a href="polars/internals/expr/ExprListNameSpace.html#polarsinternalsexprexprlistnamespaceconcat"><code>concat()</code></a>: Concat the arrays in a Series dtype List in linear time.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class ExprListNameSpace:
    &quot;&quot;&quot;
    Namespace for list related expressions
    &quot;&quot;&quot;

    def __init__(self, expr: Expr):
        self._pyexpr = expr._pyexpr

    def lengths(self) -&gt; Expr:
        &quot;&quot;&quot;
        Get the length of the arrays as UInt32.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arr_lengths())

    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sum all the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_sum())

    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the max value of the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_max())

    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the min value of the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_min())

    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the mean value of the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_mean())

    def sort(self, reverse: bool) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_sort(reverse))

    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_reverse())

    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the unique/distinct values in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_unique())

    def concat(self, other: Union[tp.List[Expr], Expr, str, tp.List[str]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Concat the arrays in a Series dtype List in linear time.

        Parameters
        ----------
        other
            Columns to concat into a List Series
        &quot;&quot;&quot;
        if not isinstance(other, list):
            other = [other]  # type: ignore
        else:
            other = copy.copy(other)
        # mypy does not understand we have a list by now
        other.insert(0, wrap_expr(self._pyexpr))  # type: ignore
        return pli.concat_list(other)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-2"><a class="header" href="#constructor-2">Constructor</a></h2>
<pre><code class="language-python">ExprListNameSpace(expr: Expr)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, expr: Expr):
        self._pyexpr = expr._pyexpr
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-2"><a class="header" href="#methods-2">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacelengths"><a class="header" href="#polarsinternalsexprexprlistnamespacelengths"><code>polars.internals.expr.ExprListNameSpace.lengths</code></a></h3>
<pre><code class="language-python">lengths() -&gt; Expr:
</code></pre>
<p>Get the length of the arrays as UInt32.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lengths(self) -&gt; Expr:
        &quot;&quot;&quot;
        Get the length of the arrays as UInt32.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arr_lengths())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacesum"><a class="header" href="#polarsinternalsexprexprlistnamespacesum"><code>polars.internals.expr.ExprListNameSpace.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Expr:
</code></pre>
<p>Sum all the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sum all the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_sum())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacemax"><a class="header" href="#polarsinternalsexprexprlistnamespacemax"><code>polars.internals.expr.ExprListNameSpace.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Expr:
</code></pre>
<p>Compute the max value of the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the max value of the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacemin"><a class="header" href="#polarsinternalsexprexprlistnamespacemin"><code>polars.internals.expr.ExprListNameSpace.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Expr:
</code></pre>
<p>Compute the min value of the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the min value of the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacemean"><a class="header" href="#polarsinternalsexprexprlistnamespacemean"><code>polars.internals.expr.ExprListNameSpace.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Expr:
</code></pre>
<p>Compute the mean value of the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the mean value of the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_mean())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacesort"><a class="header" href="#polarsinternalsexprexprlistnamespacesort"><code>polars.internals.expr.ExprListNameSpace.sort</code></a></h3>
<pre><code class="language-python">sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Sort the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, reverse: bool) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespacereverse"><a class="header" href="#polarsinternalsexprexprlistnamespacereverse"><code>polars.internals.expr.ExprListNameSpace.reverse</code></a></h3>
<pre><code class="language-python">reverse() -&gt; Expr:
</code></pre>
<p>Reverse the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the arrays in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_reverse())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespaceunique"><a class="header" href="#polarsinternalsexprexprlistnamespaceunique"><code>polars.internals.expr.ExprListNameSpace.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Expr:
</code></pre>
<p>Get the unique/distinct values in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the unique/distinct values in the list
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lst_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlistnamespaceconcat"><a class="header" href="#polarsinternalsexprexprlistnamespaceconcat"><code>polars.internals.expr.ExprListNameSpace.concat</code></a></h3>
<pre><code class="language-python">concat(other: Union[tp.List[Expr], Expr, str, tp.List[str]],) -&gt; Expr:
</code></pre>
<p>Concat the arrays in a Series dtype List in linear time.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Columns to concat into a List Series</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def concat(self, other: Union[tp.List[Expr], Expr, str, tp.List[str]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Concat the arrays in a Series dtype List in linear time.

        Parameters
        ----------
        other
            Columns to concat into a List Series
        &quot;&quot;&quot;
        if not isinstance(other, list):
            other = [other]  # type: ignore
        else:
            other = copy.copy(other)
        # mypy does not understand we have a list by now
        other.insert(0, wrap_expr(self._pyexpr))  # type: ignore
        return pli.concat_list(other)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsexprexprstringnamespace"><a class="header" href="#polarsinternalsexprexprstringnamespace"><code>polars.internals.expr.ExprStringNameSpace</code></a></h1>
<p>Namespace for string related expressions</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespacestrptime"><code>strptime()</code></a>: Parse utf8 expression as a Date/Datetimetype.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespacelengths"><code>lengths()</code></a>: Get the length of the Strings as UInt32.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespaceto_uppercase"><code>to_uppercase()</code></a>: Transform to uppercase variant.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespaceto_lowercase"><code>to_lowercase()</code></a>: Transform to lowercase variant.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespacecontains"><code>contains()</code></a>: Check if string contains regex.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespacejson_path_match"><code>json_path_match()</code></a>: Extract the first match of json string with provided JSONPath expression.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespaceextract"><code>extract()</code></a>: Extract the target capture group from provided patterns.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespacereplace"><code>replace()</code></a>: Replace first regex match with a string value.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespacereplace_all"><code>replace_all()</code></a>: Replace substring on all regex pattern matches.</li>
<li><a href="polars/internals/expr/ExprStringNameSpace.html#polarsinternalsexprexprstringnamespaceslice"><code>slice()</code></a>: Create subslices of the string values of a Utf8 Series.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class ExprStringNameSpace:
    &quot;&quot;&quot;
    Namespace for string related expressions
    &quot;&quot;&quot;

    def __init__(self, expr: Expr):
        self._pyexpr = expr._pyexpr

    def strptime(
        self,
        datatype: Union[Type[Date], Type[Datetime]],
        fmt: Optional[str] = None,
    ) -&gt; Expr:
        &quot;&quot;&quot;
        Parse utf8 expression as a Date/Datetimetype.

        Parameters
        ----------
        datatype
            Date | Datetime.
        fmt
            &quot;yyyy-mm-dd&quot;.
        &quot;&quot;&quot;
        if datatype == Date:
            return wrap_expr(self._pyexpr.str_parse_date(fmt))
        elif datatype == Datetime:
            return wrap_expr(self._pyexpr.str_parse_datetime(fmt))
        else:
            raise NotImplementedError

    def lengths(self) -&gt; Expr:
        &quot;&quot;&quot;
        Get the length of the Strings as UInt32.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_lengths())

    def to_uppercase(self) -&gt; Expr:
        &quot;&quot;&quot;
        Transform to uppercase variant.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_to_uppercase())

    def to_lowercase(self) -&gt; Expr:
        &quot;&quot;&quot;
        Transform to lowercase variant.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_to_lowercase())

    def contains(self, pattern: str) -&gt; Expr:
        &quot;&quot;&quot;
        Check if string contains regex.

        Parameters
        ----------
        pattern
            Regex pattern.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_contains(pattern))

    def json_path_match(self, json_path: str) -&gt; Expr:
        &quot;&quot;&quot;
        Extract the first match of json string with provided JSONPath expression.
        Throw errors if encounter invalid json strings.
        All return value will be casted to Utf8 regardless of the original value.
        Documentation on JSONPath standard: https://goessner.net/articles/JsonPath/

        Parameters
        ----------
        json_path
            A valid JSON path query string

        Returns
        -------
        Utf8 array. Contain null if original value is null or the json_path return nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        'json_val' = ['{&quot;a&quot;:&quot;1&quot;}',None,'{&quot;a&quot;:2}', '{&quot;a&quot;:2.1}', '{&quot;a&quot;:true}']
        })
        &gt;&gt;&gt; df.select(pl.col('json_val').str.json_path_match('$.a')
        shape: (5,)
        Series: 'json_val' [str]
        [
            &quot;1&quot;
            null
            &quot;2&quot;
            &quot;2.1&quot;
            &quot;true&quot;
        ]
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_json_path_match(json_path))

    def extract(self, pattern: str, group_index: int = 1) -&gt; Expr:
        r&quot;&quot;&quot;
        Extract the target capture group from provided patterns.

        Parameters
        ----------
        pattern
            A valid regex pattern
        group_index
            Index of the targeted capture group.
            Group 0 mean the whole pattern, first group begin at index 1
            Default to the first capture group

        Returns
        -------
        Utf8 array. Contain null if original value is null or regex capture nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        ...         'a': [
        ...             'http://vote.com/ballon_dor?candidate=messi&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidat=jorginho&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars'
        ...         ]})
        &gt;&gt;&gt; df.select([
        ...             pl.col('a').str.extract(r'candidate=(\w+)', 1)
        ...         ])
        shape: (3, 1)
        ┌─────────┐
        │ a       │
        │ ---     │
        │ str     │
        ╞═════════╡
        │ messi   │
        ├╌╌╌╌╌╌╌╌╌┤
        │ null    │
        ├╌╌╌╌╌╌╌╌╌┤
        │ ronaldo │
        └─────────┘
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_extract(pattern, group_index))

    def replace(self, pattern: str, value: str) -&gt; Expr:
        &quot;&quot;&quot;
        Replace first regex match with a string value.

        Parameters
        ----------
        pattern
            Regex pattern.
        value
            Replacement string.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_replace(pattern, value))

    def replace_all(self, pattern: str, value: str) -&gt; Expr:
        &quot;&quot;&quot;
        Replace substring on all regex pattern matches.

        Parameters
        ----------
        pattern
            Regex pattern.
        value
            Replacement string.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_replace_all(pattern, value))

    def slice(self, start: int, length: Optional[int] = None) -&gt; Expr:
        &quot;&quot;&quot;
        Create subslices of the string values of a Utf8 Series.

        Parameters
        ----------
        start
            Start of the slice (negative indexing may be used).
        length
            Optional length of the slice.

        Returns
        -------
        Series of Utf8 type
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_slice(start, length))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-3"><a class="header" href="#constructor-3">Constructor</a></h2>
<pre><code class="language-python">ExprStringNameSpace(expr: Expr)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, expr: Expr):
        self._pyexpr = expr._pyexpr
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-3"><a class="header" href="#methods-3">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespacestrptime"><a class="header" href="#polarsinternalsexprexprstringnamespacestrptime"><code>polars.internals.expr.ExprStringNameSpace.strptime</code></a></h3>
<pre><code class="language-python">strptime(datatype: Union[TypeDate, TypeDatetime], 
    fmt: Optionalstr,) -&gt; Expr:
</code></pre>
<p>Parse utf8 expression as a Date/Datetimetype.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>datatype</code>]: Date | Datetime.</li>
<li></li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def strptime(
        self,
        datatype: Union[Type[Date], Type[Datetime]],
        fmt: Optional[str] = None,
    ) -&gt; Expr:
        &quot;&quot;&quot;
        Parse utf8 expression as a Date/Datetimetype.

        Parameters
        ----------
        datatype
            Date | Datetime.
        fmt
            &quot;yyyy-mm-dd&quot;.
        &quot;&quot;&quot;
        if datatype == Date:
            return wrap_expr(self._pyexpr.str_parse_date(fmt))
        elif datatype == Datetime:
            return wrap_expr(self._pyexpr.str_parse_datetime(fmt))
        else:
            raise NotImplementedError
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespacelengths"><a class="header" href="#polarsinternalsexprexprstringnamespacelengths"><code>polars.internals.expr.ExprStringNameSpace.lengths</code></a></h3>
<pre><code class="language-python">lengths() -&gt; Expr:
</code></pre>
<p>Get the length of the Strings as UInt32.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lengths(self) -&gt; Expr:
        &quot;&quot;&quot;
        Get the length of the Strings as UInt32.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_lengths())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespaceto_uppercase"><a class="header" href="#polarsinternalsexprexprstringnamespaceto_uppercase"><code>polars.internals.expr.ExprStringNameSpace.to_uppercase</code></a></h3>
<pre><code class="language-python">to_uppercase() -&gt; Expr:
</code></pre>
<p>Transform to uppercase variant.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_uppercase(self) -&gt; Expr:
        &quot;&quot;&quot;
        Transform to uppercase variant.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_to_uppercase())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespaceto_lowercase"><a class="header" href="#polarsinternalsexprexprstringnamespaceto_lowercase"><code>polars.internals.expr.ExprStringNameSpace.to_lowercase</code></a></h3>
<pre><code class="language-python">to_lowercase() -&gt; Expr:
</code></pre>
<p>Transform to lowercase variant.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_lowercase(self) -&gt; Expr:
        &quot;&quot;&quot;
        Transform to lowercase variant.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_to_lowercase())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespacecontains"><a class="header" href="#polarsinternalsexprexprstringnamespacecontains"><code>polars.internals.expr.ExprStringNameSpace.contains</code></a></h3>
<pre><code class="language-python">contains(pattern: str) -&gt; Expr:
</code></pre>
<p>Check if string contains regex.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: Regex pattern.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def contains(self, pattern: str) -&gt; Expr:
        &quot;&quot;&quot;
        Check if string contains regex.

        Parameters
        ----------
        pattern
            Regex pattern.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_contains(pattern))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespacejson_path_match"><a class="header" href="#polarsinternalsexprexprstringnamespacejson_path_match"><code>polars.internals.expr.ExprStringNameSpace.json_path_match</code></a></h3>
<pre><code class="language-python">json_path_match(json_path: str) -&gt; Expr:
</code></pre>
<p>Extract the first match of json string with provided JSONPath expression.
Throw errors if encounter invalid json strings.
All return value will be casted to Utf8 regardless of the original value.
Documentation on JSONPath standard: https:/goessner.net/articles/JsonPath/</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>json_path</code>]: A valid JSON path query string</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Utf8 array. Contain null if original value is null or the json_path return nothing.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
'json_val' = ['{&quot;a&quot;:&quot;1&quot;}',None,'{&quot;a&quot;:2}', '{&quot;a&quot;:2.1}', '{&quot;a&quot;:true}']
})
df.select(pl.col('json_val').str.json_path_match('$.a')
shape: (5,)
Series: 'json_val' [str]
[
&quot;1&quot;</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>&quot;true&quot;
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def json_path_match(self, json_path: str) -&gt; Expr:
        &quot;&quot;&quot;
        Extract the first match of json string with provided JSONPath expression.
        Throw errors if encounter invalid json strings.
        All return value will be casted to Utf8 regardless of the original value.
        Documentation on JSONPath standard: https://goessner.net/articles/JsonPath/

        Parameters
        ----------
        json_path
            A valid JSON path query string

        Returns
        -------
        Utf8 array. Contain null if original value is null or the json_path return nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        'json_val' = ['{&quot;a&quot;:&quot;1&quot;}',None,'{&quot;a&quot;:2}', '{&quot;a&quot;:2.1}', '{&quot;a&quot;:true}']
        })
        &gt;&gt;&gt; df.select(pl.col('json_val').str.json_path_match('$.a')
        shape: (5,)
        Series: 'json_val' [str]
        [
            &quot;1&quot;
            null
            &quot;2&quot;
            &quot;2.1&quot;
            &quot;true&quot;
        ]
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_json_path_match(json_path))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespaceextract"><a class="header" href="#polarsinternalsexprexprstringnamespaceextract"><code>polars.internals.expr.ExprStringNameSpace.extract</code></a></h3>
<pre><code class="language-python">extract(pattern: str, group_index: int) -&gt; Expr:
</code></pre>
<p>Extract the target capture group from provided patterns.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: A valid regex pattern</li>
<li>[<code>group_index</code>]: Index of the targeted capture group.
Group 0 mean the whole pattern, first group begin at index 1
Default to the first capture group</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Utf8 array. Contain null if original value is null or regex capture nothing.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
...         'a': [
...             'http:/vote.com/ballon_dor?candidate=messi&amp;ref=polars',
...             'http:/vote.com/ballon_dor?candidat=jorginho&amp;ref=polars',
...             'http:/vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars'
...         ]})
df.select([
...             pl.col('a').str.extract(r'candidate=(\w+)', 1)
...         ])
shape: (3, 1)
┌─────────┐
│ a       │
│ ---     │
│ str     │
╞═════════╡
│ messi   │
├╌╌╌╌╌╌╌╌╌┤
│ null    │
├╌╌╌╌╌╌╌╌╌┤
│ ronaldo │
└─────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def extract(self, pattern: str, group_index: int = 1) -&gt; Expr:
        r&quot;&quot;&quot;
        Extract the target capture group from provided patterns.

        Parameters
        ----------
        pattern
            A valid regex pattern
        group_index
            Index of the targeted capture group.
            Group 0 mean the whole pattern, first group begin at index 1
            Default to the first capture group

        Returns
        -------
        Utf8 array. Contain null if original value is null or regex capture nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        ...         'a': [
        ...             'http://vote.com/ballon_dor?candidate=messi&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidat=jorginho&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars'
        ...         ]})
        &gt;&gt;&gt; df.select([
        ...             pl.col('a').str.extract(r'candidate=(\w+)', 1)
        ...         ])
        shape: (3, 1)
        ┌─────────┐
        │ a       │
        │ ---     │
        │ str     │
        ╞═════════╡
        │ messi   │
        ├╌╌╌╌╌╌╌╌╌┤
        │ null    │
        ├╌╌╌╌╌╌╌╌╌┤
        │ ronaldo │
        └─────────┘
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_extract(pattern, group_index))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespacereplace"><a class="header" href="#polarsinternalsexprexprstringnamespacereplace"><code>polars.internals.expr.ExprStringNameSpace.replace</code></a></h3>
<pre><code class="language-python">replace(pattern: str, value: str) -&gt; Expr:
</code></pre>
<p>Replace first regex match with a string value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: Regex pattern.</li>
<li>[<code>value</code>]: Replacement string.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace(self, pattern: str, value: str) -&gt; Expr:
        &quot;&quot;&quot;
        Replace first regex match with a string value.

        Parameters
        ----------
        pattern
            Regex pattern.
        value
            Replacement string.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_replace(pattern, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespacereplace_all"><a class="header" href="#polarsinternalsexprexprstringnamespacereplace_all"><code>polars.internals.expr.ExprStringNameSpace.replace_all</code></a></h3>
<pre><code class="language-python">replace_all(pattern: str, value: str) -&gt; Expr:
</code></pre>
<p>Replace substring on all regex pattern matches.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: Regex pattern.</li>
<li>[<code>value</code>]: Replacement string.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace_all(self, pattern: str, value: str) -&gt; Expr:
        &quot;&quot;&quot;
        Replace substring on all regex pattern matches.

        Parameters
        ----------
        pattern
            Regex pattern.
        value
            Replacement string.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_replace_all(pattern, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstringnamespaceslice"><a class="header" href="#polarsinternalsexprexprstringnamespaceslice"><code>polars.internals.expr.ExprStringNameSpace.slice</code></a></h3>
<pre><code class="language-python">slice(start: int, length: Optionalint) -&gt; Expr:
</code></pre>
<p>Create subslices of the string values of a Utf8 Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>start</code>]: Start of the slice (negative indexing may be used).</li>
<li>[<code>length</code>]: Optional length of the slice.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series of Utf8 type</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, start: int, length: Optional[int] = None) -&gt; Expr:
        &quot;&quot;&quot;
        Create subslices of the string values of a Utf8 Series.

        Parameters
        ----------
        start
            Start of the slice (negative indexing may be used).
        length
            Optional length of the slice.

        Returns
        -------
        Series of Utf8 type
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_slice(start, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsexprexprdatetimenamespace"><a class="header" href="#polarsinternalsexprexprdatetimenamespace"><code>polars.internals.expr.ExprDateTimeNameSpace</code></a></h1>
<p>Namespace for datetime related expressions.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacebuckets"><code>buckets()</code></a>: Divide the date/ datetime range into buckets.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacestrftime"><code>strftime()</code></a>: Format Date/datetime with a formatting rule: See <a href="https:/docs.rs/chrono/0.4.19/chrono/format/strftime/index.html">chrono strftime/strptime</a>.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceyear"><code>year()</code></a>: Extract year from underlying Date representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacemonth"><code>month()</code></a>: Extract month from underlying Date representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceweek"><code>week()</code></a>: Extract the week from the underlying Date representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceweekday"><code>weekday()</code></a>: Extract the week day from the underlying Date representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceday"><code>day()</code></a>: Extract day from underlying Date representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceordinal_day"><code>ordinal_day()</code></a>: Extract ordinal day from underlying Date representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacehour"><code>hour()</code></a>: Extract hour from underlying DateTime representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceminute"><code>minute()</code></a>: Extract minutes from underlying DateTime representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacesecond"><code>second()</code></a>: Extract seconds from underlying DateTime representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacenanosecond"><code>nanosecond()</code></a>: Extract seconds from underlying DateTime representation.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceround"><code>round()</code></a>: Round the datetime.</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespaceto_python_datetime"><code>to_python_datetime()</code></a>: Go from Date/Datetime to python DateTime objects</li>
<li><a href="polars/internals/expr/ExprDateTimeNameSpace.html#polarsinternalsexprexprdatetimenamespacetimestamp"><code>timestamp()</code></a>: Return timestamp in ms as Int64 type.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class ExprDateTimeNameSpace:
    &quot;&quot;&quot;
    Namespace for datetime related expressions.
    &quot;&quot;&quot;

    def __init__(self, expr: Expr):
        self._pyexpr = expr._pyexpr

    def buckets(self, interval: timedelta) -&gt; Expr:
        &quot;&quot;&quot;
        Divide the date/ datetime range into buckets.
        Data will be sorted by this operation.

        Parameters
        ----------
        interval
            python timedelta to indicate bucket size

        Returns
        -------
        Date/Datetime series

        Examples
        --------
        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; import polars as pl
        &gt;&gt;&gt; date_range = pl.date_range(
        &gt;&gt;&gt; low=datetime(year=2000, month=10, day=1, hour=23, minute=30),
        &gt;&gt;&gt; high=datetime(year=2000, month=10, day=2, hour=0, minute=30),
        &gt;&gt;&gt; interval=timedelta(minutes=8),
        &gt;&gt;&gt; name=&quot;date_range&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; date_range.dt.buckets(timedelta(minutes=8))
        shape: (8,)
        Series: 'date_range' [datetime]
        [
            2000-10-01 23:30:00
            2000-10-01 23:30:00
            2000-10-01 23:38:00
            2000-10-01 23:46:00
            2000-10-01 23:54:00
            2000-10-02 00:02:00
            2000-10-02 00:10:00
            2000-10-02 00:18:00
        ]

        &gt;&gt;&gt; # can be used to perform a downsample operation
        &gt;&gt;&gt; (date_range
        &gt;&gt;&gt;  .to_frame()
        &gt;&gt;&gt;  .groupby(
        &gt;&gt;&gt;      pl.col(&quot;date_range&quot;).dt.buckets(timedelta(minutes=16)),
        &gt;&gt;&gt;      maintain_order=True
        &gt;&gt;&gt;  )
        &gt;&gt;&gt;  .agg(pl.col(&quot;date_range&quot;).count())
        &gt;&gt;&gt; )
        shape: (4, 2)
        ┌─────────────────────┬──────────────────┐
        │ date_range          ┆ date_range_count │
        │ ---                 ┆ ---              │
        │ datetime            ┆ u32              │
        ╞═════════════════════╪══════════════════╡
        │ 2000-10-01 23:30:00 ┆ 3                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-01 23:46:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:02:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:18:00 ┆ 1                │
        └─────────────────────┴──────────────────┘

        &quot;&quot;&quot;

        return wrap_expr(
            self._pyexpr.date_buckets(
                interval.days, interval.seconds, interval.microseconds
            )
        )

    def strftime(self, fmt: str) -&gt; Expr:
        &quot;&quot;&quot;
        Format Date/datetime with a formatting rule: See [chrono strftime/strptime](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.strftime(fmt))

    def year(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract year from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the year number in the calendar date.

        Returns
        -------
        Year as Int32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.year())

    def month(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract month from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the month number starting from 1.
        The return value ranges from 1 to 12.

        Returns
        -------
        Month as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.month())

    def week(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract the week from the underlying Date representation.
        Can be performed on Date and Datetime

        Returns the ISO week number starting from 1.
        The return value ranges from 1 to 53. (The last week of year differs by years.)

        Returns
        -------
        Week number as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.week())

    def weekday(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract the week day from the underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the weekday number where monday = 0 and sunday = 6

        Returns
        -------
        Week day as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.weekday())

    def day(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract day from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the day of month starting from 1.
        The return value ranges from 1 to 31. (The last day of month differs by months.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.day())

    def ordinal_day(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract ordinal day from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the day of year starting from 1.
        The return value ranges from 1 to 366. (The last day of year differs by years.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.ordinal_day())

    def hour(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract hour from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the hour number from 0 to 23.

        Returns
        -------
        Hour as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hour())

    def minute(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract minutes from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the minute number from 0 to 59.

        Returns
        -------
        Minute as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.minute())

    def second(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract seconds from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the second number from 0 to 59.

        Returns
        -------
        Second as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.second())

    def nanosecond(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract seconds from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the number of nanoseconds since the whole non-leap second.
        The range from 1,000,000,000 to 1,999,999,999 represents the leap second.

        Returns
        -------
        Nanosecond as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.nanosecond())

    def round(self, rule: str, n: int) -&gt; Expr:
        &quot;&quot;&quot;
        Round the datetime.

        Parameters
        ----------
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr).map(lambda s: s.dt.round(rule, n), None)

    def to_python_datetime(self) -&gt; Expr:
        &quot;&quot;&quot;
        Go from Date/Datetime to python DateTime objects
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr).map(
            lambda s: s.dt.to_python_datetime(), return_dtype=Object
        )

    def timestamp(self) -&gt; Expr:
        &quot;&quot;&quot;Return timestamp in ms as Int64 type.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.timestamp())
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-4"><a class="header" href="#constructor-4">Constructor</a></h2>
<pre><code class="language-python">ExprDateTimeNameSpace(expr: Expr)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, expr: Expr):
        self._pyexpr = expr._pyexpr
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-4"><a class="header" href="#methods-4">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacebuckets"><a class="header" href="#polarsinternalsexprexprdatetimenamespacebuckets"><code>polars.internals.expr.ExprDateTimeNameSpace.buckets</code></a></h3>
<pre><code class="language-python">buckets(interval: timedelta) -&gt; Expr:
</code></pre>
<p>Divide the date/ datetime range into buckets.
Data will be sorted by this operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>interval</code>]: python timedelta to indicate bucket size</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Date/Datetime series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>from datetime import datetime, timedelta
import polars as pl
date_range = pl.date_range(
low=datetime(year=2000, month=10, day=1, hour=23, minute=30),
high=datetime(year=2000, month=10, day=2, hour=0, minute=30),
interval=timedelta(minutes=8),
name=&quot;date_range&quot;)</p>
<p>date_range.dt.buckets(timedelta(minutes=8))
shape: (8,)
Series: 'date_range' [datetime]
[
2000-10-01 23:30:00
2000-10-01 23:30:00
2000-10-01 23:38:00
2000-10-01 23:46:00
2000-10-01 23:54:00
2000-10-02 00:02:00
2000-10-02 00:10:00
2000-10-02 00:18:00
]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="can-be-used-to-perform-a-downsample-operation"><a class="header" href="#can-be-used-to-perform-a-downsample-operation">can be used to perform a downsample operation</a></h1>
<p>(date_range
.to_frame()
.groupby(
pl.col(&quot;date_range&quot;).dt.buckets(timedelta(minutes=16)),
maintain_order=True
)
.agg(pl.col(&quot;date_range&quot;).count())
)
shape: (4, 2)
┌─────────────────────┬──────────────────┐
│ date_range          ┆ date_range_count │
│ ---                 ┆ ---              │
│ datetime            ┆ u32              │
╞═════════════════════╪══════════════════╡
│ 2000-10-01 23:30:00 ┆ 3                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2000-10-01 23:46:00 ┆ 2                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2000-10-02 00:02:00 ┆ 2                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2000-10-02 00:18:00 ┆ 1                │
└─────────────────────┴──────────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def buckets(self, interval: timedelta) -&gt; Expr:
        &quot;&quot;&quot;
        Divide the date/ datetime range into buckets.
        Data will be sorted by this operation.

        Parameters
        ----------
        interval
            python timedelta to indicate bucket size

        Returns
        -------
        Date/Datetime series

        Examples
        --------
        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; import polars as pl
        &gt;&gt;&gt; date_range = pl.date_range(
        &gt;&gt;&gt; low=datetime(year=2000, month=10, day=1, hour=23, minute=30),
        &gt;&gt;&gt; high=datetime(year=2000, month=10, day=2, hour=0, minute=30),
        &gt;&gt;&gt; interval=timedelta(minutes=8),
        &gt;&gt;&gt; name=&quot;date_range&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; date_range.dt.buckets(timedelta(minutes=8))
        shape: (8,)
        Series: 'date_range' [datetime]
        [
            2000-10-01 23:30:00
            2000-10-01 23:30:00
            2000-10-01 23:38:00
            2000-10-01 23:46:00
            2000-10-01 23:54:00
            2000-10-02 00:02:00
            2000-10-02 00:10:00
            2000-10-02 00:18:00
        ]

        &gt;&gt;&gt; # can be used to perform a downsample operation
        &gt;&gt;&gt; (date_range
        &gt;&gt;&gt;  .to_frame()
        &gt;&gt;&gt;  .groupby(
        &gt;&gt;&gt;      pl.col(&quot;date_range&quot;).dt.buckets(timedelta(minutes=16)),
        &gt;&gt;&gt;      maintain_order=True
        &gt;&gt;&gt;  )
        &gt;&gt;&gt;  .agg(pl.col(&quot;date_range&quot;).count())
        &gt;&gt;&gt; )
        shape: (4, 2)
        ┌─────────────────────┬──────────────────┐
        │ date_range          ┆ date_range_count │
        │ ---                 ┆ ---              │
        │ datetime            ┆ u32              │
        ╞═════════════════════╪══════════════════╡
        │ 2000-10-01 23:30:00 ┆ 3                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-01 23:46:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:02:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:18:00 ┆ 1                │
        └─────────────────────┴──────────────────┘

        &quot;&quot;&quot;

        return wrap_expr(
            self._pyexpr.date_buckets(
                interval.days, interval.seconds, interval.microseconds
            )
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacestrftime"><a class="header" href="#polarsinternalsexprexprdatetimenamespacestrftime"><code>polars.internals.expr.ExprDateTimeNameSpace.strftime</code></a></h3>
<pre><code class="language-python">strftime(fmt: str) -&gt; Expr:
</code></pre>
<p>Format Date/datetime with a formatting rule: See <a href="https:/docs.rs/chrono/0.4.19/chrono/format/strftime/index.html">chrono strftime/strptime</a>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def strftime(self, fmt: str) -&gt; Expr:
        &quot;&quot;&quot;
        Format Date/datetime with a formatting rule: See [chrono strftime/strptime](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.strftime(fmt))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceyear"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceyear"><code>polars.internals.expr.ExprDateTimeNameSpace.year</code></a></h3>
<pre><code class="language-python">year() -&gt; Expr:
</code></pre>
<p>Extract year from underlying Date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the year number in the calendar date.</p>
<p><strong>Returns:</strong></p>
<p>Year as Int32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def year(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract year from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the year number in the calendar date.

        Returns
        -------
        Year as Int32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.year())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacemonth"><a class="header" href="#polarsinternalsexprexprdatetimenamespacemonth"><code>polars.internals.expr.ExprDateTimeNameSpace.month</code></a></h3>
<pre><code class="language-python">month() -&gt; Expr:
</code></pre>
<p>Extract month from underlying Date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the month number starting from 1.
The return value ranges from 1 to 12.</p>
<p><strong>Returns:</strong></p>
<p>Month as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def month(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract month from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the month number starting from 1.
        The return value ranges from 1 to 12.

        Returns
        -------
        Month as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.month())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceweek"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceweek"><code>polars.internals.expr.ExprDateTimeNameSpace.week</code></a></h3>
<pre><code class="language-python">week() -&gt; Expr:
</code></pre>
<p>Extract the week from the underlying Date representation.
Can be performed on Date and Datetime</p>
<p>Returns the ISO week number starting from 1.
The return value ranges from 1 to 53. (The last week of year differs by years.)</p>
<p><strong>Returns:</strong></p>
<p>Week number as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def week(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract the week from the underlying Date representation.
        Can be performed on Date and Datetime

        Returns the ISO week number starting from 1.
        The return value ranges from 1 to 53. (The last week of year differs by years.)

        Returns
        -------
        Week number as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.week())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceweekday"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceweekday"><code>polars.internals.expr.ExprDateTimeNameSpace.weekday</code></a></h3>
<pre><code class="language-python">weekday() -&gt; Expr:
</code></pre>
<p>Extract the week day from the underlying Date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the weekday number where monday = 0 and sunday = 6</p>
<p><strong>Returns:</strong></p>
<p>Week day as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def weekday(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract the week day from the underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the weekday number where monday = 0 and sunday = 6

        Returns
        -------
        Week day as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.weekday())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceday"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceday"><code>polars.internals.expr.ExprDateTimeNameSpace.day</code></a></h3>
<pre><code class="language-python">day() -&gt; Expr:
</code></pre>
<p>Extract day from underlying Date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the day of month starting from 1.
The return value ranges from 1 to 31. (The last day of month differs by months.)</p>
<p><strong>Returns:</strong></p>
<p>Day as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def day(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract day from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the day of month starting from 1.
        The return value ranges from 1 to 31. (The last day of month differs by months.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.day())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceordinal_day"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceordinal_day"><code>polars.internals.expr.ExprDateTimeNameSpace.ordinal_day</code></a></h3>
<pre><code class="language-python">ordinal_day() -&gt; Expr:
</code></pre>
<p>Extract ordinal day from underlying Date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the day of year starting from 1.
The return value ranges from 1 to 366. (The last day of year differs by years.)</p>
<p><strong>Returns:</strong></p>
<p>Day as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def ordinal_day(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract ordinal day from underlying Date representation.
        Can be performed on Date and Datetime.

        Returns the day of year starting from 1.
        The return value ranges from 1 to 366. (The last day of year differs by years.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.ordinal_day())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacehour"><a class="header" href="#polarsinternalsexprexprdatetimenamespacehour"><code>polars.internals.expr.ExprDateTimeNameSpace.hour</code></a></h3>
<pre><code class="language-python">hour() -&gt; Expr:
</code></pre>
<p>Extract hour from underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the hour number from 0 to 23.</p>
<p><strong>Returns:</strong></p>
<p>Hour as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hour(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract hour from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the hour number from 0 to 23.

        Returns
        -------
        Hour as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hour())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceminute"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceminute"><code>polars.internals.expr.ExprDateTimeNameSpace.minute</code></a></h3>
<pre><code class="language-python">minute() -&gt; Expr:
</code></pre>
<p>Extract minutes from underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the minute number from 0 to 59.</p>
<p><strong>Returns:</strong></p>
<p>Minute as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def minute(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract minutes from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the minute number from 0 to 59.

        Returns
        -------
        Minute as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.minute())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacesecond"><a class="header" href="#polarsinternalsexprexprdatetimenamespacesecond"><code>polars.internals.expr.ExprDateTimeNameSpace.second</code></a></h3>
<pre><code class="language-python">second() -&gt; Expr:
</code></pre>
<p>Extract seconds from underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the second number from 0 to 59.</p>
<p><strong>Returns:</strong></p>
<p>Second as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def second(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract seconds from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the second number from 0 to 59.

        Returns
        -------
        Second as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.second())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacenanosecond"><a class="header" href="#polarsinternalsexprexprdatetimenamespacenanosecond"><code>polars.internals.expr.ExprDateTimeNameSpace.nanosecond</code></a></h3>
<pre><code class="language-python">nanosecond() -&gt; Expr:
</code></pre>
<p>Extract seconds from underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the number of nanoseconds since the whole non-leap second.
The range from 1,000,000,000 to 1,999,999,999 represents the leap second.</p>
<p><strong>Returns:</strong></p>
<p>Nanosecond as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def nanosecond(self) -&gt; Expr:
        &quot;&quot;&quot;
        Extract seconds from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the number of nanoseconds since the whole non-leap second.
        The range from 1,000,000,000 to 1,999,999,999 represents the leap second.

        Returns
        -------
        Nanosecond as UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.nanosecond())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceround"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceround"><code>polars.internals.expr.ExprDateTimeNameSpace.round</code></a></h3>
<pre><code class="language-python">round(rule: str, n: int) -&gt; Expr:
</code></pre>
<p>Round the datetime.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>rule</code>]: Units of the downscaling operation.</p>
<p>Any of:
- &quot;month&quot;
- &quot;week&quot;
- &quot;day&quot;
- &quot;hour&quot;
- &quot;minute&quot;
- &quot;second&quot;</p>
</li>
<li>
<p>[<code>n</code>]: Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.</p>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, rule: str, n: int) -&gt; Expr:
        &quot;&quot;&quot;
        Round the datetime.

        Parameters
        ----------
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr).map(lambda s: s.dt.round(rule, n), None)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespaceto_python_datetime"><a class="header" href="#polarsinternalsexprexprdatetimenamespaceto_python_datetime"><code>polars.internals.expr.ExprDateTimeNameSpace.to_python_datetime</code></a></h3>
<pre><code class="language-python">to_python_datetime() -&gt; Expr:
</code></pre>
<p>Go from Date/Datetime to python DateTime objects</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_python_datetime(self) -&gt; Expr:
        &quot;&quot;&quot;
        Go from Date/Datetime to python DateTime objects
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr).map(
            lambda s: s.dt.to_python_datetime(), return_dtype=Object
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdatetimenamespacetimestamp"><a class="header" href="#polarsinternalsexprexprdatetimenamespacetimestamp"><code>polars.internals.expr.ExprDateTimeNameSpace.timestamp</code></a></h3>
<pre><code class="language-python">timestamp() -&gt; Expr:
</code></pre>
<p>Return timestamp in ms as Int64 type.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def timestamp(self) -&gt; Expr:
        &quot;&quot;&quot;Return timestamp in ms as Int64 type.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.timestamp())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalsframe"><a class="header" href="#module-polarsinternalsframe">Module <code>polars.internals.frame</code></a></h1>
<p>&quot;
Module containing logic related to eager DataFrames</p>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/internals/frame.html#polarsinternalsframewrap_df"><code>wrap_df()</code></a>: </li>
</ul>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframewrap_df"><a class="header" href="#polarsinternalsframewrap_df"><code>polars.internals.frame.wrap_df</code></a></h3>
<pre><code class="language-python">wrap_df(df: PyDataFrame) -&gt; DataFrame:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def wrap_df(df: &quot;PyDataFrame&quot;) -&gt; &quot;DataFrame&quot;:
    return DataFrame._from_pydf(df)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsframedataframe"><a class="header" href="#polarsinternalsframedataframe"><code>polars.internals.frame.DataFrame</code></a></h1>
<p>A DataFrame is a two-dimensional data structure that represents data as a table
with rows and columns.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> [<code>dict, Sequence, ndarray, Series, or pandas.DataFrame</code>]: Two-dimensional data in various forms. dict must contain Sequences.
Sequence may contain Series or other Sequences.</li>
<li><code>columns</code> [<code>Sequence of str, default None</code>]: Column labels to use for resulting DataFrame. If specified, overrides any
labels already present in the data. Must match data dimensions.
orient : {'col', 'row'}, default None
Whether to interpret two-dimensional data as columns or as rows. If None,
the orientation is inferred by matching the columns and data dimensions. If
this does not yield conclusive results, column orientation is used.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Constructing a DataFrame from a dictionary:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = {'a': [1, 2], 'b': [3, 4]}
df = pl.DataFrame(data)
df
shape: (2, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 4   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice that the dtype is automatically inferred as a polars Int64:</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.dtypes
[&lt;class 'polars.datatypes.Int64'&gt;, &lt;class 'polars.datatypes.Int64'&gt;]</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to specify dtypes for your columns, initialize the DataFrame with a list
of Series instead:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [pl.Series('col1', [1, 2], dtype=pl.Float32),
...         pl.Series('col2', [3, 4], dtype=pl.Int64)]
df2 = pl.DataFrame(series)
df2
shape: (2, 2)
╭──────┬──────╮
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ 1    ┆ 3    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ 4    │
╰──────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a DataFrame from a numpy ndarray, specifying column names:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = np.array([(1, 2), (3, 4)])
df3 = pl.DataFrame(data, columns=['a', 'b'], orient='col')
df3
shape: (2, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 4   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a DataFrame from a list of lists, row orientation inferred:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [[1, 2, 3], [4, 5, 6]]
df4 = pl.DataFrame(data, columns=['a', 'b', 'c'])
df4
shape: (2, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 5   ┆ 6   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeread_csv"><code>read_csv()</code></a>: Read a CSV file into a Dataframe.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeread_parquet"><code>read_parquet()</code></a>: Read into a DataFrame from a parquet file.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeread_ipc"><code>read_ipc()</code></a>: Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeread_json"><code>read_json()</code></a>: Read into a DataFrame from JSON format.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_arrow"><code>to_arrow()</code></a>: Collect the underlying arrow arrays in an Arrow Table.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_dict"><code>to_dict()</code></a>: Convert DataFrame to a dictionary mapping column name to values.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_json"><code>to_json()</code></a>: Serialize to JSON representation.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_pandas"><code>to_pandas()</code></a>: Cast to a Pandas DataFrame. This requires that Pandas is installed.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_csv"><code>to_csv()</code></a>: Write Dataframe to comma-separated values file (csv).</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_ipc"><code>to_ipc()</code></a>: Write to Arrow IPC binary stream, or a feather file.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_dicts"><code>to_dicts()</code></a>: </li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframetranspose"><code>transpose()</code></a>: Transpose a DataFrame over the diagonal.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_parquet"><code>to_parquet()</code></a>: Write the DataFrame disk in parquet format.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_numpy"><code>to_numpy()</code></a>: Convert DataFrame to a 2d numpy array.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframefind_idx_by_name"><code>find_idx_by_name()</code></a>: Find the index of a column by name.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_series"><code>to_series()</code></a>: Select column as Series at index location.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframerename"><code>rename()</code></a>: Rename column names.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeinsert_at_idx"><code>insert_at_idx()</code></a>: Insert a Series at a certain column index. This operation is in place.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframefilter"><code>filter()</code></a>: Filter the rows in the DataFrame based on a predicate expression.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeshape"><code>shape()</code></a>: Get the shape of the DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeheight"><code>height()</code></a>: Get the height of the DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframewidth"><code>width()</code></a>: Get the width of the DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframecolumns"><code>columns()</code></a>: Change the column names of the <code>DataFrame</code>.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedtypes"><code>dtypes()</code></a>: Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedescribe"><code>describe()</code></a>: Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedescribedescribe_cast"><code>describe_cast()</code></a>: </li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframereplace_at_idx"><code>replace_at_idx()</code></a>: Replace a column at an index location.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframesort"><code>sort()</code></a>: Sort the DataFrame by column.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeframe_equal"><code>frame_equal()</code></a>: Check if DataFrame is equal to other.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframereplace"><code>replace()</code></a>: Replace a column by a new Series.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeslice"><code>slice()</code></a>: Slice this DataFrame over the rows direction.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframelimit"><code>limit()</code></a>: Get first N rows as DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframehead"><code>head()</code></a>: Get first N rows as DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframetail"><code>tail()</code></a>: Get last N rows as DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedrop_nulls"><code>drop_nulls()</code></a>: Return a new DataFrame where the null values are dropped.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframepipe"><code>pipe()</code></a>: Apply a function on Self.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframewith_row_count"><code>with_row_count()</code></a>: Add a column at index 0 that counts the rows.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframegroupby"><code>groupby()</code></a>: Start a groupby operation.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedownsample"><code>downsample()</code></a>: Start a downsampling groupby operation.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeupsample"><code>upsample()</code></a>: Upsample a DataFrame at a regular frequency.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframejoin"><code>join()</code></a>: SQL like joins.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeapply"><code>apply()</code></a>: Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframewith_column"><code>with_column()</code></a>: Return a new DataFrame with the column added or replaced.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframewith_column_renamed"><code>with_column_renamed()</code></a>: Return a new DataFrame with the column renamed.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframehstack"><code>hstack()</code></a>: Return a new DataFrame grown horizontally by stacking multiple Series to it.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframevstack"><code>vstack()</code></a>: Grow this DataFrame vertically by stacking a DataFrame to it.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedrop"><code>drop()</code></a>: Remove column from DataFrame and return as new.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedrop_in_place"><code>drop_in_place()</code></a>: Drop in place.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeselect_at_idx"><code>select_at_idx()</code></a>: Select column at index location.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeclone"><code>clone()</code></a>: Very cheap deep clone.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeget_columns"><code>get_columns()</code></a>: Get the DataFrame as a List of Series.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeget_column"><code>get_column()</code></a>: Get a single column as Series by name.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframefill_null"><code>fill_null()</code></a>: Fill None/missing values by a filling strategy or an Expression evaluation.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframefill_nan"><code>fill_nan()</code></a>: Fill None/missing values by a an Expression evaluation.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeexplode"><code>explode()</code></a>: Explode <code>DataFrame</code> to long format by exploding a column with Lists.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframemelt"><code>melt()</code></a>: Unpivot DataFrame to long format.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeis_duplicated"><code>is_duplicated()</code></a>: Get a mask of all duplicated rows in this DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeis_unique"><code>is_unique()</code></a>: Get a mask of all unique rows in this DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframelazy"><code>lazy()</code></a>: Start a lazy query from this point. This returns a <code>LazyFrame</code> object.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeselect"><code>select()</code></a>: Select columns from this DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframewith_columns"><code>with_columns()</code></a>: Add or overwrite multiple columns in a DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframen_chunks"><code>n_chunks()</code></a>: Get number of chunks used by the ChunkedArrays of this DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframemax"><code>max()</code></a>: Aggregate the columns of this DataFrame to their maximum value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframemin"><code>min()</code></a>: Aggregate the columns of this DataFrame to their minimum value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframesum"><code>sum()</code></a>: Aggregate the columns of this DataFrame to their sum value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframemean"><code>mean()</code></a>: Aggregate the columns of this DataFrame to their mean value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframestd"><code>std()</code></a>: Aggregate the columns of this DataFrame to their standard deviation value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframevar"><code>var()</code></a>: Aggregate the columns of this DataFrame to their variance value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframemedian"><code>median()</code></a>: Aggregate the columns of this DataFrame to their median value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframequantile"><code>quantile()</code></a>: Aggregate the columns of this DataFrame to their quantile value.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeto_dummies"><code>to_dummies()</code></a>: Get one hot encoded dummy variables.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframedrop_duplicates"><code>drop_duplicates()</code></a>: Drop duplicate rows from this DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframerechunk"><code>rechunk()</code></a>: Rechunk the data in this DataFrame to a contiguous allocation.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframenull_count"><code>null_count()</code></a>: Create a new DataFrame that shows the null counts per column.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframesample"><code>sample()</code></a>: Sample from this DataFrame by setting either <code>n</code> or <code>frac</code>.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframefold"><code>fold()</code></a>: Apply a horizontal reduction on a DataFrame. This can be used to effectively</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframerow"><code>row()</code></a>: Get a row as tuple.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframerows"><code>rows()</code></a>: Convert columnar data to rows as python tuples.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeshrink_to_fit"><code>shrink_to_fit()</code></a>: Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframehash_rows"><code>hash_rows()</code></a>: Hash and combine the rows in this DataFrame.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
<li><a href="polars/internals/frame/DataFrame.html#polarsinternalsframedataframeis_empty"><code>is_empty()</code></a>: Check if the dataframe is empty</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class DataFrame:
    &quot;&quot;&quot;
    A DataFrame is a two-dimensional data structure that represents data as a table
    with rows and columns.

    Parameters
    ----------
    data : dict, Sequence, ndarray, Series, or pandas.DataFrame
        Two-dimensional data in various forms. dict must contain Sequences.
        Sequence may contain Series or other Sequences.
    columns : Sequence of str, default None
        Column labels to use for resulting DataFrame. If specified, overrides any
        labels already present in the data. Must match data dimensions.
    orient : {'col', 'row'}, default None
        Whether to interpret two-dimensional data as columns or as rows. If None,
        the orientation is inferred by matching the columns and data dimensions. If
        this does not yield conclusive results, column orientation is used.

    Examples
    --------
    Constructing a DataFrame from a dictionary:

    &gt;&gt;&gt; data = {'a': [1, 2], 'b': [3, 4]}
    &gt;&gt;&gt; df = pl.DataFrame(data)
    &gt;&gt;&gt; df
    shape: (2, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 4   │
    ╰─────┴─────╯

    Notice that the dtype is automatically inferred as a polars Int64:

    &gt;&gt;&gt; df.dtypes
    [&lt;class 'polars.datatypes.Int64'&gt;, &lt;class 'polars.datatypes.Int64'&gt;]

    In order to specify dtypes for your columns, initialize the DataFrame with a list
    of Series instead:

    &gt;&gt;&gt; data = [pl.Series('col1', [1, 2], dtype=pl.Float32),
    ...         pl.Series('col2', [3, 4], dtype=pl.Int64)]
    &gt;&gt;&gt; df2 = pl.DataFrame(series)
    &gt;&gt;&gt; df2
    shape: (2, 2)
    ╭──────┬──────╮
    │ col1 ┆ col2 │
    │ ---  ┆ ---  │
    │ f32  ┆ i64  │
    ╞══════╪══════╡
    │ 1    ┆ 3    │
    ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
    │ 2    ┆ 4    │
    ╰──────┴──────╯

    Constructing a DataFrame from a numpy ndarray, specifying column names:

    &gt;&gt;&gt; data = np.array([(1, 2), (3, 4)])
    &gt;&gt;&gt; df3 = pl.DataFrame(data, columns=['a', 'b'], orient='col')
    &gt;&gt;&gt; df3
    shape: (2, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 4   │
    ╰─────┴─────╯

    Constructing a DataFrame from a list of lists, row orientation inferred:

    &gt;&gt;&gt; data = [[1, 2, 3], [4, 5, 6]]
    &gt;&gt;&gt; df4 = pl.DataFrame(data, columns=['a', 'b', 'c'])
    &gt;&gt;&gt; df4
    shape: (2, 3)
    ╭─────┬─────┬─────╮
    │ a   ┆ b   ┆ c   │
    │ --- ┆ --- ┆ --- │
    │ i64 ┆ i64 ┆ i64 │
    ╞═════╪═════╪═════╡
    │ 1   ┆ 2   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
    │ 4   ┆ 5   ┆ 6   │
    ╰─────┴─────┴─────╯
    &quot;&quot;&quot;

    def __init__(
        self,
        data: Optional[
            Union[
                Dict[str, Sequence[Any]],
                Sequence[Any],
                np.ndarray,
                &quot;pa.Table&quot;,
                &quot;pd.DataFrame&quot;,
                &quot;pli.Series&quot;,
            ]
        ] = None,
        columns: Optional[Sequence[str]] = None,
        orient: Optional[str] = None,
    ):
        if data is None:
            self._df = dict_to_pydf({}, columns=columns)

        elif isinstance(data, dict):
            self._df = dict_to_pydf(data, columns=columns)

        elif isinstance(data, np.ndarray):
            self._df = numpy_to_pydf(data, columns=columns, orient=orient)

        elif _PYARROW_AVAILABLE and isinstance(data, pa.Table):
            self._df = arrow_to_pydf(data, columns=columns)

        elif isinstance(data, Sequence) and not isinstance(data, str):
            self._df = sequence_to_pydf(data, columns=columns, orient=orient)

        elif isinstance(data, pli.Series):
            self._df = series_to_pydf(data, columns=columns)

        elif _PANDAS_AVAILABLE and isinstance(data, pd.DataFrame):
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required for converting a pandas DataFrame to a polars DataFrame.&quot;
                )
            self._df = pandas_to_pydf(data, columns=columns)

        else:
            raise ValueError(&quot;DataFrame constructor not called properly.&quot;)

    @classmethod
    def _from_pydf(cls, py_df: &quot;PyDataFrame&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct Polars DataFrame from FFI PyDataFrame object.
        &quot;&quot;&quot;
        df = cls.__new__(cls)
        df._df = py_df
        return df

    @classmethod
    def _from_dicts(cls, data: Sequence[Dict[str, Any]]) -&gt; &quot;DataFrame&quot;:
        pydf = PyDataFrame.read_dicts(data)
        return DataFrame._from_pydf(pydf)

    @classmethod
    def _from_dict(
        cls,
        data: Dict[str, Sequence[Any]],
        columns: Optional[Sequence[str]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a DataFrame from a dictionary of sequences.

        Parameters
        ----------
        data : dict of sequences
            Two-dimensional data represented as a dictionary. dict must contain
            Sequences.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. If specified, overrides any
            labels already present in the data. Must match data dimensions.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return cls._from_pydf(dict_to_pydf(data, columns=columns))

    @classmethod
    def _from_records(
        cls,
        data: Union[np.ndarray, Sequence[Sequence[Any]]],
        columns: Optional[Sequence[str]] = None,
        orient: Optional[str] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a DataFrame from a numpy ndarray or sequence of sequences.

        Parameters
        ----------
        data : numpy ndarray or Sequence of sequences
            Two-dimensional data represented as numpy ndarray or sequence of sequences.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. Must match data dimensions.
            If not specified, columns will be named `column_0`, `column_1`, etc.
        orient : {'col', 'row'}, default None
            Whether to interpret two-dimensional data as columns or as rows. If None,
            the orientation is inferred by matching the columns and data dimensions. If
            this does not yield conclusive results, column orientation is used.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        if isinstance(data, np.ndarray):
            pydf = numpy_to_pydf(data, columns=columns, orient=orient)
        else:
            pydf = sequence_to_pydf(data, columns=columns, orient=orient)
        return cls._from_pydf(pydf)

    @classmethod
    def _from_arrow(
        cls,
        data: &quot;pa.Table&quot;,
        columns: Optional[Sequence[str]] = None,
        rechunk: bool = True,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a DataFrame from an Arrow table.

        This operation will be zero copy for the most part. Types that are not
        supported by Polars may be cast to the closest supported type.

        Parameters
        ----------
        data : numpy ndarray or Sequence of sequences
            Two-dimensional data represented as Arrow table.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. Must match data dimensions.
            If not specified, existing Array table columns are used, with missing names
            named as `column_0`, `column_1`, etc.
        rechunk : bool, default True
            Make sure that all data is contiguous.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return cls._from_pydf(arrow_to_pydf(data, columns=columns, rechunk=rechunk))

    @classmethod
    def _from_pandas(
        cls,
        data: &quot;pd.DataFrame&quot;,
        columns: Optional[Sequence[str]] = None,
        rechunk: bool = True,
        nan_to_none: bool = True,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a Polars DataFrame from a pandas DataFrame.

        Parameters
        ----------
        data : pandas DataFrame
            Two-dimensional data represented as a pandas DataFrame.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. If specified, overrides any
            labels already present in the data. Must match data dimensions.
        rechunk : bool, default True
            Make sure that all data is contiguous.
        nan_to_none : bool, default True
            If data contains NaN values PyArrow will convert the NaN to None

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return cls._from_pydf(
            pandas_to_pydf(
                data, columns=columns, rechunk=rechunk, nan_to_none=nan_to_none
            )
        )

    @staticmethod
    def read_csv(
        file: Union[str, BinaryIO, bytes],
        infer_schema_length: Optional[int] = 100,
        batch_size: int = 64,
        has_headers: bool = True,
        ignore_errors: bool = False,
        stop_after_n_rows: Optional[int] = None,
        skip_rows: int = 0,
        projection: Optional[tp.List[int]] = None,
        sep: str = &quot;,&quot;,
        columns: Optional[tp.List[str]] = None,
        rechunk: bool = True,
        encoding: str = &quot;utf8&quot;,
        n_threads: Optional[int] = None,
        dtype: Union[Dict[str, Type[DataType]], tp.List[Type[DataType]], None] = None,
        low_memory: bool = False,
        comment_char: Optional[str] = None,
        quote_char: Optional[str] = r'&quot;',
        null_values: Optional[Union[str, tp.List[str], Dict[str, str]]] = None,
        parse_dates: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read a CSV file into a Dataframe.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used. Example: `file.csv`.
        infer_schema_length
            Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
            If set to `None`, a full table scan will be done (slow).
        batch_size
            Number of lines to read into the buffer at once. Modify this to change performance.
        has_headers
            Indicate if first row of dataset is header or not. If set to False first row will be set to `column_x`,
            `x` being an enumeration over every column in the dataset.
        ignore_errors
            Try to keep reading lines if some lines yield errors.
        stop_after_n_rows
            After n rows are read from the CSV, it stops reading.
            During multi-threaded parsing, an upper bound of `n` rows
            cannot be guaranteed.
        skip_rows
            Start reading after `skip_rows`.
        projection
            Indices of columns to select. Note that column indices start at zero.
        sep
            Character to use as delimiter in the file.
        columns
            Columns to select.
        rechunk
            Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.
        encoding
            Allowed encodings: `utf8`, `utf8-lossy`. Lossy means that invalid utf8 values are replaced with `�` character.
        n_threads
            Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.
        dtype
            Overwrite the dtypes during inference.
        low_memory
            Reduce memory usage in expense of performance.
        comment_char
            character that indicates the start of a comment line, for instance '#'.
        quote_char
            single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
            of quotes off.
        null_values
            Values to interpret as null values. You can provide a:

            - str -&gt; all values encountered equal to this string will be null
            - tp.List[str] -&gt; A null value per column.
            - Dict[str, str] -&gt; A dictionary that maps column name to a null value string.
        parse_dates
            Whether to attempt to parse dates or not

        Returns
        -------
        DataFrame

        Examples
        --------

        &gt;&gt;&gt; df = pl.read_csv('file.csv', sep=';', stop_after_n_rows=25)

        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)

        path: Optional[str]
        if isinstance(file, str):
            path = file
        else:
            path = None
            if isinstance(file, BytesIO):
                file = file.getvalue()
            if isinstance(file, StringIO):
                file = file.getvalue().encode()

        dtype_list: Optional[tp.List[Tuple[str, Type[DataType]]]] = None
        dtype_slice: Optional[tp.List[Type[DataType]]] = None
        if dtype is not None:
            if isinstance(dtype, dict):
                dtype_list = []
                for k, v in dtype.items():
                    dtype_list.append((k, py_type_to_dtype(v)))
            elif isinstance(dtype, list):
                dtype_slice = dtype
            else:
                raise ValueError(&quot;dtype arg should be list or dict&quot;)

        processed_null_values = _process_null_values(null_values)

        self._df = PyDataFrame.read_csv(
            file,
            infer_schema_length,
            batch_size,
            has_headers,
            ignore_errors,
            stop_after_n_rows,
            skip_rows,
            projection,
            sep,
            rechunk,
            columns,
            encoding,
            n_threads,
            path,
            dtype_list,
            dtype_slice,
            low_memory,
            comment_char,
            quote_char,
            processed_null_values,
            parse_dates,
        )
        return self

    @staticmethod
    def read_parquet(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from a parquet file.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_parquet(
            file, columns, projection, stop_after_n_rows
        )
        return self

    @staticmethod
    def read_ipc(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_ipc(file, columns, projection, stop_after_n_rows)
        return self

    @staticmethod
    def read_json(file: Union[str, BytesIO]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from JSON format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        &quot;&quot;&quot;
        if not isinstance(file, str):
            file = file.read().decode(&quot;utf8&quot;)
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_json(file)
        return self

    def to_arrow(self) -&gt; &quot;pa.Table&quot;:
        &quot;&quot;&quot;
        Collect the underlying arrow arrays in an Arrow Table.
        This operation is mostly zero copy.

        Data types that do copy:
            - CategoricalType
        &quot;&quot;&quot;
        if not _PYARROW_AVAILABLE:
            raise ImportError(
                &quot;'pyarrow' is required for converting a polars DataFrame to an Arrow Table.&quot;
            )
        record_batches = self._df.to_arrow()
        return pa.Table.from_batches(record_batches)

    def to_dict(
        self, as_series: bool = True
    ) -&gt; Union[Dict[str, &quot;pli.Series&quot;], Dict[str, tp.List[Any]]]:
        &quot;&quot;&quot;
        Convert DataFrame to a dictionary mapping column name to values.

        Parameters
        ----------
        as_series
            True -&gt; Values are series
            False -&gt; Values are List[Any]

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;      &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;      &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;      &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;      &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt;      &quot;optional&quot;: [28, 300, None, 2, -30],
        &gt;&gt;&gt; })
        shape: (5, 5)
        ┌─────┬──────────┬─────┬──────────┬──────────┐
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ optional │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64      │
        ╞═════╪══════════╪═════╪══════════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 28       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 300      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ null     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ -30      │
        └─────┴──────────┴─────┴──────────┴──────────┘
        &gt;&gt;&gt; df.to_dict(as_series=False)
        {'A': [1, 2, 3, 4, 5],
        'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'],
        'B': [5, 4, 3, 2, 1],
        'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'],
        'optional': [28, 300, None, 2, -30]}
        &gt;&gt;&gt; df.to_dict(as_series=True)
        {'A': shape: (5,)
         Series: 'A' [i64]
         [
            1
            2
            3
            4
            5
         ],
         'fruits': shape: (5,)
         ...
         Series: 'optional' [i64]
         [
            28
            300
            null
            2
            -30
         ]}

        &quot;&quot;&quot;
        if as_series:
            return {s.name: s for s in self}
        else:
            return {s.name: s.to_list() for s in self}

    def to_json(
        self,
        file: Optional[Union[BytesIO, str, Path]] = None,
        pretty: bool = False,
        to_string: bool = False,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Serialize to JSON representation.

        Parameters
        ----------
        file
            Write to this file instead of returning an string.
        pretty
            Pretty serialize json.
        to_string
            Ignore file argument and return a string.
        &quot;&quot;&quot;
        if to_string or file is None:
            file = BytesIO()
            self._df.to_json(file, pretty)
            file.seek(0)
            return file.read().decode(&quot;utf8&quot;)
        else:
            self._df.to_json(file, pretty)
            return None

    def to_pandas(
        self, *args: Any, date_as_object: bool = False, **kwargs: Any
    ) -&gt; &quot;pd.DataFrame&quot;:  # noqa: F821
        &quot;&quot;&quot;
        Cast to a Pandas DataFrame. This requires that Pandas is installed.
        This operation clones data.

        Parameters
        ----------
        args
            Arguments will be sent to pyarrow.Table.to_pandas.
        date_as_object
            Cast dates to objects. If False, convert to datetime64[ns] dtype.
        kwargs
            Arguments will be sent to pyarrow.Table.to_pandas.

        Examples
        --------

        &gt;&gt;&gt; import pandas
        &gt;&gt;&gt; df = pl.DataFrame({
            &quot;foo&quot;: [1, 2, 3],
            &quot;bar&quot;: [6, 7, 8],
            &quot;ham&quot;: ['a', 'b', 'c']
            })
        &gt;&gt;&gt; pandas_df = df.to_pandas()
        &gt;&gt;&gt; type(pandas_df)
        pandas.core.frame.DataFrame
        &quot;&quot;&quot;
        return self.to_arrow().to_pandas(*args, date_as_object=date_as_object, **kwargs)

    def to_csv(
        self,
        file: Optional[Union[TextIO, BytesIO, str, Path]] = None,
        has_headers: bool = True,
        sep: str = &quot;,&quot;,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Write Dataframe to comma-separated values file (csv).

        Parameters
        ---
        file
            File path to which the file should be written.
        has_headers
            Whether or not to include header in the CSV output.
        sep
            Separate CSV fields with this symbol.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_csv('new_file.csv', sep=',')

        &quot;&quot;&quot;
        if file is None:
            buffer = BytesIO()
            self._df.to_csv(buffer, has_headers, ord(sep))
            return str(buffer.getvalue(), encoding=&quot;utf-8&quot;)

        if isinstance(file, Path):
            file = str(file)

        self._df.to_csv(file, has_headers, ord(sep))
        return None

    def to_ipc(
        self,
        file: Union[BinaryIO, BytesIO, str, Path],
        compression: str = &quot;uncompressed&quot;,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write to Arrow IPC binary stream, or a feather file.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        &quot;&quot;&quot;
        if isinstance(file, Path):
            file = str(file)

        self._df.to_ipc(file, compression)

    def to_dicts(self) -&gt; tp.List[Dict[str, Any]]:
        pydf = self._df
        names = self.columns

        return [
            {k: v for k, v in zip(names, pydf.row_tuple(i))}
            for i in range(0, self.height)
        ]

    def transpose(
        self,
        include_header: bool = False,
        header_name: str = &quot;column&quot;,
        column_names: Optional[Union[tp.Iterator[str], tp.Sequence[str]]] = None,
    ) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Transpose a DataFrame over the diagonal.

        Parameters
        ----------
        include_header:
            If set, the column names will be added as first column.
        header_name:
            If `include_header` is set, this determines the name of the column that will be inserted
        column_names:
            Optional generator/iterator that yields column names. Will be used to replace the columns in the DataFrame.

        Notes
        -----
        This is a very expensive operation. Perhaps you can do it differently.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [1, 2, 3]})
        &gt;&gt;&gt; df.transpose(include_header=True)
        shape: (2, 4)
        ┌────────┬──────────┬──────────┬──────────┐
        │ column ┆ column_0 ┆ column_1 ┆ column_2 │
        │ ---    ┆ ---      ┆ ---      ┆ ---      │
        │ str    ┆ i64      ┆ i64      ┆ i64      │
        ╞════════╪══════════╪══════════╪══════════╡
        │ a      ┆ 1        ┆ 2        ┆ 3        │
        ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ b      ┆ 1        ┆ 2        ┆ 3        │
        └────────┴──────────┴──────────┴──────────┘

        # replace the auto generated column names with a list
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt; # include the header as a separate column
        &gt;&gt;&gt; df.transpose(include_header=True, header_name=&quot;foo&quot;, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 4)
        ┌─────┬─────┬─────┬─────┐
        │ foo ┆ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╪═════╡
        │ a   ┆ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┴─────┘

        &gt;&gt;&gt; # replace the auto generated column with column names from a generator function
        &gt;&gt;&gt; def name_generator():
        &gt;&gt;&gt;     base_name = &quot;my_column_&quot;
        &gt;&gt;&gt;     count = 0
        &gt;&gt;&gt;     while True:
        &gt;&gt;&gt;         yield f&quot;{base_name}{count}&quot;
        &gt;&gt;&gt;         count += 1
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=name_generator())
        shape: (2, 3)
        ┌─────────────┬─────────────┬─────────────┐
        │ my_column_0 ┆ my_column_1 ┆ my_column_2 │
        │ ---         ┆ ---         ┆ ---         │
        │ i64         ┆ i64         ┆ i64         │
        ╞═════════════╪═════════════╪═════════════╡
        │ 1           ┆ 2           ┆ 3           │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 1           ┆ 2           ┆ 3           │
        └─────────────┴─────────────┴─────────────┘

        &quot;&quot;&quot;
        df = wrap_df(self._df.transpose(include_header, header_name))
        if column_names is not None:
            names = []
            n = df.width
            if include_header:
                names.append(header_name)
                n -= 1

            column_names = iter(column_names)
            for _ in range(n):
                names.append(next(column_names))
            df.columns = names
        return df

    def to_parquet(
        self,
        file: Union[str, Path, BytesIO],
        compression: Optional[str] = &quot;snappy&quot;,
        use_pyarrow: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write the DataFrame disk in parquet format.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot; (not supported by pyarrow)
                - &quot;snappy&quot;
                - &quot;gzip&quot;
                - &quot;lzo&quot;
                - &quot;brotli&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        use_pyarrow
            Use C++ parquet implementation vs rust parquet implementation.
            At the moment C++ supports more features.

        **kwargs are passed to pyarrow.parquet.write_table
        &quot;&quot;&quot;
        if compression is None:
            compression = &quot;uncompressed&quot;
        if isinstance(file, Path):
            file = str(file)

        if use_pyarrow:
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required when using 'to_parquet(..., use_pyarrow=True)'.&quot;
                )

            tbl = self.to_arrow()

            data = {}

            for i, column in enumerate(tbl):
                # extract the name before casting
                if column._name is None:
                    name = f&quot;column_{i}&quot;
                else:
                    name = column._name

                data[name] = column
            tbl = pa.table(data)

            pa.parquet.write_table(
                table=tbl, where=file, compression=compression, **kwargs
            )
        else:
            self._df.to_parquet(file, compression)

    def to_numpy(self) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert DataFrame to a 2d numpy array.
        This operation clones data.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; numpy_array = df.to_numpy()
        &gt;&gt;&gt; type(numpy_array)
        numpy.ndarray

        &quot;&quot;&quot;
        return np.vstack([self.to_series(i).to_numpy() for i in range(self.width)]).T

    def __getstate__(self):  # type: ignore
        return self.get_columns()

    def __setstate__(self, state):  # type: ignore
        self._df = DataFrame(state)._df

    def __mul__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.mul(other._s))

    def __truediv__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.div(other._s))

    def __add__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.add(other._s))

    def __sub__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.sub(other._s))

    def __str__(self) -&gt; str:
        return self._df.as_str()

    def __repr__(self) -&gt; str:
        return self.__str__()

    def __getattr__(self, item: Any) -&gt; &quot;PySeries&quot;:
        &quot;&quot;&quot;
        Access columns as attribute.
        &quot;&quot;&quot;
        try:
            return pli.wrap_s(self._df.column(item))
        except RuntimeError:
            raise AttributeError(f&quot;{item} not found&quot;)

    def __iter__(self) -&gt; Iterator[Any]:
        return self.get_columns().__iter__()

    def find_idx_by_name(self, name: str) -&gt; int:
        &quot;&quot;&quot;
        Find the index of a column by name.

        Parameters
        ----------
        name
            Name of the column to find.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.find_idx_by_name(&quot;ham&quot;))
        2

        &quot;&quot;&quot;
        return self._df.find_idx_by_name(name)

    def _pos_idx(self, idx: int, dim: int) -&gt; int:
        if idx &gt;= 0:
            return idx
        else:
            return self.shape[dim] + idx

    def __getitem__(self, item: Any) -&gt; Any:
        &quot;&quot;&quot;
        Does quite a lot. Read the comments.
        &quot;&quot;&quot;
        if hasattr(item, &quot;_pyexpr&quot;):
            return self.select(item)
        if isinstance(item, np.ndarray):
            item = pli.Series(&quot;&quot;, item)
        # select rows and columns at once
        # every 2d selection, i.e. tuple is row column order, just like numpy
        if isinstance(item, tuple):
            row_selection, col_selection = item

            # df[:, unknown]
            if isinstance(row_selection, slice):

                # multiple slices
                # df[:, :]
                if isinstance(col_selection, slice):
                    # slice can be
                    # by index
                    #   [1:8]
                    # or by column name
                    #   [&quot;foo&quot;:&quot;bar&quot;]
                    # first we make sure that the slice is by index
                    start = col_selection.start
                    stop = col_selection.stop
                    if isinstance(col_selection.start, str):
                        start = self.find_idx_by_name(col_selection.start)
                    if isinstance(col_selection.stop, str):
                        stop = self.find_idx_by_name(col_selection.stop) + 1

                    col_selection = slice(start, stop, col_selection.step)

                    df = self.__getitem__(self.columns[col_selection])
                    return df[row_selection]

                # slice and boolean mask
                # df[:2, [True, False, True]]
                if isinstance(col_selection, (Sequence, pli.Series)):
                    if (
                        isinstance(col_selection[0], bool)
                        or isinstance(col_selection, pli.Series)
                        and col_selection.dtype() == Boolean
                    ):
                        df = self.__getitem__(row_selection)
                        select = []
                        for col, valid in zip(df.columns, col_selection):
                            if valid:
                                select.append(col)
                        return df.select(select)

                # single slice
                # df[:, unknown]
                series = self.__getitem__(col_selection)
                # s[:]
                pli.wrap_s(series[row_selection])

            # df[2, :] (select row as df)
            if isinstance(row_selection, int):
                if isinstance(col_selection, (slice, list, np.ndarray)):
                    df = self[:, col_selection]
                    return df.slice(row_selection, 1)
                # df[2, &quot;a&quot;]
                if isinstance(col_selection, str):
                    return self[col_selection][row_selection]

            # column selection can be &quot;a&quot; and [&quot;a&quot;, &quot;b&quot;]
            if isinstance(col_selection, str):
                col_selection = [col_selection]

            # df[:, 1]
            if isinstance(col_selection, int):
                series = self.to_series(col_selection)
                return series[row_selection]

            if isinstance(col_selection, list):
                # df[:, [1, 2]]
                # select by column indexes
                if isinstance(col_selection[0], int):
                    series = [self.to_series(i) for i in col_selection]
                    df = DataFrame(series)
                    return df[row_selection]
            df = self.__getitem__(col_selection)
            return df.__getitem__(row_selection)

        # select single column
        # df[&quot;foo&quot;]
        if isinstance(item, str):
            return pli.wrap_s(self._df.column(item))

        # df[idx]
        if isinstance(item, int):
            return self.slice(self._pos_idx(item, dim=0), 1)

        # df[range(n)]
        if isinstance(item, range):
            step: Optional[int]
            # maybe we can slice instead of take by indices
            if item.step != 1:
                step = item.step
            else:
                step = None
            slc = slice(item.start, item.stop, step)
            return self[slc]

        # df[:]
        if isinstance(item, slice):
            # special case df[::-1]
            if item.start is None and item.stop is None and item.step == -1:
                return self.select(pli.col(&quot;*&quot;).reverse())  # type: ignore

            if getattr(item, &quot;end&quot;, False):
                raise ValueError(&quot;A slice with steps larger than 1 is not supported.&quot;)
            if item.start is None:
                start = 0
            else:
                start = item.start
            if item.stop is None:
                stop = self.height
            else:
                stop = item.stop

            length = stop - start
            if item.step is None:
                # df[start:stop]
                return self.slice(start, length)
            else:
                # df[start:stop:step]
                return self.select(
                    pli.col(&quot;*&quot;).slice(start, length).take_every(item.step)  # type: ignore
                )

        # select multiple columns
        # df[&quot;foo&quot;, &quot;bar&quot;]
        if isinstance(item, Sequence):
            if isinstance(item[0], str):
                return wrap_df(self._df.select(item))
            elif isinstance(item[0], pli.Expr):
                return self.select(item)

        # select rows by mask or index
        # df[[1, 2, 3]]
        # df[true, false, true]
        if isinstance(item, np.ndarray):
            if item.dtype == int:
                return wrap_df(self._df.take(item))
            if isinstance(item[0], str):
                return wrap_df(self._df.select(item))
        if isinstance(item, (pli.Series, Sequence)):
            if isinstance(item, Sequence):
                # only bool or integers allowed
                if type(item[0]) == bool:
                    item = pli.Series(&quot;&quot;, item)
                else:
                    return wrap_df(
                        self._df.take([self._pos_idx(i, dim=0) for i in item])
                    )
            dtype = item.dtype
            if dtype == Boolean:
                return wrap_df(self._df.filter(item.inner()))
            if dtype == UInt32:
                return wrap_df(self._df.take_with_series(item.inner()))

    def __setitem__(self, key: Union[str, int, Tuple[Any, Any]], value: Any) -&gt; None:
        # df[&quot;foo&quot;] = series
        if isinstance(key, str):
            try:
                self.replace(key, pli.Series(key, value))
            except Exception:
                self.hstack([pli.Series(key, value)], in_place=True)
        # df[idx] = series
        elif isinstance(key, int):
            assert isinstance(value, pli.Series)
            self.replace_at_idx(key, value)
        # df[[&quot;C&quot;, &quot;D&quot;]]
        elif isinstance(key, list):
            value = np.array(value)
            if len(value.shape) != 2:
                raise ValueError(&quot;can only set multiple columns with 2D matrix&quot;)
            if value.shape[1] != len(key):
                raise ValueError(
                    &quot;matrix columns should be equal to list use to determine column names&quot;
                )
            for (i, name) in enumerate(key):
                self[name] = value[:, i]

        # df[a, b]
        elif isinstance(key, tuple):
            row_selection, col_selection = key

            # get series column selection
            if isinstance(col_selection, str):
                s = self.__getitem__(col_selection)
            elif isinstance(col_selection, int):
                s = self[:, col_selection]
            else:
                raise ValueError(f&quot;column selection not understood: {col_selection}&quot;)

            # dispatch to __setitem__ of Series to do modification
            s[row_selection] = value

            # now find the location to place series
            # df[idx]
            if isinstance(col_selection, int):
                self.replace_at_idx(col_selection, s)
            # df[&quot;foo&quot;]
            elif isinstance(col_selection, str):
                self.replace(col_selection, s)
        else:
            raise NotImplementedError

    def __len__(self) -&gt; int:
        return self.height

    def _repr_html_(self) -&gt; str:
        &quot;&quot;&quot;
        Used by jupyter notebooks to get a html table.

        Output rows and columns can be modified by setting the following ENVIRONMENT variables:

        * POLARS_FMT_MAX_COLS: set the number of columns
        * POLARS_FMT_MAX_ROWS: set the number of rows
        &quot;&quot;&quot;
        max_cols = int(os.environ.get(&quot;POLARS_FMT_MAX_COLS&quot;, default=75))
        max_rows = int(os.environ.get(&quot;POLARS_FMT_MAX_ROWS&quot;, default=25))
        return &quot;\n&quot;.join(NotebookFormatter(self, max_cols, max_rows).render())

    def to_series(self, index: int = 0) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column as Series at index location.

        Parameters
        ----------
        index
            Location of selection.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_series(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(index))

    def rename(self, mapping: Dict[str, str]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rename column names.

        Parameters
        ----------
        mapping
            Key value pairs that map from old name to new name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df.rename({&quot;foo&quot;: &quot;apple&quot;})
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 1     ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2     ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3     ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        df = self.clone()
        for k, v in mapping.items():
            df._df.rename(k, v)
        return df

    def insert_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Insert a Series at a certain column index. This operation is in place.

        Parameters
        ----------
        index
            Column to insert the new `Series` column.
        series
            `Series` to insert.
        &quot;&quot;&quot;
        self._df.insert_at_idx(index, series._s)

    def filter(self, predicate: &quot;pli.Expr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Filter the rows in the DataFrame based on a predicate expression.

        Parameters
        ----------
        predicate
            Expression that evaluates to a boolean Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; # Filter on one condition
        &gt;&gt;&gt; df.filter(pl.col(&quot;foo&quot;) &lt; 3)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ b   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt;  # Filter on multiple conditions
        &gt;&gt;&gt; df.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;))
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .filter(predicate)
            .collect(no_optimization=True, string_cache=False)
        )

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &quot;&quot;&quot;
        Get the shape of the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.shape
        shape: (5, 1)

        &quot;&quot;&quot;
        return self._df.shape()

    @property
    def height(self) -&gt; int:
        &quot;&quot;&quot;
        Get the height of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.height
        5

        &quot;&quot;&quot;
        return self._df.height()

    @property
    def width(self) -&gt; int:
        &quot;&quot;&quot;
        Get the width of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.width
        1
        &quot;&quot;&quot;
        return self._df.width()

    @property
    def columns(self) -&gt; tp.List[str]:
        &quot;&quot;&quot;
        Get or set column names.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
            &quot;foo&quot;: [1, 2, 3],
            &quot;bar&quot;: [6, 7, 8],
            &quot;ham&quot;: ['a', 'b', 'c']
            })
        &gt;&gt;&gt; df.columns
        ['foo', 'bar', 'ham']
        &gt;&gt;&gt; # Set column names
        &gt;&gt;&gt; df.columns = ['apple', 'banana', 'orange']
        shape: (3, 3)
        ╭───────┬────────┬────────╮
        │ apple ┆ banana ┆ orange │
        │ ---   ┆ ---    ┆ ---    │
        │ i64   ┆ i64    ┆ str    │
        ╞═══════╪════════╪════════╡
        │ 1     ┆ 6      ┆ &quot;a&quot;    │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2     ┆ 7      ┆ &quot;b&quot;    │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 3     ┆ 8      ┆ &quot;c&quot;    │
        ╰───────┴────────┴────────╯

        &quot;&quot;&quot;
        return self._df.columns()

    @columns.setter
    def columns(self, columns: Sequence[str]) -&gt; None:
        &quot;&quot;&quot;
        Change the column names of the `DataFrame`.

        Parameters
        ----------
        columns
            A list with new names for the `DataFrame`.
            The length of the list should be equal to the width of the `DataFrame`.
        &quot;&quot;&quot;
        self._df.set_column_names(columns)

    @property
    def dtypes(self) -&gt; tp.List[Type[DataType]]:
        &quot;&quot;&quot;
        Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.dtypes
        [polars.datatypes.Int64, polars.datatypes.Float64, polars.datatypes.Utf8]
        &gt;&gt;&gt; df
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return [DTYPES[idx] for idx in self._df.dtypes()]

    def describe(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     'a': [1.0, 2.8, 3.0],
        &gt;&gt;&gt;     'b': [4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [True, False, True]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.describe()
        shape: (5, 4)
        ╭──────────┬───────┬─────┬──────╮
        │ describe ┆ a     ┆ b   ┆ c    │
        │ ---      ┆ ---   ┆ --- ┆ ---  │
        │ str      ┆ f64   ┆ f64 ┆ f64  │
        ╞══════════╪═══════╪═════╪══════╡
        │ &quot;mean&quot;   ┆ 2.267 ┆ 5   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;std&quot;    ┆ 1.102 ┆ 1   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;min&quot;    ┆ 1     ┆ 4   ┆ 0.0  │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;max&quot;    ┆ 3     ┆ 6   ┆ 1    │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;median&quot; ┆ 2.8   ┆ 5   ┆ null │
        ╰──────────┴───────┴─────┴──────╯

        &quot;&quot;&quot;

        def describe_cast(self: &quot;DataFrame&quot;) -&gt; &quot;DataFrame&quot;:
            columns = []
            for s in self:
                if s.is_numeric() or s.is_boolean():
                    columns.append(s.cast(float))
                else:
                    columns.append(s)
            return DataFrame(columns)

        summary = pli.concat(
            [
                describe_cast(self.mean()),  # type: ignore
                describe_cast(self.std()),
                describe_cast(self.min()),  # type: ignore
                describe_cast(self.max()),  # type: ignore
                describe_cast(self.median()),
            ]
        )
        summary.insert_at_idx(  # type: ignore
            0, pli.Series(&quot;describe&quot;, [&quot;mean&quot;, &quot;std&quot;, &quot;min&quot;, &quot;max&quot;, &quot;median&quot;])
        )
        return summary  # type: ignore

    def replace_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column at an index location.

        Parameters
        ----------
        index
            Column index.
        series
            Series that will replace the column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.replace_at_idx(0, x)
        shape: (3, 3)
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 10    ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 20    ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 30    ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        self._df.replace_at_idx(index, series._s)

    def sort(
        self,
        by: Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]],
        reverse: Union[bool, tp.List[bool]] = False,
        in_place: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sort the DataFrame by column.

        Parameters
        ----------
        by
            By which column to sort. Only accepts string.
        reverse
            Reverse/descending sort.
        in_place
            Perform operation in-place.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sort('foo', reverse=True)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ╰─────┴─────┴─────╯

        **Sort by multiple columns.**
        For multiple columns we can also use expression syntax.

        &gt;&gt;&gt; df.sort([pl.col(&quot;foo&quot;), pl.col(&quot;bar&quot;) ** 2], reverse=[True, False])

        &quot;&quot;&quot;
        if type(by) is list or isinstance(by, pli.Expr):
            df = (
                self.lazy()
                .sort(by, reverse)
                .collect(no_optimization=True, string_cache=False)
            )
            if in_place:
                self._df = df._df
                return self
            return df
        if in_place:
            self._df.sort_in_place(by, reverse)
            return self
        else:
            return wrap_df(self._df.sort(by, reverse))

    def frame_equal(self, other: &quot;DataFrame&quot;, null_equal: bool = True) -&gt; bool:
        &quot;&quot;&quot;
        Check if DataFrame is equal to other.

        Parameters
        ----------
        other
            DataFrame to compare with.
        null_equal
            Consider null values as equal.

        Examples
        --------
        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 2, 1],
        &gt;&gt;&gt;     &quot;bar&quot;: [8.0, 7.0, 6.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'b', 'a']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.frame_equal(df1)
        True
        &gt;&gt;&gt; df1.frame_equal(df2)
        False

        &quot;&quot;&quot;
        return self._df.frame_equal(other._df, null_equal)

    def replace(self, column: str, new_col: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column by a new Series.

        Parameters
        ----------
        column
            Column to replace.
        new_col
            New column to insert.
        &quot;&quot;&quot;
        self._df.replace(column, new_col.inner())

    def slice(self, offset: int, length: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Slice this DataFrame over the rows direction.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.slice(1, 2)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        if length &lt; 0:
            length = self.height - offset + length
        return wrap_df(self._df.slice(offset, length))

    def limit(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        See Also `DataFrame.head`

        Parameters
        ----------
        length
            Amount of rows to take.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.limit(2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return self.head(length)

    def head(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.head(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.head(length))

    def tail(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get last N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.tail(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 5   ┆ 10  ┆ &quot;e&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.tail(length))

    def drop_nulls(self, subset: Optional[tp.List[str]] = None) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame where the null values are dropped.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, None, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.drop_nulls()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        This method only drops nulls row-wise if any single value of the row is null.

        Below are some example snippets that show how you could drop null values based on other
        conditions

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {
        &gt;&gt;&gt;        &quot;a&quot;: [None, None, None, None],
        &gt;&gt;&gt;        &quot;b&quot;: [1, 2, None, 1],
        &gt;&gt;&gt;        &quot;c&quot;: [1, None, None, 1],
        &gt;&gt;&gt;    }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df
        shape: (4, 3)
        ┌──────┬──────┬──────┐
        │ a    ┆ b    ┆ c    │
        │ ---  ┆ ---  ┆ ---  │
        │ f64  ┆ i64  ┆ i64  │
        ╞══════╪══════╪══════╡
        │ null ┆ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1    ┆ 1    │
        └──────┴──────┴──────┘

        &gt;&gt;&gt; # drop a row only if all values are null
        &gt;&gt;&gt; df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
        shape: (3, 3)
        ┌──────┬─────┬──────┐
        │ a    ┆ b   ┆ c    │
        │ ---  ┆ --- ┆ ---  │
        │ f64  ┆ i64 ┆ i64  │
        ╞══════╪═════╪══════╡
        │ null ┆ 1   ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2   ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1   ┆ 1    │
        └──────┴─────┴──────┘

        &gt;&gt;&gt; # drop a column if all values are null
        &gt;&gt;&gt; df[:, [not (s.null_count() == df.height) for s in df]]
        shape: (4, 2)
        ┌──────┬──────┐
        │ b    ┆ c    │
        │ ---  ┆ ---  │
        │ i64  ┆ i64  │
        ╞══════╪══════╡
        │ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 1    │
        └──────┴──────┘

        &quot;&quot;&quot;
        if subset is not None and isinstance(subset, str):
            subset = [subset]
        return wrap_df(self._df.drop_nulls(subset))

    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:
        &quot;&quot;&quot;
        Apply a function on Self.

        Parameters
        ----------
        func
            Callable.
        args
            Arguments.
        kwargs
            Keyword arguments.
        &quot;&quot;&quot;
        return func(self, *args, **kwargs)

    def with_row_count(self, name: str = &quot;row_nr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add a column at index 0 that counts the rows.

        Parameters
        ----------
        name
            Name of the column to add.
        &quot;&quot;&quot;
        return wrap_df(self._df.with_row_count(name))

    def groupby(
        self,
        by: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]],
        maintain_order: bool = False,
    ) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a groupby operation.

        Parameters
        ----------
        by
            Column(s) to group by.
        maintain_order
            Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
            Note that this only works in expression aggregations.

        Examples
        --------
        Below we group by column `&quot;a&quot;`, and we sum column `&quot;b&quot;`.

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;],
        &gt;&gt;&gt;     &quot;b&quot;: [1, 2, 3, 4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [6, 5, 4, 3, 2, 1],
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; assert (
        &gt;&gt;&gt;     df.groupby(&quot;a&quot;)[&quot;b&quot;]
        &gt;&gt;&gt;     .sum()
        &gt;&gt;&gt;     .sort(by_column=&quot;a&quot;)
        &gt;&gt;&gt;     .frame_equal(DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;: [4, 11, 6]})))

        We can also loop over the grouped `DataFrame`

        &gt;&gt;&gt; for sub_df in df.groupby(&quot;a&quot;):
        &gt;&gt;&gt;    print(sub_df)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;b&quot; ┆ 2   ┆ 5   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 4   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 5   ┆ 2   │
        ╰─────┴─────┴─────╯
        shape: (1, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;c&quot; ┆ 6   ┆ 1   │
        ╰─────┴─────┴─────╯
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;a&quot; ┆ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot; ┆ 3   ┆ 4   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(by, str):
            by = [by]
        return GroupBy(
            self._df, by, maintain_order=maintain_order, downsample=False  # type: ignore
        )

    def downsample(self, by: Union[str, tp.List[str]], rule: str, n: int) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a downsampling groupby operation.

        Parameters
        ----------
        by
            Column that will be used as key in the groupby operation.
            This should be a datetime/date column.
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-02&quot;, &quot;2020-01-03&quot;,&quot;2020-01-04&quot;,&quot;2020-01-05&quot;,&quot;2020-01-06&quot;],
        &gt;&gt;&gt;         &quot;B&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0],
        &gt;&gt;&gt;         &quot;C&quot;: [3.0, 6.0, 9.0, 2.0, 13.0, 8.0],
        &gt;&gt;&gt;         &quot;D&quot;: [12.0, 5.0, 9.0, 2.0, 11.0, 2.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df['A'] = df['A'].str.strptime(pl.Date, &quot;%Y-%m-%d&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; df.downsample(&quot;A&quot;, rule=&quot;day&quot;, n=3).agg(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;B&quot;: &quot;max&quot;,
        &gt;&gt;&gt;         &quot;C&quot;: &quot;min&quot;,
        &gt;&gt;&gt;         &quot;D&quot;: &quot;last&quot;
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        shape: (3, 4)
        ┌──────────────┬───────┬───────┬────────┐
        │ A            ┆ B_max ┆ C_min ┆ D_last │
        │ ---          ┆ ---   ┆ ---   ┆ ---    │
        │ date(days)   ┆ f64   ┆ f64   ┆ f64    │
        ╞══════════════╪═══════╪═══════╪════════╡
        │ 2019-12-31   ┆ 8     ┆ 3     ┆ 5      │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-03   ┆ 16    ┆ 2     ┆ 11     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-06   ┆ 10    ┆ 8     ┆ 2      │
        └──────────────┴───────┴───────┴────────┘

        &quot;&quot;&quot;
        return GroupBy(
            self._df,
            by,
            maintain_order=False,
            downsample=True,
            rule=rule,
            downsample_n=n,
        )

    def upsample(self, by: str, interval: timedelta) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Upsample a DataFrame at a regular frequency.

        Parameters
        ----------
        by
            Column that will be used as key in the upsampling operation.
            This should be a datetime column.
        interval
            Interval periods.
        &quot;&quot;&quot;
        if self[by].dtype != Datetime:
            raise ValueError(
                f&quot;Column {by} should be of type datetime. Got {self[by].dtype}&quot;
            )
        bounds = self.select(
            [pli.col(by).min().alias(&quot;low&quot;), pli.col(by).max().alias(&quot;high&quot;)]
        )
        low = bounds[&quot;low&quot;].dt[0]
        high = bounds[&quot;high&quot;].dt[0]
        upsampled = pli.date_range(low, high, interval, name=by)
        return DataFrame(upsampled).join(self, on=by, how=&quot;left&quot;)  # type: ignore

    def join(
        self,
        df: &quot;DataFrame&quot;,
        left_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        right_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        on: Optional[Union[str, tp.List[str]]] = None,
        how: str = &quot;inner&quot;,
        suffix: str = &quot;_right&quot;,
        asof_by: Optional[Union[str, tp.List[str]]] = None,
        asof_by_left: Optional[Union[str, tp.List[str]]] = None,
        asof_by_right: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        SQL like joins.

        Parameters
        ----------
        df
            DataFrame to join with.
        left_on
            Name(s) of the left join column(s).
        right_on
            Name(s) of the right join column(s).
        on
            Name(s) of the join columns in both DataFrames.
        how
            Join strategy
                - &quot;inner&quot;
                - &quot;left&quot;
                - &quot;outer&quot;
                - &quot;asof&quot;
                - &quot;cross&quot;
        suffix
            Suffix to append to columns with a duplicate name.
        asof_by
            join on these columns before doing asof join
        asof_by_left
            join on these columns before doing asof join
        asof_by_right
            join on these columns before doing asof join
        Returns
        -------
            Joined DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; other_df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;apple&quot;: ['x', 'y', 'z'],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.join(other_df, on='ham')
        shape: (2, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ f64 ┆ str ┆ str   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ╰─────┴─────┴─────┴───────╯

        &gt;&gt;&gt; df.join(other_df, on='ham', how='outer')
        shape: (4, 4)
        ╭──────┬──────┬─────┬───────╮
        │ foo  ┆ bar  ┆ ham ┆ apple │
        │ ---  ┆ ---  ┆ --- ┆ ---   │
        │ i64  ┆ f64  ┆ str ┆ str   │
        ╞══════╪══════╪═════╪═══════╡
        │ 1    ┆ 6    ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ null ┆ null ┆ &quot;d&quot; ┆ &quot;z&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot; ┆ null  │
        ╰──────┴──────┴─────┴───────╯

        Asof join
        =========
        This is similar to a left-join except that we match on nearest key rather than equal keys.
        The keys must be sorted to perform an asof join

        &quot;&quot;&quot;
        if how == &quot;cross&quot;:
            return wrap_df(self._df.join(df._df, [], [], how, suffix))

        left_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(left_on, (str, pli.Expr)):
            left_on_ = [left_on]  # type: ignore[assignment]
        else:
            left_on_ = left_on

        right_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(right_on, (str, pli.Expr)):
            right_on_ = [right_on]  # type: ignore[assignment]
        else:
            right_on_ = right_on

        if isinstance(on, str):
            left_on_ = [on]
            right_on_ = [on]
        elif isinstance(on, list):
            left_on_ = on
            right_on_ = on

        if left_on_ is None or right_on_ is None:
            raise ValueError(&quot;You should pass the column to join on as an argument.&quot;)

        if (
            isinstance(left_on_[0], pli.Expr)
            or isinstance(right_on_[0], pli.Expr)
            or asof_by_left is not None
            or asof_by_right is not None
            or asof_by is not None
        ):
            return (
                self.lazy()
                .join(
                    df.lazy(),
                    left_on,
                    right_on,
                    on=on,
                    how=how,
                    suffix=suffix,
                    asof_by_right=asof_by_right,
                    asof_by_left=asof_by_left,
                    asof_by=asof_by,
                )
                .collect(no_optimization=True)
            )
        else:
            return wrap_df(self._df.join(df._df, left_on_, right_on_, how, suffix))

    def apply(
        self,
        f: Callable[[Tuple[Any]], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.

        Beware, this is slow.

        Parameters
        ----------
        f
            Custom function/ lambda function.
        return_dtype
            Output type of the operation. If none given, Polars tries to infer the type.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.apply(f, return_dtype))

    def with_column(self, column: Union[&quot;pli.Series&quot;, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column added or replaced.

        Parameters
        ----------
        column
            Series, where the name of the Series refers to the column in the DataFrame.
        &quot;&quot;&quot;
        if isinstance(column, pli.Expr):
            return self.with_columns([column])
        else:
            return wrap_df(self._df.with_column(column._s))

    def with_column_renamed(self, existing_name: str, new_name: str) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column renamed.

        Parameters
        ----------
        existing_name
        new_name
        &quot;&quot;&quot;
        return (
            self.lazy()
            .with_column_renamed(existing_name, new_name)
            .collect(no_optimization=True, string_cache=False)
        )

    def hstack(
        self, columns: Union[tp.List[&quot;pli.Series&quot;], &quot;DataFrame&quot;], in_place: bool = False
    ) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Return a new DataFrame grown horizontally by stacking multiple Series to it.

        Parameters
        ----------
        columns
            Series to stack.
        in_place
            Modify in place.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.hstack([x])
        shape: (3, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ i64 ┆ str ┆ i64   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ 10    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ 20    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; ┆ 30    │
        ╰─────┴─────┴─────┴───────╯

        &quot;&quot;&quot;
        if not isinstance(columns, list):
            columns = columns.get_columns()
        if in_place:
            self._df.hstack_mut([s.inner() for s in columns])
            return None
        else:
            return wrap_df(self._df.hstack([s.inner() for s in columns]))

    def vstack(self, df: &quot;DataFrame&quot;, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Grow this DataFrame vertically by stacking a DataFrame to it.

        Parameters
        ----------
        df
            DataFrame to stack.
        in_place
            Modify in place

        Examples
        --------

        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 4],
        &gt;&gt;&gt;     &quot;bar&quot;: [8 , 9],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.vstack(df2)
        shape: (4, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if in_place:
            self._df.vstack_mut(df._df)
            return None
        else:
            return wrap_df(self._df.vstack(df._df))

    def drop(self, name: Union[str, tp.List[str]]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Remove column from DataFrame and return as new.

        Parameters
        ----------
        name
            Column(s) to drop.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop('ham')
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ f64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(name, list):
            df = self.clone()

            for name in name:
                df._df.drop_in_place(name)
            return df

        return wrap_df(self._df.drop(name))

    def drop_in_place(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Drop in place.

        Parameters
        ----------
        name
            Column to drop.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop_in_place(&quot;ham&quot;)
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ i64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.drop_in_place(name))

    def select_at_idx(self, idx: int) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column at index location.

        Parameters
        ----------
        idx
            Location of selection.

        .. deprecated:: 0.10.20

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select_at_idx(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(idx))

    def clone(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Very cheap deep clone.
        &quot;&quot;&quot;
        return wrap_df(self._df.clone())

    def __copy__(self) -&gt; &quot;DataFrame&quot;:
        return self.clone()

    def __deepcopy__(self, memodict={}) -&gt; &quot;DataFrame&quot;:  # type: ignore
        return self.clone()

    def get_columns(self) -&gt; tp.List[&quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Get the DataFrame as a List of Series.
        &quot;&quot;&quot;
        return list(map(lambda s: pli.wrap_s(s), self._df.get_columns()))

    def get_column(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a single column as Series by name.
        &quot;&quot;&quot;
        return self[name]

    def fill_null(self, strategy: Union[str, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a filling strategy or an Expression evaluation.

        Parameters
        ----------
        strategy
            One of:
            - &quot;backward&quot;
            - &quot;forward&quot;
            - &quot;mean&quot;
            - &quot;min'
            - &quot;max&quot;
            - &quot;zero&quot;
            - &quot;one&quot;
            Or an expression.

        Returns
        -------
            DataFrame with None replaced with the filling strategy.
        &quot;&quot;&quot;
        if isinstance(strategy, pli.Expr):
            return self.lazy().fill_null(strategy).collect(no_optimization=True)
        if not isinstance(strategy, str):
            return self.fill_null(pli.lit(strategy))
        return wrap_df(self._df.fill_null(strategy))

    def fill_nan(self, fill_value: Union[&quot;pli.Expr&quot;, int, float]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a an Expression evaluation.

        Warnings
        --------
        NOTE that floating point NaN (No a Number) are not missing values!
        to replace missing values, use `fill_null`.

        Parameters
        ----------
        fill_value
            value to fill NaN with

        Returns
        -------
            DataFrame with NaN replaced with fill_value
        &quot;&quot;&quot;
        return self.lazy().fill_nan(fill_value).collect(no_optimization=True)

    def explode(
        self, columns: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Explode `DataFrame` to long format by exploding a column with Lists.

        Parameters
        ----------
        columns
            Column of LargeList type.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬────────────╮
        │ letters ┆ nrs        │
        │ ---     ┆ ---        │
        │ str     ┆ list [i64] │
        ╞═════════╪════════════╡
        │ &quot;c&quot;     ┆ [1, 2]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [1, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [4, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [5, 5, 5]  │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [6]        │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ [2, 1, 2]  │
        ╰─────────┴────────────╯
        &gt;&gt;&gt; df.explode(&quot;nrs&quot;)
        shape: (13, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ ...     ┆ ... │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return self.lazy().explode(columns).collect(no_optimization=True)

    def melt(
        self, id_vars: Union[tp.List[str], str], value_vars: Union[tp.List[str], str]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Unpivot DataFrame to long format.

        Parameters
        ----------
        id_vars
            Columns to use as identifier variables.

        value_vars
            Values to use as identifier variables.

        Returns
        -------

        &quot;&quot;&quot;
        if isinstance(value_vars, str):
            value_vars = [value_vars]
        if isinstance(id_vars, str):
            id_vars = [id_vars]
        return wrap_df(self._df.melt(id_vars, value_vars))

    def shift(self, periods: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift(periods=1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 6    ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        └──────┴──────┴──────┘
        &gt;&gt;&gt; df.shift(periods=-1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        └──────┴──────┴──────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.shift(periods))

    def shift_and_fill(
        self, periods: int, fill_value: Union[int, str, float]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            fill None values with this value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift_and_fill(periods=1, fill_value=0)
        shape: (3, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 0   ┆ 0   ┆ &quot;0&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .shift_and_fill(periods, fill_value)
            .collect(no_optimization=True, string_cache=False)
        )

    def is_duplicated(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all duplicated rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_duplicated())

    def is_unique(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all unique rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_unique())

    def lazy(self) -&gt; &quot;pli.LazyFrame&quot;:
        &quot;&quot;&quot;
        Start a lazy query from this point. This returns a `LazyFrame` object.

        Operations on a `LazyFrame` are not executed until this is requested by either calling:

        * `.fetch()` (run on a small number of rows)
        * `.collect()` (run on all data)
        * `.describe_plan()` (print unoptimized query plan)
        * `.describe_optimized_plan()` (print optimized query plan)
        * `.show_graph()` (show (un)optimized query plan) as graphiz graph)

        Lazy operations are advised because they allow for query optimization and more parallelization.
        &quot;&quot;&quot;
        return pli.wrap_ldf(self._df.lazy())

    def select(
        self,
        exprs: Union[
            str,
            &quot;pli.Expr&quot;,
            Sequence[Union[str, &quot;pli.Expr&quot;]],
            Sequence[bool],
            Sequence[int],
            Sequence[float],
        ],
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Select columns from this DataFrame.

        Parameters
        ----------
        exprs
            Column or columns to select.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select('foo')
        shape: (3, 1)
        ┌─────┐
        │ foo │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        └─────┘

        &quot;&quot;&quot;
        return (
            self.lazy().select(exprs).collect(no_optimization=True, string_cache=False)  # type: ignore
        )

    def with_columns(
        self, exprs: Union[&quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite multiple columns in a DataFrame.

        Parameters
        ----------
        exprs
            List of Expressions that evaluate to columns.
        &quot;&quot;&quot;
        if not isinstance(exprs, list):
            exprs = [exprs]
        return (
            self.lazy()
            .with_columns(exprs)
            .collect(no_optimization=True, string_cache=False)
        )

    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get number of chunks used by the ChunkedArrays of this DataFrame.
        &quot;&quot;&quot;
        return self._df.n_chunks()

    def max(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their maximum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.max()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 3   ┆ 8   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.max())
        if axis == 1:
            return pli.wrap_s(self._df.hmax())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def min(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their minimum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.min()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 6   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.min())
        if axis == 1:
            return pli.wrap_s(self._df.hmin())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def sum(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their sum value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sum()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 6   ┆ 21  ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.sum())
        if axis == 1:
            return pli.wrap_s(self._df.hsum(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def mean(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their mean value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.mean()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.mean())
        if axis == 1:
            return pli.wrap_s(self._df.hmean(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def std(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their standard deviation value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.std()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.std())

    def var(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their variance value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.var()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.var())

    def median(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their median value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.median()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.median())

    def quantile(self, quantile: float) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their quantile value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.quantile(0.5)
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.quantile(quantile))

    def to_dummies(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get one hot encoded dummy variables.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_dummies()
        shape: (3, 9)
        ╭───────┬───────┬───────┬───────┬─────┬───────┬───────┬───────┬───────╮
        │ foo_1 ┆ foo_2 ┆ foo_3 ┆ bar_6 ┆ ... ┆ bar_8 ┆ ham_a ┆ ham_b ┆ ham_c │
        │ ---   ┆ ---   ┆ ---   ┆ ---   ┆     ┆ ---   ┆ ---   ┆ ---   ┆ ---   │
        │ u8    ┆ u8    ┆ u8    ┆ u8    ┆     ┆ u8    ┆ u8    ┆ u8    ┆ u8    │
        ╞═══════╪═══════╪═══════╪═══════╪═════╪═══════╪═══════╪═══════╪═══════╡
        │ 1     ┆ 0     ┆ 0     ┆ 1     ┆ ... ┆ 0     ┆ 1     ┆ 0     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 1     ┆ 0     ┆ 0     ┆ ... ┆ 0     ┆ 0     ┆ 1     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 0     ┆ 1     ┆ 0     ┆ ... ┆ 1     ┆ 0     ┆ 0     ┆ 1     │
        ╰───────┴───────┴───────┴───────┴─────┴───────┴───────┴───────┴───────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.to_dummies())

    def drop_duplicates(
        self,
        maintain_order: bool = True,
        subset: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Drop duplicate rows from this DataFrame.
        Note that this fails if there is a column of type `List` in the DataFrame.
        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_df(self._df.drop_duplicates(maintain_order, subset))

    def rechunk(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rechunk the data in this DataFrame to a contiguous allocation.

        This will make sure all subsequent operations have optimal and predictable performance.
        &quot;&quot;&quot;
        return wrap_df(self._df.rechunk())

    def null_count(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Create a new DataFrame that shows the null counts per column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, None, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, None],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.null_count()
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ u32 ┆ u32 ┆ u32 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 1   ┆ 0   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.null_count())

    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sample from this DataFrame by setting either `n` or `frac`.

        Parameters
        ----------
        n
            Number of samples &lt; self.len() .
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            Sample with replacement.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sample(n=2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if n is not None:
            return wrap_df(self._df.sample_n(n, with_replacement))
        return wrap_df(self._df.sample_frac(frac, with_replacement))

    def fold(
        self, operation: Callable[[&quot;pli.Series&quot;, &quot;pli.Series&quot;], &quot;pli.Series&quot;]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a horizontal reduction on a DataFrame. This can be used to effectively
        determine aggregations on a row level, and can be applied to any DataType that
        can be supercasted (casted to a similar parent type).

        An example of the supercast rules when applying an arithmetic operation on two DataTypes are for instance:

        Int8 + Utf8 = Utf8
        Float32 + Int64 = Float32
        Float32 + Float64 = Float64

        Examples
        --------
        &gt;&gt;&gt; # A horizontal sum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: 'a' [f64]
        [
            4
            5
            9
        ]

        &gt;&gt;&gt; # A horizontal minimum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1.zip_with(s1 &lt; s2, s2))
        Series: 'a' [f64]
        [
            1
            1
            3
        ]

        &gt;&gt;&gt; # A horizontal string concattenation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, 2],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: '' [f64]
        [
            &quot;foo11&quot;
            &quot;bar22
            &quot;233&quot;
        ]

        Parameters
        ----------
        operation
            function that takes two `Series` and returns a `Series`.

        &quot;&quot;&quot;
        if self.width == 1:
            return self.to_series(0)
        df = self
        acc = operation(df.to_series(0), df.to_series(1))

        for i in range(2, df.width):
            acc = operation(acc, df.to_series(i))
        return acc

    def row(self, index: int) -&gt; Tuple[Any]:
        &quot;&quot;&quot;
        Get a row as tuple.

        Parameters
        ----------
        index
            Row index.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.row(2)
        (3, 8, 'c')

        &quot;&quot;&quot;
        return self._df.row_tuple(index)

    def rows(self) -&gt; tp.List[Tuple]:
        &quot;&quot;&quot;
        Convert columnar data to rows as python tuples.
        &quot;&quot;&quot;
        return self._df.row_tuples()

    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._df.shrink_to_fit()
            return None
        else:
            df = self.clone()
            df._df.shrink_to_fit()
            return df

    def hash_rows(
        self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash and combine the rows in this DataFrame.

        Hash value is UInt64

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.hash(k0=42)
        shape: (3,)
        Series: '' [u64]
        [
                1208206736888326229
                8040480609798856146
                18282897888575762835
        ]
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.hash_rows(k0, k1, k2, k3))

    def interpolate(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return self.select(pli.col(&quot;*&quot;).interpolate())  # type: ignore

    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if the dataframe is empty
        &quot;&quot;&quot;
        return self.height == 0
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-5"><a class="header" href="#constructor-5">Constructor</a></h2>
<pre><code class="language-python">DataFrame(data: OptionalUnion[Dict[str, SequenceAny], SequenceAny, np.ndarray, pa.Table, pd.DataFrame, pli.Series], 
    columns: OptionalSequencestr, 
    orient: Optionalstr,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        data: Optional[
            Union[
                Dict[str, Sequence[Any]],
                Sequence[Any],
                np.ndarray,
                &quot;pa.Table&quot;,
                &quot;pd.DataFrame&quot;,
                &quot;pli.Series&quot;,
            ]
        ] = None,
        columns: Optional[Sequence[str]] = None,
        orient: Optional[str] = None,
    ):
        if data is None:
            self._df = dict_to_pydf({}, columns=columns)

        elif isinstance(data, dict):
            self._df = dict_to_pydf(data, columns=columns)

        elif isinstance(data, np.ndarray):
            self._df = numpy_to_pydf(data, columns=columns, orient=orient)

        elif _PYARROW_AVAILABLE and isinstance(data, pa.Table):
            self._df = arrow_to_pydf(data, columns=columns)

        elif isinstance(data, Sequence) and not isinstance(data, str):
            self._df = sequence_to_pydf(data, columns=columns, orient=orient)

        elif isinstance(data, pli.Series):
            self._df = series_to_pydf(data, columns=columns)

        elif _PANDAS_AVAILABLE and isinstance(data, pd.DataFrame):
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required for converting a pandas DataFrame to a polars DataFrame.&quot;
                )
            self._df = pandas_to_pydf(data, columns=columns)

        else:
            raise ValueError(&quot;DataFrame constructor not called properly.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-5"><a class="header" href="#methods-5">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_csv"><a class="header" href="#polarsinternalsframedataframeread_csv"><code>polars.internals.frame.DataFrame.read_csv</code></a></h3>
<pre><code class="language-python">read_csv(file: Union[str, BinaryIO, bytes], 
    infer_schema_length: Optionalint, 
    batch_size: int, 
    has_headers: bool, 
    ignore_errors: bool, 
    stop_after_n_rows: Optionalint, 
    skip_rows: int, 
    projection: Optionaltp.List[int], 
    sep: str, 
    columns: Optionaltp.List[str], 
    rechunk: bool, 
    encoding: str, 
    n_threads: Optionalint, 
    dtype: Union[Dict[str, TypeDataType], tp.List[TypeDataType], None], 
    low_memory: bool, 
    comment_char: Optionalstr, 
    quote_char: Optionalstr, 
    null_values: OptionalUnion[str, tp.List[str], Dict[str, str]], 
    parse_dates: bool,) -&gt; DataFrame:
</code></pre>
<p>Read a CSV file into a Dataframe.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>file</code>]: Path to a file or a file like object. Any valid filepath can be used. Example: <code>file.csv</code>.</p>
</li>
<li>
<p>[<code>infer_schema_length</code>]: Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
If set to <code>None</code>, a full table scan will be done (slow).</p>
</li>
<li>
<p>[<code>batch_size</code>]: Number of lines to read into the buffer at once. Modify this to change performance.</p>
</li>
<li>
<p>[<code>has_headers</code>]: Indicate if first row of dataset is header or not. If set to False first row will be set to <code>column_x</code>,
<code>x</code> being an enumeration over every column in the dataset.</p>
</li>
<li>
<p>[<code>ignore_errors</code>]: Try to keep reading lines if some lines yield errors.</p>
</li>
<li>
<p>[<code>stop_after_n_rows</code>]: After n rows are read from the CSV, it stops reading.
During multi-threaded parsing, an upper bound of <code>n</code> rows
cannot be guaranteed.</p>
</li>
<li>
<p>[<code>skip_rows</code>]: Start reading after <code>skip_rows</code>.</p>
</li>
<li>
<p>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</p>
</li>
<li>
<p>[<code>sep</code>]: Character to use as delimiter in the file.</p>
</li>
<li>
<p>[<code>columns</code>]: Columns to select.</p>
</li>
<li>
<p>[<code>rechunk</code>]: Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.</p>
</li>
<li>
<p>[<code>encoding</code>]: Allowed encodings: <code>utf8</code>, <code>utf8-lossy</code>. Lossy means that invalid utf8 values are replaced with <code>�</code> character.</p>
</li>
<li>
<p>[<code>n_threads</code>]: Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.</p>
</li>
<li>
<p>[<code>dtype</code>]: Overwrite the dtypes during inference.</p>
</li>
<li>
<p>[<code>low_memory</code>]: Reduce memory usage in expense of performance.</p>
</li>
<li>
<p>[<code>comment_char</code>]: character that indicates the start of a comment line, for instance '#'.</p>
</li>
<li>
<p>[<code>quote_char</code>]: single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
of quotes off.</p>
</li>
<li>
<p>[<code>null_values</code>]: Values to interpret as null values. You can provide a:</p>
<ul>
<li>str -&gt; all values encountered equal to this string will be null</li>
<li>tp.List[str] -&gt; A null value per column.</li>
<li>Dict[str, str] -&gt; A dictionary that maps column name to a null value string.</li>
</ul>
</li>
<li>
<p>[<code>parse_dates</code>]: Whether to attempt to parse dates or not</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.read_csv('file.csv', sep=';', stop_after_n_rows=25)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_csv(
        file: Union[str, BinaryIO, bytes],
        infer_schema_length: Optional[int] = 100,
        batch_size: int = 64,
        has_headers: bool = True,
        ignore_errors: bool = False,
        stop_after_n_rows: Optional[int] = None,
        skip_rows: int = 0,
        projection: Optional[tp.List[int]] = None,
        sep: str = &quot;,&quot;,
        columns: Optional[tp.List[str]] = None,
        rechunk: bool = True,
        encoding: str = &quot;utf8&quot;,
        n_threads: Optional[int] = None,
        dtype: Union[Dict[str, Type[DataType]], tp.List[Type[DataType]], None] = None,
        low_memory: bool = False,
        comment_char: Optional[str] = None,
        quote_char: Optional[str] = r'&quot;',
        null_values: Optional[Union[str, tp.List[str], Dict[str, str]]] = None,
        parse_dates: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read a CSV file into a Dataframe.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used. Example: `file.csv`.
        infer_schema_length
            Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
            If set to `None`, a full table scan will be done (slow).
        batch_size
            Number of lines to read into the buffer at once. Modify this to change performance.
        has_headers
            Indicate if first row of dataset is header or not. If set to False first row will be set to `column_x`,
            `x` being an enumeration over every column in the dataset.
        ignore_errors
            Try to keep reading lines if some lines yield errors.
        stop_after_n_rows
            After n rows are read from the CSV, it stops reading.
            During multi-threaded parsing, an upper bound of `n` rows
            cannot be guaranteed.
        skip_rows
            Start reading after `skip_rows`.
        projection
            Indices of columns to select. Note that column indices start at zero.
        sep
            Character to use as delimiter in the file.
        columns
            Columns to select.
        rechunk
            Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.
        encoding
            Allowed encodings: `utf8`, `utf8-lossy`. Lossy means that invalid utf8 values are replaced with `�` character.
        n_threads
            Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.
        dtype
            Overwrite the dtypes during inference.
        low_memory
            Reduce memory usage in expense of performance.
        comment_char
            character that indicates the start of a comment line, for instance '#'.
        quote_char
            single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
            of quotes off.
        null_values
            Values to interpret as null values. You can provide a:

            - str -&gt; all values encountered equal to this string will be null
            - tp.List[str] -&gt; A null value per column.
            - Dict[str, str] -&gt; A dictionary that maps column name to a null value string.
        parse_dates
            Whether to attempt to parse dates or not

        Returns
        -------
        DataFrame

        Examples
        --------

        &gt;&gt;&gt; df = pl.read_csv('file.csv', sep=';', stop_after_n_rows=25)

        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)

        path: Optional[str]
        if isinstance(file, str):
            path = file
        else:
            path = None
            if isinstance(file, BytesIO):
                file = file.getvalue()
            if isinstance(file, StringIO):
                file = file.getvalue().encode()

        dtype_list: Optional[tp.List[Tuple[str, Type[DataType]]]] = None
        dtype_slice: Optional[tp.List[Type[DataType]]] = None
        if dtype is not None:
            if isinstance(dtype, dict):
                dtype_list = []
                for k, v in dtype.items():
                    dtype_list.append((k, py_type_to_dtype(v)))
            elif isinstance(dtype, list):
                dtype_slice = dtype
            else:
                raise ValueError(&quot;dtype arg should be list or dict&quot;)

        processed_null_values = _process_null_values(null_values)

        self._df = PyDataFrame.read_csv(
            file,
            infer_schema_length,
            batch_size,
            has_headers,
            ignore_errors,
            stop_after_n_rows,
            skip_rows,
            projection,
            sep,
            rechunk,
            columns,
            encoding,
            n_threads,
            path,
            dtype_list,
            dtype_slice,
            low_memory,
            comment_char,
            quote_char,
            processed_null_values,
            parse_dates,
        )
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_parquet"><a class="header" href="#polarsinternalsframedataframeread_parquet"><code>polars.internals.frame.DataFrame.read_parquet</code></a></h3>
<pre><code class="language-python">read_parquet(file: Union[str, BinaryIO], 
    columns: Optionaltp.List[str], 
    projection: Optionaltp.List[int], 
    stop_after_n_rows: Optionalint,) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from a parquet file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object. Any valid filepath can be used.</li>
<li>[<code>columns</code>]: Columns to select.</li>
<li>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</li>
<li>[<code>stop_after_n_rows</code>]: Only read specified number of rows of the dataset. After <code>n</code> stops reading.</li>
</ul>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_parquet(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from a parquet file.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_parquet(
            file, columns, projection, stop_after_n_rows
        )
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_ipc"><a class="header" href="#polarsinternalsframedataframeread_ipc"><code>polars.internals.frame.DataFrame.read_ipc</code></a></h3>
<pre><code class="language-python">read_ipc(file: Union[str, BinaryIO], 
    columns: Optionaltp.List[str], 
    projection: Optionaltp.List[int], 
    stop_after_n_rows: Optionalint,) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object.</li>
<li>[<code>columns</code>]: Columns to select.</li>
<li>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</li>
<li>[<code>stop_after_n_rows</code>]: Only read specified number of rows of the dataset. After <code>n</code> stops reading.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_ipc(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_ipc(file, columns, projection, stop_after_n_rows)
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_json"><a class="header" href="#polarsinternalsframedataframeread_json"><code>polars.internals.frame.DataFrame.read_json</code></a></h3>
<pre><code class="language-python">read_json(file: Union[str, BytesIO]) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from JSON format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object.</li>
</ul>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_json(file: Union[str, BytesIO]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from JSON format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        &quot;&quot;&quot;
        if not isinstance(file, str):
            file = file.read().decode(&quot;utf8&quot;)
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_json(file)
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_arrow"><a class="header" href="#polarsinternalsframedataframeto_arrow"><code>polars.internals.frame.DataFrame.to_arrow</code></a></h3>
<pre><code class="language-python">to_arrow() -&gt; pa.Table:
</code></pre>
<p>Collect the underlying arrow arrays in an Arrow Table.
This operation is mostly zero copy.</p>
<p>Data types that do copy:
- CategoricalType</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_arrow(self) -&gt; &quot;pa.Table&quot;:
        &quot;&quot;&quot;
        Collect the underlying arrow arrays in an Arrow Table.
        This operation is mostly zero copy.

        Data types that do copy:
            - CategoricalType
        &quot;&quot;&quot;
        if not _PYARROW_AVAILABLE:
            raise ImportError(
                &quot;'pyarrow' is required for converting a polars DataFrame to an Arrow Table.&quot;
            )
        record_batches = self._df.to_arrow()
        return pa.Table.from_batches(record_batches)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_dict"><a class="header" href="#polarsinternalsframedataframeto_dict"><code>polars.internals.frame.DataFrame.to_dict</code></a></h3>
<pre><code class="language-python">to_dict(as_series: bool,) -&gt; Union[Dict[str, pli.Series], Dict[str, tp.List[Any]]]:
</code></pre>
<p>Convert DataFrame to a dictionary mapping column name to values.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>as_series</code>]: True -&gt; Values are series
False -&gt; Values are List[Any]</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;A&quot;: [1, 2, 3, 4, 5],
&quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
&quot;B&quot;: [5, 4, 3, 2, 1],
&quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
&quot;optional&quot;: [28, 300, None, 2, -30],
})
shape: (5, 5)
┌─────┬──────────┬─────┬──────────┬──────────┐
│ A   ┆ fruits   ┆ B   ┆ cars     ┆ optional │
│ --- ┆ ---      ┆ --- ┆ ---      ┆ ---      │
│ i64 ┆ str      ┆ i64 ┆ str      ┆ i64      │
╞═════╪══════════╪═════╪══════════╪══════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 28       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 300      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ null     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ -30      │
└─────┴──────────┴─────┴──────────┴──────────┘
df.to_dict(as_series=False)
{'A': [1, 2, 3, 4, 5],
'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'],
'B': [5, 4, 3, 2, 1],
'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'],
'optional': [28, 300, None, 2, -30]}
df.to_dict(as_series=True)
{'A': shape: (5,)
Series: 'A' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>5
],
'fruits': shape: (5,)
...
Series: 'optional' [i64]
[</li>
<li></li>
<li>-30
]}</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dict(
        self, as_series: bool = True
    ) -&gt; Union[Dict[str, &quot;pli.Series&quot;], Dict[str, tp.List[Any]]]:
        &quot;&quot;&quot;
        Convert DataFrame to a dictionary mapping column name to values.

        Parameters
        ----------
        as_series
            True -&gt; Values are series
            False -&gt; Values are List[Any]

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;      &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;      &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;      &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;      &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt;      &quot;optional&quot;: [28, 300, None, 2, -30],
        &gt;&gt;&gt; })
        shape: (5, 5)
        ┌─────┬──────────┬─────┬──────────┬──────────┐
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ optional │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64      │
        ╞═════╪══════════╪═════╪══════════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 28       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 300      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ null     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ -30      │
        └─────┴──────────┴─────┴──────────┴──────────┘
        &gt;&gt;&gt; df.to_dict(as_series=False)
        {'A': [1, 2, 3, 4, 5],
        'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'],
        'B': [5, 4, 3, 2, 1],
        'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'],
        'optional': [28, 300, None, 2, -30]}
        &gt;&gt;&gt; df.to_dict(as_series=True)
        {'A': shape: (5,)
         Series: 'A' [i64]
         [
            1
            2
            3
            4
            5
         ],
         'fruits': shape: (5,)
         ...
         Series: 'optional' [i64]
         [
            28
            300
            null
            2
            -30
         ]}

        &quot;&quot;&quot;
        if as_series:
            return {s.name: s for s in self}
        else:
            return {s.name: s.to_list() for s in self}
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_json"><a class="header" href="#polarsinternalsframedataframeto_json"><code>polars.internals.frame.DataFrame.to_json</code></a></h3>
<pre><code class="language-python">to_json(file: OptionalUnion[BytesIO, str, Path], 
    pretty: bool, 
    to_string: bool,) -&gt; Optionalstr:
</code></pre>
<p>Serialize to JSON representation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Write to this file instead of returning an string.</li>
<li>[<code>pretty</code>]: Pretty serialize json.</li>
<li>[<code>to_string</code>]: Ignore file argument and return a string.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_json(
        self,
        file: Optional[Union[BytesIO, str, Path]] = None,
        pretty: bool = False,
        to_string: bool = False,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Serialize to JSON representation.

        Parameters
        ----------
        file
            Write to this file instead of returning an string.
        pretty
            Pretty serialize json.
        to_string
            Ignore file argument and return a string.
        &quot;&quot;&quot;
        if to_string or file is None:
            file = BytesIO()
            self._df.to_json(file, pretty)
            file.seek(0)
            return file.read().decode(&quot;utf8&quot;)
        else:
            self._df.to_json(file, pretty)
            return None
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_pandas"><a class="header" href="#polarsinternalsframedataframeto_pandas"><code>polars.internals.frame.DataFrame.to_pandas</code></a></h3>
<pre><code class="language-python">to_pandas(*args, **kwargs) -&gt; pd.DataFrame:
</code></pre>
<p>Cast to a Pandas DataFrame. This requires that Pandas is installed.
This operation clones data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><a href="polars/internals/frame/Arguments."><code>args</code></a>: Arguments will be sent to pyarrow.Table.to_pandas.</li>
<li>[<code>date_as_object</code>]: Cast dates to objects. If False, convert to datetime64[ns] dtype.</li>
<li>[<code>kwargs</code>]: Arguments will be sent to pyarrow.Table.to_pandas.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import pandas
df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
pandas_df = df.to_pandas()
type(pandas_df)
pandas.core.frame.DataFrame</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_pandas(
        self, *args: Any, date_as_object: bool = False, **kwargs: Any
    ) -&gt; &quot;pd.DataFrame&quot;:  # noqa: F821
        &quot;&quot;&quot;
        Cast to a Pandas DataFrame. This requires that Pandas is installed.
        This operation clones data.

        Parameters
        ----------
        args
            Arguments will be sent to pyarrow.Table.to_pandas.
        date_as_object
            Cast dates to objects. If False, convert to datetime64[ns] dtype.
        kwargs
            Arguments will be sent to pyarrow.Table.to_pandas.

        Examples
        --------

        &gt;&gt;&gt; import pandas
        &gt;&gt;&gt; df = pl.DataFrame({
            &quot;foo&quot;: [1, 2, 3],
            &quot;bar&quot;: [6, 7, 8],
            &quot;ham&quot;: ['a', 'b', 'c']
            })
        &gt;&gt;&gt; pandas_df = df.to_pandas()
        &gt;&gt;&gt; type(pandas_df)
        pandas.core.frame.DataFrame
        &quot;&quot;&quot;
        return self.to_arrow().to_pandas(*args, date_as_object=date_as_object, **kwargs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_csv"><a class="header" href="#polarsinternalsframedataframeto_csv"><code>polars.internals.frame.DataFrame.to_csv</code></a></h3>
<pre><code class="language-python">to_csv(file: OptionalUnion[TextIO, BytesIO, str, Path], 
    has_headers: bool, 
    sep: str,) -&gt; Optionalstr:
</code></pre>
<p>Write Dataframe to comma-separated values file (csv).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: File path to which the file should be written.</li>
<li>[<code>has_headers</code>]: Whether or not to include header in the CSV output.</li>
<li>[<code>sep</code>]: Separate CSV fields with this symbol.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3, 4, 5],
&quot;bar&quot;: [6, 7, 8, 9, 10],
&quot;ham&quot;: ['a', 'b', 'c', 'd','e']
})
df.to_csv('new_file.csv', sep=',')</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_csv(
        self,
        file: Optional[Union[TextIO, BytesIO, str, Path]] = None,
        has_headers: bool = True,
        sep: str = &quot;,&quot;,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Write Dataframe to comma-separated values file (csv).

        Parameters
        ---
        file
            File path to which the file should be written.
        has_headers
            Whether or not to include header in the CSV output.
        sep
            Separate CSV fields with this symbol.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_csv('new_file.csv', sep=',')

        &quot;&quot;&quot;
        if file is None:
            buffer = BytesIO()
            self._df.to_csv(buffer, has_headers, ord(sep))
            return str(buffer.getvalue(), encoding=&quot;utf-8&quot;)

        if isinstance(file, Path):
            file = str(file)

        self._df.to_csv(file, has_headers, ord(sep))
        return None
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_ipc"><a class="header" href="#polarsinternalsframedataframeto_ipc"><code>polars.internals.frame.DataFrame.to_ipc</code></a></h3>
<pre><code class="language-python">to_ipc(file: Union[BinaryIO, BytesIO, str, Path], 
    compression: str,) -&gt; None:
</code></pre>
<p>Write to Arrow IPC binary stream, or a feather file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: File path to which the file should be written.</li>
<li>[<code>compression</code>]: Compression method. Choose one of:
- &quot;uncompressed&quot;
- &quot;lz4&quot;
- &quot;zstd&quot;</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_ipc(
        self,
        file: Union[BinaryIO, BytesIO, str, Path],
        compression: str = &quot;uncompressed&quot;,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write to Arrow IPC binary stream, or a feather file.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        &quot;&quot;&quot;
        if isinstance(file, Path):
            file = str(file)

        self._df.to_ipc(file, compression)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_dicts"><a class="header" href="#polarsinternalsframedataframeto_dicts"><code>polars.internals.frame.DataFrame.to_dicts</code></a></h3>
<pre><code class="language-python">to_dicts() -&gt; tp.List[Dict[str, Any]]:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dicts(self) -&gt; tp.List[Dict[str, Any]]:
        pydf = self._df
        names = self.columns

        return [
            {k: v for k, v in zip(names, pydf.row_tuple(i))}
            for i in range(0, self.height)
        ]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframetranspose"><a class="header" href="#polarsinternalsframedataframetranspose"><code>polars.internals.frame.DataFrame.transpose</code></a></h3>
<pre><code class="language-python">transpose(include_header: bool, 
    header_name: str, 
    column_names: OptionalUnion[tp.Iteratorstr, tp.Sequencestr],) -&gt; pli.DataFrame:
</code></pre>
<p>Transpose a DataFrame over the diagonal.</p>
<p><strong>Parameters:</strong></p>
<p>include_header:
If set, the column names will be added as first column.
header_name:
If <code>include_header</code> is set, this determines the name of the column that will be inserted
column_names:
Optional generator/iterator that yields column names. Will be used to replace the columns in the DataFrame.</p>
<p><strong>Notes:</strong></p>
<p>This is a very expensive operation. Perhaps you can do it differently.</p>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [1, 2, 3]})
df.transpose(include_header=True)
shape: (2, 4)
┌────────┬──────────┬──────────┬──────────┐
│ column ┆ column_0 ┆ column_1 ┆ column_2 │
│ ---    ┆ ---      ┆ ---      ┆ ---      │
│ str    ┆ i64      ┆ i64      ┆ i64      │
╞════════╪══════════╪══════════╪══════════╡
│ a      ┆ 1        ┆ 2        ┆ 3        │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ b      ┆ 1        ┆ 2        ┆ 3        │
└────────┴──────────┴──────────┴──────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>replace:</strong>
the auto generated column names with a list
&gt;&gt;&gt; df.transpose(include_header=False, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
shape: (2, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ 2   ┆ 3   │
└─────┴─────┴─────┘</p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="include-the-header-as-a-separate-column"><a class="header" href="#include-the-header-as-a-separate-column">include the header as a separate column</a></h1>
<p>df.transpose(include_header=True, header_name=&quot;foo&quot;, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
shape: (2, 4)
┌─────┬─────┬─────┬─────┐
│ foo ┆ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╪═════╡
│ a   ┆ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ b   ┆ 1   ┆ 2   ┆ 3   │
└─────┴─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="replace-the-auto-generated-column-with-column-names-from-a-generator-function"><a class="header" href="#replace-the-auto-generated-column-with-column-names-from-a-generator-function">replace the auto generated column with column names from a generator function</a></h1>
<p>def name_generator():
base_name = &quot;my_column_&quot;
count = 0
while True:
yield f&quot;{base_name}{count}&quot;
count += 1
df.transpose(include_header=False, column_names=name_generator())
shape: (2, 3)
┌─────────────┬─────────────┬─────────────┐
│ my_column_0 ┆ my_column_1 ┆ my_column_2 │
│ ---         ┆ ---         ┆ ---         │
│ i64         ┆ i64         ┆ i64         │
╞═════════════╪═════════════╪═════════════╡
│ 1           ┆ 2           ┆ 3           │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1           ┆ 2           ┆ 3           │
└─────────────┴─────────────┴─────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def transpose(
        self,
        include_header: bool = False,
        header_name: str = &quot;column&quot;,
        column_names: Optional[Union[tp.Iterator[str], tp.Sequence[str]]] = None,
    ) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Transpose a DataFrame over the diagonal.

        Parameters
        ----------
        include_header:
            If set, the column names will be added as first column.
        header_name:
            If `include_header` is set, this determines the name of the column that will be inserted
        column_names:
            Optional generator/iterator that yields column names. Will be used to replace the columns in the DataFrame.

        Notes
        -----
        This is a very expensive operation. Perhaps you can do it differently.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [1, 2, 3]})
        &gt;&gt;&gt; df.transpose(include_header=True)
        shape: (2, 4)
        ┌────────┬──────────┬──────────┬──────────┐
        │ column ┆ column_0 ┆ column_1 ┆ column_2 │
        │ ---    ┆ ---      ┆ ---      ┆ ---      │
        │ str    ┆ i64      ┆ i64      ┆ i64      │
        ╞════════╪══════════╪══════════╪══════════╡
        │ a      ┆ 1        ┆ 2        ┆ 3        │
        ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ b      ┆ 1        ┆ 2        ┆ 3        │
        └────────┴──────────┴──────────┴──────────┘

        # replace the auto generated column names with a list
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt; # include the header as a separate column
        &gt;&gt;&gt; df.transpose(include_header=True, header_name=&quot;foo&quot;, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 4)
        ┌─────┬─────┬─────┬─────┐
        │ foo ┆ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╪═════╡
        │ a   ┆ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┴─────┘

        &gt;&gt;&gt; # replace the auto generated column with column names from a generator function
        &gt;&gt;&gt; def name_generator():
        &gt;&gt;&gt;     base_name = &quot;my_column_&quot;
        &gt;&gt;&gt;     count = 0
        &gt;&gt;&gt;     while True:
        &gt;&gt;&gt;         yield f&quot;{base_name}{count}&quot;
        &gt;&gt;&gt;         count += 1
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=name_generator())
        shape: (2, 3)
        ┌─────────────┬─────────────┬─────────────┐
        │ my_column_0 ┆ my_column_1 ┆ my_column_2 │
        │ ---         ┆ ---         ┆ ---         │
        │ i64         ┆ i64         ┆ i64         │
        ╞═════════════╪═════════════╪═════════════╡
        │ 1           ┆ 2           ┆ 3           │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 1           ┆ 2           ┆ 3           │
        └─────────────┴─────────────┴─────────────┘

        &quot;&quot;&quot;
        df = wrap_df(self._df.transpose(include_header, header_name))
        if column_names is not None:
            names = []
            n = df.width
            if include_header:
                names.append(header_name)
                n -= 1

            column_names = iter(column_names)
            for _ in range(n):
                names.append(next(column_names))
            df.columns = names
        return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_parquet"><a class="header" href="#polarsinternalsframedataframeto_parquet"><code>polars.internals.frame.DataFrame.to_parquet</code></a></h3>
<pre><code class="language-python">to_parquet(file: Union[str, Path, BytesIO], 
    compression: Optionalstr, 
    use_pyarrow: bool, 
    **kwargs,) -&gt; None:
</code></pre>
<p>Write the DataFrame disk in parquet format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: File path to which the file should be written.</li>
<li>[<code>compression</code>]: Compression method. Choose one of:
- &quot;uncompressed&quot; (not supported by pyarrow)
- &quot;snappy&quot;
- &quot;gzip&quot;
- &quot;lzo&quot;
- &quot;brotli&quot;
- &quot;lz4&quot;
- &quot;zstd&quot;</li>
<li>[<code>use_pyarrow</code>]: Use C++ parquet implementation vs rust parquet implementation.
At the moment C++ supports more features.</li>
</ul>
<p>**kwargs are passed to pyarrow.parquet.write_table</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_parquet(
        self,
        file: Union[str, Path, BytesIO],
        compression: Optional[str] = &quot;snappy&quot;,
        use_pyarrow: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write the DataFrame disk in parquet format.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot; (not supported by pyarrow)
                - &quot;snappy&quot;
                - &quot;gzip&quot;
                - &quot;lzo&quot;
                - &quot;brotli&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        use_pyarrow
            Use C++ parquet implementation vs rust parquet implementation.
            At the moment C++ supports more features.

        **kwargs are passed to pyarrow.parquet.write_table
        &quot;&quot;&quot;
        if compression is None:
            compression = &quot;uncompressed&quot;
        if isinstance(file, Path):
            file = str(file)

        if use_pyarrow:
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required when using 'to_parquet(..., use_pyarrow=True)'.&quot;
                )

            tbl = self.to_arrow()

            data = {}

            for i, column in enumerate(tbl):
                # extract the name before casting
                if column._name is None:
                    name = f&quot;column_{i}&quot;
                else:
                    name = column._name

                data[name] = column
            tbl = pa.table(data)

            pa.parquet.write_table(
                table=tbl, where=file, compression=compression, **kwargs
            )
        else:
            self._df.to_parquet(file, compression)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_numpy"><a class="header" href="#polarsinternalsframedataframeto_numpy"><code>polars.internals.frame.DataFrame.to_numpy</code></a></h3>
<pre><code class="language-python">to_numpy() -&gt; np.ndarray:
</code></pre>
<p>Convert DataFrame to a 2d numpy array.
This operation clones data.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
numpy_array = df.to_numpy()
type(numpy_array)
numpy.ndarray</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_numpy(self) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert DataFrame to a 2d numpy array.
        This operation clones data.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; numpy_array = df.to_numpy()
        &gt;&gt;&gt; type(numpy_array)
        numpy.ndarray

        &quot;&quot;&quot;
        return np.vstack([self.to_series(i).to_numpy() for i in range(self.width)]).T
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefind_idx_by_name"><a class="header" href="#polarsinternalsframedataframefind_idx_by_name"><code>polars.internals.frame.DataFrame.find_idx_by_name</code></a></h3>
<pre><code class="language-python">find_idx_by_name(name: str) -&gt; int:
</code></pre>
<p>Find the index of a column by name.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Name of the column to find.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.find_idx_by_name(&quot;ham&quot;))
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def find_idx_by_name(self, name: str) -&gt; int:
        &quot;&quot;&quot;
        Find the index of a column by name.

        Parameters
        ----------
        name
            Name of the column to find.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.find_idx_by_name(&quot;ham&quot;))
        2

        &quot;&quot;&quot;
        return self._df.find_idx_by_name(name)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_series"><a class="header" href="#polarsinternalsframedataframeto_series"><code>polars.internals.frame.DataFrame.to_series</code></a></h3>
<pre><code class="language-python">to_series(index: int) -&gt; pli.Series:
</code></pre>
<p>Select column as Series at index location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Location of selection.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.to_series(1))
shape: (3,)
Series: 'bar' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  8
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_series(self, index: int = 0) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column as Series at index location.

        Parameters
        ----------
        index
            Location of selection.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_series(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(index))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerename"><a class="header" href="#polarsinternalsframedataframerename"><code>polars.internals.frame.DataFrame.rename</code></a></h3>
<pre><code class="language-python">rename(mapping: Dict[str, str]) -&gt; DataFrame:
</code></pre>
<p>Rename column names.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mapping</code>]: Key value pairs that map from old name to new name.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.rename({&quot;foo&quot;: &quot;apple&quot;})
╭───────┬─────┬─────╮
│ apple ┆ bar ┆ ham │
│ ---   ┆ --- ┆ --- │
│ i64   ┆ i64 ┆ str │
╞═══════╪═════╪═════╡
│ 1     ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2     ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3     ┆ 8   ┆ &quot;c&quot; │
╰───────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rename(self, mapping: Dict[str, str]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rename column names.

        Parameters
        ----------
        mapping
            Key value pairs that map from old name to new name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df.rename({&quot;foo&quot;: &quot;apple&quot;})
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 1     ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2     ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3     ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        df = self.clone()
        for k, v in mapping.items():
            df._df.rename(k, v)
        return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeinsert_at_idx"><a class="header" href="#polarsinternalsframedataframeinsert_at_idx"><code>polars.internals.frame.DataFrame.insert_at_idx</code></a></h3>
<pre><code class="language-python">insert_at_idx(index: int, series: pli.Series) -&gt; None:
</code></pre>
<p>Insert a Series at a certain column index. This operation is in place.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Column to insert the new <code>Series</code> column.</li>
<li>[<code>series</code>]: <code>Series</code> to insert.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def insert_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Insert a Series at a certain column index. This operation is in place.

        Parameters
        ----------
        index
            Column to insert the new `Series` column.
        series
            `Series` to insert.
        &quot;&quot;&quot;
        self._df.insert_at_idx(index, series._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefilter"><a class="header" href="#polarsinternalsframedataframefilter"><code>polars.internals.frame.DataFrame.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: pli.Expr) -&gt; DataFrame:
</code></pre>
<p>Filter the rows in the DataFrame based on a predicate expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Expression that evaluates to a boolean Series.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})</p>
<h1 id="filter-on-one-condition"><a class="header" href="#filter-on-one-condition">Filter on one condition</a></h1>
<p>df.filter(pl.col(&quot;foo&quot;) &lt; 3)
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ b   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="filter-on-multiple-conditions"><a class="header" href="#filter-on-multiple-conditions">Filter on multiple conditions</a></h1>
<p>df.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;))
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: &quot;pli.Expr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Filter the rows in the DataFrame based on a predicate expression.

        Parameters
        ----------
        predicate
            Expression that evaluates to a boolean Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; # Filter on one condition
        &gt;&gt;&gt; df.filter(pl.col(&quot;foo&quot;) &lt; 3)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ b   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt;  # Filter on multiple conditions
        &gt;&gt;&gt; df.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;))
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .filter(predicate)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshape"><a class="header" href="#polarsinternalsframedataframeshape"><code>polars.internals.frame.DataFrame.shape</code></a></h3>
<pre><code class="language-python">shape() -&gt; Tuple[int, int]:
</code></pre>
<p>Get the shape of the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
df.shape
shape: (5, 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shape(self) -&gt; Tuple[int, int]:
        &quot;&quot;&quot;
        Get the shape of the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.shape
        shape: (5, 1)

        &quot;&quot;&quot;
        return self._df.shape()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeheight"><a class="header" href="#polarsinternalsframedataframeheight"><code>polars.internals.frame.DataFrame.height</code></a></h3>
<pre><code class="language-python">height() -&gt; int:
</code></pre>
<p>Get the height of the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
df.height
5</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def height(self) -&gt; int:
        &quot;&quot;&quot;
        Get the height of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.height
        5

        &quot;&quot;&quot;
        return self._df.height()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewidth"><a class="header" href="#polarsinternalsframedataframewidth"><code>polars.internals.frame.DataFrame.width</code></a></h3>
<pre><code class="language-python">width() -&gt; int:
</code></pre>
<p>Get the width of the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
df.width
1</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def width(self) -&gt; int:
        &quot;&quot;&quot;
        Get the width of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.width
        1
        &quot;&quot;&quot;
        return self._df.width()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframecolumns"><a class="header" href="#polarsinternalsframedataframecolumns"><code>polars.internals.frame.DataFrame.columns</code></a></h3>
<pre><code class="language-python">columns(columns: Sequencestr) -&gt; None:
</code></pre>
<p>Change the column names of the <code>DataFrame</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: A list with new names for the <code>DataFrame</code>.
The length of the list should be equal to the width of the <code>DataFrame</code>.</li>
</ul>
<p><strong>Decoration</strong> via <code>@columns.setter</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def columns(self, columns: Sequence[str]) -&gt; None:
        &quot;&quot;&quot;
        Change the column names of the `DataFrame`.

        Parameters
        ----------
        columns
            A list with new names for the `DataFrame`.
            The length of the list should be equal to the width of the `DataFrame`.
        &quot;&quot;&quot;
        self._df.set_column_names(columns)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedtypes"><a class="header" href="#polarsinternalsframedataframedtypes"><code>polars.internals.frame.DataFrame.dtypes</code></a></h3>
<pre><code class="language-python">dtypes() -&gt; tp.List[TypeDataType]:
</code></pre>
<p>Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.dtypes
[polars.datatypes.Int64, polars.datatypes.Float64, polars.datatypes.Utf8]
df
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dtypes(self) -&gt; tp.List[Type[DataType]]:
        &quot;&quot;&quot;
        Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.dtypes
        [polars.datatypes.Int64, polars.datatypes.Float64, polars.datatypes.Utf8]
        &gt;&gt;&gt; df
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return [DTYPES[idx] for idx in self._df.dtypes()]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedescribe"><a class="header" href="#polarsinternalsframedataframedescribe"><code>polars.internals.frame.DataFrame.describe</code></a></h3>
<pre><code class="language-python">describe() -&gt; DataFrame:
</code></pre>
<p>Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
'a': [1.0, 2.8, 3.0],
'b': [4, 5, 6],
&quot;c&quot;: [True, False, True]
})
df.describe()
shape: (5, 4)
╭──────────┬───────┬─────┬──────╮
│ describe ┆ a     ┆ b   ┆ c    │
│ ---      ┆ ---   ┆ --- ┆ ---  │
│ str      ┆ f64   ┆ f64 ┆ f64  │
╞══════════╪═══════╪═════╪══════╡
│ &quot;mean&quot;   ┆ 2.267 ┆ 5   ┆ null │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;std&quot;    ┆ 1.102 ┆ 1   ┆ null │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;min&quot;    ┆ 1     ┆ 4   ┆ 0.0  │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;max&quot;    ┆ 3     ┆ 6   ┆ 1    │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;median&quot; ┆ 2.8   ┆ 5   ┆ null │
╰──────────┴───────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     'a': [1.0, 2.8, 3.0],
        &gt;&gt;&gt;     'b': [4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [True, False, True]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.describe()
        shape: (5, 4)
        ╭──────────┬───────┬─────┬──────╮
        │ describe ┆ a     ┆ b   ┆ c    │
        │ ---      ┆ ---   ┆ --- ┆ ---  │
        │ str      ┆ f64   ┆ f64 ┆ f64  │
        ╞══════════╪═══════╪═════╪══════╡
        │ &quot;mean&quot;   ┆ 2.267 ┆ 5   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;std&quot;    ┆ 1.102 ┆ 1   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;min&quot;    ┆ 1     ┆ 4   ┆ 0.0  │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;max&quot;    ┆ 3     ┆ 6   ┆ 1    │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;median&quot; ┆ 2.8   ┆ 5   ┆ null │
        ╰──────────┴───────┴─────┴──────╯

        &quot;&quot;&quot;

        def describe_cast(self: &quot;DataFrame&quot;) -&gt; &quot;DataFrame&quot;:
            columns = []
            for s in self:
                if s.is_numeric() or s.is_boolean():
                    columns.append(s.cast(float))
                else:
                    columns.append(s)
            return DataFrame(columns)

        summary = pli.concat(
            [
                describe_cast(self.mean()),  # type: ignore
                describe_cast(self.std()),
                describe_cast(self.min()),  # type: ignore
                describe_cast(self.max()),  # type: ignore
                describe_cast(self.median()),
            ]
        )
        summary.insert_at_idx(  # type: ignore
            0, pli.Series(&quot;describe&quot;, [&quot;mean&quot;, &quot;std&quot;, &quot;min&quot;, &quot;max&quot;, &quot;median&quot;])
        )
        return summary  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedescribedescribe_cast"><a class="header" href="#polarsinternalsframedataframedescribedescribe_cast"><code>polars.internals.frame.DataFrame.describe.describe_cast</code></a></h3>
<pre><code class="language-python">describe_cast(: DataFrame) -&gt; DataFrame:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def describe_cast(self: &quot;DataFrame&quot;) -&gt; &quot;DataFrame&quot;:
            columns = []
            for s in self:
                if s.is_numeric() or s.is_boolean():
                    columns.append(s.cast(float))
                else:
                    columns.append(s)
            return DataFrame(columns)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframereplace_at_idx"><a class="header" href="#polarsinternalsframedataframereplace_at_idx"><code>polars.internals.frame.DataFrame.replace_at_idx</code></a></h3>
<pre><code class="language-python">replace_at_idx(index: int, series: pli.Series) -&gt; None:
</code></pre>
<p>Replace a column at an index location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Column index.</li>
<li>[<code>series</code>]: Series that will replace the column.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
x = pl.Series(&quot;apple&quot;, [10, 20, 30])
df.replace_at_idx(0, x)
shape: (3, 3)
╭───────┬─────┬─────╮
│ apple ┆ bar ┆ ham │
│ ---   ┆ --- ┆ --- │
│ i64   ┆ i64 ┆ str │
╞═══════╪═════╪═════╡
│ 10    ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 20    ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 30    ┆ 8   ┆ &quot;c&quot; │
╰───────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column at an index location.

        Parameters
        ----------
        index
            Column index.
        series
            Series that will replace the column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.replace_at_idx(0, x)
        shape: (3, 3)
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 10    ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 20    ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 30    ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        self._df.replace_at_idx(index, series._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframesort"><a class="header" href="#polarsinternalsframedataframesort"><code>polars.internals.frame.DataFrame.sort</code></a></h3>
<pre><code class="language-python">sort(by: Union[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    reverse: Union[bool, tp.List[bool]], 
    in_place: bool,) -&gt; DataFrame:
</code></pre>
<p>Sort the DataFrame by column.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: By which column to sort. Only accepts string.</li>
<li>[<code>reverse</code>]: Reverse/descending sort.</li>
<li>[<code>in_place</code>]: Perform operation in-place.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.sort('foo', reverse=True)
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 3   ┆ 8   ┆ &quot;c&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ 6   ┆ &quot;a&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Sort by multiple columns.</strong>
For multiple columns we can also use expression syntax.</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.sort([pl.col(&quot;foo&quot;), pl.col(&quot;bar&quot;) ** 2], reverse=[True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(
        self,
        by: Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]],
        reverse: Union[bool, tp.List[bool]] = False,
        in_place: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sort the DataFrame by column.

        Parameters
        ----------
        by
            By which column to sort. Only accepts string.
        reverse
            Reverse/descending sort.
        in_place
            Perform operation in-place.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sort('foo', reverse=True)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ╰─────┴─────┴─────╯

        **Sort by multiple columns.**
        For multiple columns we can also use expression syntax.

        &gt;&gt;&gt; df.sort([pl.col(&quot;foo&quot;), pl.col(&quot;bar&quot;) ** 2], reverse=[True, False])

        &quot;&quot;&quot;
        if type(by) is list or isinstance(by, pli.Expr):
            df = (
                self.lazy()
                .sort(by, reverse)
                .collect(no_optimization=True, string_cache=False)
            )
            if in_place:
                self._df = df._df
                return self
            return df
        if in_place:
            self._df.sort_in_place(by, reverse)
            return self
        else:
            return wrap_df(self._df.sort(by, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeframe_equal"><a class="header" href="#polarsinternalsframedataframeframe_equal"><code>polars.internals.frame.DataFrame.frame_equal</code></a></h3>
<pre><code class="language-python">frame_equal(other: DataFrame, 
    null_equal: bool,) -&gt; bool:
</code></pre>
<p>Check if DataFrame is equal to other.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: DataFrame to compare with.</li>
<li>[<code>null_equal</code>]: Consider null values as equal.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df1 = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df2 = pl.DataFrame({
&quot;foo&quot;: [3, 2, 1],
&quot;bar&quot;: [8.0, 7.0, 6.0],
&quot;ham&quot;: ['c', 'b', 'a']
})
df1.frame_equal(df1)
True
df1.frame_equal(df2)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def frame_equal(self, other: &quot;DataFrame&quot;, null_equal: bool = True) -&gt; bool:
        &quot;&quot;&quot;
        Check if DataFrame is equal to other.

        Parameters
        ----------
        other
            DataFrame to compare with.
        null_equal
            Consider null values as equal.

        Examples
        --------
        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 2, 1],
        &gt;&gt;&gt;     &quot;bar&quot;: [8.0, 7.0, 6.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'b', 'a']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.frame_equal(df1)
        True
        &gt;&gt;&gt; df1.frame_equal(df2)
        False

        &quot;&quot;&quot;
        return self._df.frame_equal(other._df, null_equal)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframereplace"><a class="header" href="#polarsinternalsframedataframereplace"><code>polars.internals.frame.DataFrame.replace</code></a></h3>
<pre><code class="language-python">replace(column: str, new_col: pli.Series) -&gt; None:
</code></pre>
<p>Replace a column by a new Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Column to replace.</li>
<li>[<code>new_col</code>]: New column to insert.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace(self, column: str, new_col: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column by a new Series.

        Parameters
        ----------
        column
            Column to replace.
        new_col
            New column to insert.
        &quot;&quot;&quot;
        self._df.replace(column, new_col.inner())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeslice"><a class="header" href="#polarsinternalsframedataframeslice"><code>polars.internals.frame.DataFrame.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; DataFrame:
</code></pre>
<p>Slice this DataFrame over the rows direction.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Offset index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.slice(1, 2)
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Slice this DataFrame over the rows direction.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.slice(1, 2)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        if length &lt; 0:
            length = self.height - offset + length
        return wrap_df(self._df.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframelimit"><a class="header" href="#polarsinternalsframedataframelimit"><code>polars.internals.frame.DataFrame.limit</code></a></h3>
<pre><code class="language-python">limit(length: int) -&gt; DataFrame:
</code></pre>
<p>Get first N rows as DataFrame.</p>
<p>See Also <code>DataFrame.head</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Amount of rows to take.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.limit(2)
shape: (2, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def limit(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        See Also `DataFrame.head`

        Parameters
        ----------
        length
            Amount of rows to take.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.limit(2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return self.head(length)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframehead"><a class="header" href="#polarsinternalsframedataframehead"><code>polars.internals.frame.DataFrame.head</code></a></h3>
<pre><code class="language-python">head(length: int) -&gt; DataFrame:
</code></pre>
<p>Get first N rows as DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the head.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3, 4, 5],
&quot;bar&quot;: [6, 7, 8, 9, 10],
&quot;ham&quot;: ['a', 'b', 'c', 'd','e']
})
df.head(3)
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.head(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.head(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframetail"><a class="header" href="#polarsinternalsframedataframetail"><code>polars.internals.frame.DataFrame.tail</code></a></h3>
<pre><code class="language-python">tail(length: int) -&gt; DataFrame:
</code></pre>
<p>Get last N rows as DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the tail.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3, 4, 5],
&quot;bar&quot;: [6, 7, 8, 9, 10],
&quot;ham&quot;: ['a', 'b', 'c', 'd','e']
})
df.tail(3)
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 3   ┆ 8   ┆ &quot;c&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 9   ┆ &quot;d&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 5   ┆ 10  ┆ &quot;e&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get last N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.tail(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 5   ┆ 10  ┆ &quot;e&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.tail(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop_nulls"><a class="header" href="#polarsinternalsframedataframedrop_nulls"><code>polars.internals.frame.DataFrame.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls(subset: Optionaltp.List[str]) -&gt; DataFrame:
</code></pre>
<p>Return a new DataFrame where the null values are dropped.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, None, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.drop_nulls()
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>This method only drops nulls row-wise if any single value of the row is null.</p>
<p>Below are some example snippets that show how you could drop null values based on other
conditions</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;a&quot;: [None, None, None, None],
&quot;b&quot;: [1, 2, None, 1],
&quot;c&quot;: [1, None, None, 1],
}
)
df
shape: (4, 3)
┌──────┬──────┬──────┐
│ a    ┆ b    ┆ c    │
│ ---  ┆ ---  ┆ ---  │
│ f64  ┆ i64  ┆ i64  │
╞══════╪══════╪══════╡
│ null ┆ 1    ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 2    ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 1    ┆ 1    │
└──────┴──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="drop-a-row-only-if-all-values-are-null"><a class="header" href="#drop-a-row-only-if-all-values-are-null">drop a row only if all values are null</a></h1>
<p>df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
shape: (3, 3)
┌──────┬─────┬──────┐
│ a    ┆ b   ┆ c    │
│ ---  ┆ --- ┆ ---  │
│ f64  ┆ i64 ┆ i64  │
╞══════╪═════╪══════╡
│ null ┆ 1   ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 2   ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 1   ┆ 1    │
└──────┴─────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="drop-a-column-if-all-values-are-null"><a class="header" href="#drop-a-column-if-all-values-are-null">drop a column if all values are null</a></h1>
<p>df[:, [not (s.null_count() == df.height) for s in df]]
shape: (4, 2)
┌──────┬──────┐
│ b    ┆ c    │
│ ---  ┆ ---  │
│ i64  ┆ i64  │
╞══════╪══════╡
│ 1    ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 1    ┆ 1    │
└──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self, subset: Optional[tp.List[str]] = None) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame where the null values are dropped.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, None, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.drop_nulls()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        This method only drops nulls row-wise if any single value of the row is null.

        Below are some example snippets that show how you could drop null values based on other
        conditions

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {
        &gt;&gt;&gt;        &quot;a&quot;: [None, None, None, None],
        &gt;&gt;&gt;        &quot;b&quot;: [1, 2, None, 1],
        &gt;&gt;&gt;        &quot;c&quot;: [1, None, None, 1],
        &gt;&gt;&gt;    }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df
        shape: (4, 3)
        ┌──────┬──────┬──────┐
        │ a    ┆ b    ┆ c    │
        │ ---  ┆ ---  ┆ ---  │
        │ f64  ┆ i64  ┆ i64  │
        ╞══════╪══════╪══════╡
        │ null ┆ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1    ┆ 1    │
        └──────┴──────┴──────┘

        &gt;&gt;&gt; # drop a row only if all values are null
        &gt;&gt;&gt; df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
        shape: (3, 3)
        ┌──────┬─────┬──────┐
        │ a    ┆ b   ┆ c    │
        │ ---  ┆ --- ┆ ---  │
        │ f64  ┆ i64 ┆ i64  │
        ╞══════╪═════╪══════╡
        │ null ┆ 1   ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2   ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1   ┆ 1    │
        └──────┴─────┴──────┘

        &gt;&gt;&gt; # drop a column if all values are null
        &gt;&gt;&gt; df[:, [not (s.null_count() == df.height) for s in df]]
        shape: (4, 2)
        ┌──────┬──────┐
        │ b    ┆ c    │
        │ ---  ┆ ---  │
        │ i64  ┆ i64  │
        ╞══════╪══════╡
        │ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 1    │
        └──────┴──────┘

        &quot;&quot;&quot;
        if subset is not None and isinstance(subset, str):
            subset = [subset]
        return wrap_df(self._df.drop_nulls(subset))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframepipe"><a class="header" href="#polarsinternalsframedataframepipe"><code>polars.internals.frame.DataFrame.pipe</code></a></h3>
<pre><code class="language-python">pipe(func: Callable[, Any], *args, **kwargs) -&gt; Any:
</code></pre>
<p>Apply a function on Self.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li></li>
<li></li>
<li>[<code>kwargs</code>]: Keyword arguments.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:
        &quot;&quot;&quot;
        Apply a function on Self.

        Parameters
        ----------
        func
            Callable.
        args
            Arguments.
        kwargs
            Keyword arguments.
        &quot;&quot;&quot;
        return func(self, *args, **kwargs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_row_count"><a class="header" href="#polarsinternalsframedataframewith_row_count"><code>polars.internals.frame.DataFrame.with_row_count</code></a></h3>
<pre><code class="language-python">with_row_count(name: str) -&gt; DataFrame:
</code></pre>
<p>Add a column at index 0 that counts the rows.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Name of the column to add.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_row_count(self, name: str = &quot;row_nr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add a column at index 0 that counts the rows.

        Parameters
        ----------
        name
            Name of the column to add.
        &quot;&quot;&quot;
        return wrap_df(self._df.with_row_count(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframegroupby"><a class="header" href="#polarsinternalsframedataframegroupby"><code>polars.internals.frame.DataFrame.groupby</code></a></h3>
<pre><code class="language-python">groupby(by: Union[str, pli.Expr, Sequencestr, Sequencepli.Expr], 
    maintain_order: bool,) -&gt; GroupBy:
</code></pre>
<p>Start a groupby operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Column(s) to group by.</li>
<li>[<code>maintain_order</code>]: Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
Note that this only works in expression aggregations.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Below we group by column <code>&quot;a&quot;</code>, and we sum column <code>&quot;b&quot;</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;],
&quot;b&quot;: [1, 2, 3, 4, 5, 6],
&quot;c&quot;: [6, 5, 4, 3, 2, 1],
})
assert (
df.groupby(&quot;a&quot;)[&quot;b&quot;]
.sum()
.sort(by_column=&quot;a&quot;)
.frame_equal(DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;: [4, 11, 6]})))</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can also loop over the grouped <code>DataFrame</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>for sub_df in df.groupby(&quot;a&quot;):
print(sub_df)
shape: (3, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ &quot;b&quot; ┆ 2   ┆ 5   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot; ┆ 4   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot; ┆ 5   ┆ 2   │
╰─────┴─────┴─────╯
shape: (1, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ &quot;c&quot; ┆ 6   ┆ 1   │
╰─────┴─────┴─────╯
shape: (2, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ &quot;a&quot; ┆ 1   ┆ 6   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot; ┆ 3   ┆ 4   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def groupby(
        self,
        by: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]],
        maintain_order: bool = False,
    ) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a groupby operation.

        Parameters
        ----------
        by
            Column(s) to group by.
        maintain_order
            Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
            Note that this only works in expression aggregations.

        Examples
        --------
        Below we group by column `&quot;a&quot;`, and we sum column `&quot;b&quot;`.

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;],
        &gt;&gt;&gt;     &quot;b&quot;: [1, 2, 3, 4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [6, 5, 4, 3, 2, 1],
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; assert (
        &gt;&gt;&gt;     df.groupby(&quot;a&quot;)[&quot;b&quot;]
        &gt;&gt;&gt;     .sum()
        &gt;&gt;&gt;     .sort(by_column=&quot;a&quot;)
        &gt;&gt;&gt;     .frame_equal(DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;: [4, 11, 6]})))

        We can also loop over the grouped `DataFrame`

        &gt;&gt;&gt; for sub_df in df.groupby(&quot;a&quot;):
        &gt;&gt;&gt;    print(sub_df)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;b&quot; ┆ 2   ┆ 5   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 4   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 5   ┆ 2   │
        ╰─────┴─────┴─────╯
        shape: (1, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;c&quot; ┆ 6   ┆ 1   │
        ╰─────┴─────┴─────╯
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;a&quot; ┆ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot; ┆ 3   ┆ 4   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(by, str):
            by = [by]
        return GroupBy(
            self._df, by, maintain_order=maintain_order, downsample=False  # type: ignore
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedownsample"><a class="header" href="#polarsinternalsframedataframedownsample"><code>polars.internals.frame.DataFrame.downsample</code></a></h3>
<pre><code class="language-python">downsample(by: Union[str, tp.List[str]], 
    rule: str, 
    n: int,) -&gt; GroupBy:
</code></pre>
<p>Start a downsampling groupby operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>by</code>]: Column that will be used as key in the groupby operation.
This should be a datetime/date column.</p>
</li>
<li>
<p>[<code>rule</code>]: Units of the downscaling operation.</p>
<p>Any of:
- &quot;month&quot;
- &quot;week&quot;
- &quot;day&quot;
- &quot;hour&quot;
- &quot;minute&quot;
- &quot;second&quot;</p>
</li>
<li>
<p>[<code>n</code>]: Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.</p>
</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-02&quot;, &quot;2020-01-03&quot;,&quot;2020-01-04&quot;,&quot;2020-01-05&quot;,&quot;2020-01-06&quot;],
&quot;B&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0],
&quot;C&quot;: [3.0, 6.0, 9.0, 2.0, 13.0, 8.0],
&quot;D&quot;: [12.0, 5.0, 9.0, 2.0, 11.0, 2.0],
}
)
df['A'] = df['A'].str.strptime(pl.Date, &quot;%Y-%m-%d&quot;)</p>
<p>df.downsample(&quot;A&quot;, rule=&quot;day&quot;, n=3).agg(
{
&quot;B&quot;: &quot;max&quot;,
&quot;C&quot;: &quot;min&quot;,
&quot;D&quot;: &quot;last&quot;
}
)
shape: (3, 4)
┌──────────────┬───────┬───────┬────────┐
│ A            ┆ B_max ┆ C_min ┆ D_last │
│ ---          ┆ ---   ┆ ---   ┆ ---    │
│ date(days)   ┆ f64   ┆ f64   ┆ f64    │
╞══════════════╪═══════╪═══════╪════════╡
│ 2019-12-31   ┆ 8     ┆ 3     ┆ 5      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2020-01-03   ┆ 16    ┆ 2     ┆ 11     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2020-01-06   ┆ 10    ┆ 8     ┆ 2      │
└──────────────┴───────┴───────┴────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def downsample(self, by: Union[str, tp.List[str]], rule: str, n: int) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a downsampling groupby operation.

        Parameters
        ----------
        by
            Column that will be used as key in the groupby operation.
            This should be a datetime/date column.
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-02&quot;, &quot;2020-01-03&quot;,&quot;2020-01-04&quot;,&quot;2020-01-05&quot;,&quot;2020-01-06&quot;],
        &gt;&gt;&gt;         &quot;B&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0],
        &gt;&gt;&gt;         &quot;C&quot;: [3.0, 6.0, 9.0, 2.0, 13.0, 8.0],
        &gt;&gt;&gt;         &quot;D&quot;: [12.0, 5.0, 9.0, 2.0, 11.0, 2.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df['A'] = df['A'].str.strptime(pl.Date, &quot;%Y-%m-%d&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; df.downsample(&quot;A&quot;, rule=&quot;day&quot;, n=3).agg(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;B&quot;: &quot;max&quot;,
        &gt;&gt;&gt;         &quot;C&quot;: &quot;min&quot;,
        &gt;&gt;&gt;         &quot;D&quot;: &quot;last&quot;
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        shape: (3, 4)
        ┌──────────────┬───────┬───────┬────────┐
        │ A            ┆ B_max ┆ C_min ┆ D_last │
        │ ---          ┆ ---   ┆ ---   ┆ ---    │
        │ date(days)   ┆ f64   ┆ f64   ┆ f64    │
        ╞══════════════╪═══════╪═══════╪════════╡
        │ 2019-12-31   ┆ 8     ┆ 3     ┆ 5      │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-03   ┆ 16    ┆ 2     ┆ 11     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-06   ┆ 10    ┆ 8     ┆ 2      │
        └──────────────┴───────┴───────┴────────┘

        &quot;&quot;&quot;
        return GroupBy(
            self._df,
            by,
            maintain_order=False,
            downsample=True,
            rule=rule,
            downsample_n=n,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeupsample"><a class="header" href="#polarsinternalsframedataframeupsample"><code>polars.internals.frame.DataFrame.upsample</code></a></h3>
<pre><code class="language-python">upsample(by: str, interval: timedelta) -&gt; DataFrame:
</code></pre>
<p>Upsample a DataFrame at a regular frequency.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Column that will be used as key in the upsampling operation.
This should be a datetime column.</li>
<li>[<code>interval</code>]: Interval periods.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def upsample(self, by: str, interval: timedelta) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Upsample a DataFrame at a regular frequency.

        Parameters
        ----------
        by
            Column that will be used as key in the upsampling operation.
            This should be a datetime column.
        interval
            Interval periods.
        &quot;&quot;&quot;
        if self[by].dtype != Datetime:
            raise ValueError(
                f&quot;Column {by} should be of type datetime. Got {self[by].dtype}&quot;
            )
        bounds = self.select(
            [pli.col(by).min().alias(&quot;low&quot;), pli.col(by).max().alias(&quot;high&quot;)]
        )
        low = bounds[&quot;low&quot;].dt[0]
        high = bounds[&quot;high&quot;].dt[0]
        upsampled = pli.date_range(low, high, interval, name=by)
        return DataFrame(upsampled).join(self, on=by, how=&quot;left&quot;)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframejoin"><a class="header" href="#polarsinternalsframedataframejoin"><code>polars.internals.frame.DataFrame.join</code></a></h3>
<pre><code class="language-python">join(df: DataFrame, 
    left_on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    right_on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    on: OptionalUnion[str, tp.List[str]], 
    how: str, 
    suffix: str, 
    asof_by: OptionalUnion[str, tp.List[str]], 
    asof_by_left: OptionalUnion[str, tp.List[str]], 
    asof_by_right: OptionalUnion[str, tp.List[str]],) -&gt; DataFrame:
</code></pre>
<p>SQL like joins.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>df</code>]: DataFrame to join with.</p>
</li>
<li>
<p>[<code>left_on</code>]: Name(s) of the left join column(s).</p>
</li>
<li>
<p>[<code>right_on</code>]: Name(s) of the right join column(s).</p>
</li>
<li>
<p>[<code>on</code>]: Name(s) of the join columns in both DataFrames.</p>
</li>
<li>
<p>[<code>how</code>]: Join strategy
- &quot;inner&quot;
- &quot;left&quot;
- &quot;outer&quot;
- &quot;asof&quot;
- &quot;cross&quot;</p>
</li>
<li>
<p>[<code>suffix</code>]: Suffix to append to columns with a duplicate name.</p>
</li>
<li>
<p>[<code>asof_by</code>]: join on these columns before doing asof join</p>
</li>
<li>
<p>[<code>asof_by_left</code>]: join on these columns before doing asof join</p>
</li>
<li>
<p>[<code>asof_by_right</code>]: join on these columns before doing asof join
<strong>Returns:</strong></p>
<p>Joined DataFrame</p>
</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
other_df = pl.DataFrame({
&quot;apple&quot;: ['x', 'y', 'z'],
&quot;ham&quot;: ['a', 'b', 'd']
})
df.join(other_df, on='ham')
shape: (2, 4)
╭─────┬─────┬─────┬───────╮
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ str ┆ str   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6   ┆ &quot;a&quot; ┆ &quot;x&quot;   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; ┆ &quot;y&quot;   │
╰─────┴─────┴─────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>df.join(other_df, on='ham', how='outer')
shape: (4, 4)
╭──────┬──────┬─────┬───────╮
│ foo  ┆ bar  ┆ ham ┆ apple │
│ ---  ┆ ---  ┆ --- ┆ ---   │
│ i64  ┆ f64  ┆ str ┆ str   │
╞══════╪══════╪═════╪═══════╡
│ 1    ┆ 6    ┆ &quot;a&quot; ┆ &quot;x&quot;   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2    ┆ 7    ┆ &quot;b&quot; ┆ &quot;y&quot;   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ null ┆ null ┆ &quot;d&quot; ┆ &quot;z&quot;   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3    ┆ 8    ┆ &quot;c&quot; ┆ null  │
╰──────┴──────┴─────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="asof-join"><a class="header" href="#asof-join">Asof join</a></h1>
<p>This is similar to a left-join except that we match on nearest key rather than equal keys.
The keys must be sorted to perform an asof join</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def join(
        self,
        df: &quot;DataFrame&quot;,
        left_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        right_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        on: Optional[Union[str, tp.List[str]]] = None,
        how: str = &quot;inner&quot;,
        suffix: str = &quot;_right&quot;,
        asof_by: Optional[Union[str, tp.List[str]]] = None,
        asof_by_left: Optional[Union[str, tp.List[str]]] = None,
        asof_by_right: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        SQL like joins.

        Parameters
        ----------
        df
            DataFrame to join with.
        left_on
            Name(s) of the left join column(s).
        right_on
            Name(s) of the right join column(s).
        on
            Name(s) of the join columns in both DataFrames.
        how
            Join strategy
                - &quot;inner&quot;
                - &quot;left&quot;
                - &quot;outer&quot;
                - &quot;asof&quot;
                - &quot;cross&quot;
        suffix
            Suffix to append to columns with a duplicate name.
        asof_by
            join on these columns before doing asof join
        asof_by_left
            join on these columns before doing asof join
        asof_by_right
            join on these columns before doing asof join
        Returns
        -------
            Joined DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; other_df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;apple&quot;: ['x', 'y', 'z'],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.join(other_df, on='ham')
        shape: (2, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ f64 ┆ str ┆ str   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ╰─────┴─────┴─────┴───────╯

        &gt;&gt;&gt; df.join(other_df, on='ham', how='outer')
        shape: (4, 4)
        ╭──────┬──────┬─────┬───────╮
        │ foo  ┆ bar  ┆ ham ┆ apple │
        │ ---  ┆ ---  ┆ --- ┆ ---   │
        │ i64  ┆ f64  ┆ str ┆ str   │
        ╞══════╪══════╪═════╪═══════╡
        │ 1    ┆ 6    ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ null ┆ null ┆ &quot;d&quot; ┆ &quot;z&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot; ┆ null  │
        ╰──────┴──────┴─────┴───────╯

        Asof join
        =========
        This is similar to a left-join except that we match on nearest key rather than equal keys.
        The keys must be sorted to perform an asof join

        &quot;&quot;&quot;
        if how == &quot;cross&quot;:
            return wrap_df(self._df.join(df._df, [], [], how, suffix))

        left_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(left_on, (str, pli.Expr)):
            left_on_ = [left_on]  # type: ignore[assignment]
        else:
            left_on_ = left_on

        right_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(right_on, (str, pli.Expr)):
            right_on_ = [right_on]  # type: ignore[assignment]
        else:
            right_on_ = right_on

        if isinstance(on, str):
            left_on_ = [on]
            right_on_ = [on]
        elif isinstance(on, list):
            left_on_ = on
            right_on_ = on

        if left_on_ is None or right_on_ is None:
            raise ValueError(&quot;You should pass the column to join on as an argument.&quot;)

        if (
            isinstance(left_on_[0], pli.Expr)
            or isinstance(right_on_[0], pli.Expr)
            or asof_by_left is not None
            or asof_by_right is not None
            or asof_by is not None
        ):
            return (
                self.lazy()
                .join(
                    df.lazy(),
                    left_on,
                    right_on,
                    on=on,
                    how=how,
                    suffix=suffix,
                    asof_by_right=asof_by_right,
                    asof_by_left=asof_by_left,
                    asof_by=asof_by,
                )
                .collect(no_optimization=True)
            )
        else:
            return wrap_df(self._df.join(df._df, left_on_, right_on_, how, suffix))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeapply"><a class="header" href="#polarsinternalsframedataframeapply"><code>polars.internals.frame.DataFrame.apply</code></a></h3>
<pre><code class="language-python">apply(f: Callable[[TupleAny], Any], 
    return_dtype: OptionalTypeDataType,) -&gt; pli.Series:
</code></pre>
<p>Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.</p>
<p>Beware, this is slow.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Custom function/ lambda function.</li>
<li>[<code>return_dtype</code>]: Output type of the operation. If none given, Polars tries to infer the type.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        f: Callable[[Tuple[Any]], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.

        Beware, this is slow.

        Parameters
        ----------
        f
            Custom function/ lambda function.
        return_dtype
            Output type of the operation. If none given, Polars tries to infer the type.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.apply(f, return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_column"><a class="header" href="#polarsinternalsframedataframewith_column"><code>polars.internals.frame.DataFrame.with_column</code></a></h3>
<pre><code class="language-python">with_column(column: Union[pli.Series, pli.Expr],) -&gt; DataFrame:
</code></pre>
<p>Return a new DataFrame with the column added or replaced.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Series, where the name of the Series refers to the column in the DataFrame.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_column(self, column: Union[&quot;pli.Series&quot;, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column added or replaced.

        Parameters
        ----------
        column
            Series, where the name of the Series refers to the column in the DataFrame.
        &quot;&quot;&quot;
        if isinstance(column, pli.Expr):
            return self.with_columns([column])
        else:
            return wrap_df(self._df.with_column(column._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_column_renamed"><a class="header" href="#polarsinternalsframedataframewith_column_renamed"><code>polars.internals.frame.DataFrame.with_column_renamed</code></a></h3>
<pre><code class="language-python">with_column_renamed(existing_name: str, 
    new_name: str,) -&gt; DataFrame:
</code></pre>
<p>Return a new DataFrame with the column renamed.</p>
<p><strong>Parameters:</strong></p>
<p>existing_name
new_name</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_column_renamed(self, existing_name: str, new_name: str) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column renamed.

        Parameters
        ----------
        existing_name
        new_name
        &quot;&quot;&quot;
        return (
            self.lazy()
            .with_column_renamed(existing_name, new_name)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframehstack"><a class="header" href="#polarsinternalsframedataframehstack"><code>polars.internals.frame.DataFrame.hstack</code></a></h3>
<pre><code class="language-python">hstack(columns: Union[tp.List[pli.Series], DataFrame], 
    in_place: bool,) -&gt; OptionalDataFrame:
</code></pre>
<p>Return a new DataFrame grown horizontally by stacking multiple Series to it.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: Series to stack.</li>
<li>[<code>in_place</code>]: Modify in place.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
x = pl.Series(&quot;apple&quot;, [10, 20, 30])
df.hstack([x])
shape: (3, 4)
╭─────┬─────┬─────┬───────╮
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ i64 ┆ str ┆ i64   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6   ┆ &quot;a&quot; ┆ 10    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; ┆ 20    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; ┆ 30    │
╰─────┴─────┴─────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hstack(
        self, columns: Union[tp.List[&quot;pli.Series&quot;], &quot;DataFrame&quot;], in_place: bool = False
    ) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Return a new DataFrame grown horizontally by stacking multiple Series to it.

        Parameters
        ----------
        columns
            Series to stack.
        in_place
            Modify in place.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.hstack([x])
        shape: (3, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ i64 ┆ str ┆ i64   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ 10    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ 20    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; ┆ 30    │
        ╰─────┴─────┴─────┴───────╯

        &quot;&quot;&quot;
        if not isinstance(columns, list):
            columns = columns.get_columns()
        if in_place:
            self._df.hstack_mut([s.inner() for s in columns])
            return None
        else:
            return wrap_df(self._df.hstack([s.inner() for s in columns]))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframevstack"><a class="header" href="#polarsinternalsframedataframevstack"><code>polars.internals.frame.DataFrame.vstack</code></a></h3>
<pre><code class="language-python">vstack(df: DataFrame, 
    in_place: bool,) -&gt; OptionalDataFrame:
</code></pre>
<p>Grow this DataFrame vertically by stacking a DataFrame to it.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>df</code>]: DataFrame to stack.</li>
<li>[<code>in_place</code>]: Modify in place</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df1 = pl.DataFrame({
&quot;foo&quot;: [1, 2],
&quot;bar&quot;: [6, 7],
&quot;ham&quot;: ['a', 'b']
})
df2 = pl.DataFrame({
&quot;foo&quot;: [3, 4],
&quot;bar&quot;: [8 , 9],
&quot;ham&quot;: ['c', 'd']
})
df1.vstack(df2)
shape: (4, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 9   ┆ &quot;d&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def vstack(self, df: &quot;DataFrame&quot;, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Grow this DataFrame vertically by stacking a DataFrame to it.

        Parameters
        ----------
        df
            DataFrame to stack.
        in_place
            Modify in place

        Examples
        --------

        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 4],
        &gt;&gt;&gt;     &quot;bar&quot;: [8 , 9],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.vstack(df2)
        shape: (4, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if in_place:
            self._df.vstack_mut(df._df)
            return None
        else:
            return wrap_df(self._df.vstack(df._df))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop"><a class="header" href="#polarsinternalsframedataframedrop"><code>polars.internals.frame.DataFrame.drop</code></a></h3>
<pre><code class="language-python">drop(name: Union[str, tp.List[str]]) -&gt; DataFrame:
</code></pre>
<p>Remove column from DataFrame and return as new.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Column(s) to drop.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.drop('ham')
shape: (3, 2)
╭─────┬─────╮
│ foo ┆ bar │
│ --- ┆ --- │
│ i64 ┆ f64 │
╞═════╪═════╡
│ 1   ┆ 6   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop(self, name: Union[str, tp.List[str]]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Remove column from DataFrame and return as new.

        Parameters
        ----------
        name
            Column(s) to drop.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop('ham')
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ f64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(name, list):
            df = self.clone()

            for name in name:
                df._df.drop_in_place(name)
            return df

        return wrap_df(self._df.drop(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop_in_place"><a class="header" href="#polarsinternalsframedataframedrop_in_place"><code>polars.internals.frame.DataFrame.drop_in_place</code></a></h3>
<pre><code class="language-python">drop_in_place(name: str) -&gt; pli.Series:
</code></pre>
<p>Drop in place.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Column to drop.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.drop_in_place(&quot;ham&quot;)
shape: (3, 2)
╭─────┬─────╮
│ foo ┆ bar │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 6   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_in_place(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Drop in place.

        Parameters
        ----------
        name
            Column to drop.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop_in_place(&quot;ham&quot;)
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ i64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.drop_in_place(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeselect_at_idx"><a class="header" href="#polarsinternalsframedataframeselect_at_idx"><code>polars.internals.frame.DataFrame.select_at_idx</code></a></h3>
<pre><code class="language-python">select_at_idx(idx: int) -&gt; pli.Series:
</code></pre>
<p>Select column at index location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>idx</code>]: Location of selection.</li>
</ul>
<p>.. deprecated:: 0.10.20</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.select_at_idx(1))
shape: (3,)
Series: 'bar' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  8
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def select_at_idx(self, idx: int) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column at index location.

        Parameters
        ----------
        idx
            Location of selection.

        .. deprecated:: 0.10.20

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select_at_idx(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(idx))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeclone"><a class="header" href="#polarsinternalsframedataframeclone"><code>polars.internals.frame.DataFrame.clone</code></a></h3>
<pre><code class="language-python">clone() -&gt; DataFrame:
</code></pre>
<p>Very cheap deep clone.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clone(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Very cheap deep clone.
        &quot;&quot;&quot;
        return wrap_df(self._df.clone())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeget_columns"><a class="header" href="#polarsinternalsframedataframeget_columns"><code>polars.internals.frame.DataFrame.get_columns</code></a></h3>
<pre><code class="language-python">get_columns() -&gt; tp.List[pli.Series]:
</code></pre>
<p>Get the DataFrame as a List of Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def get_columns(self) -&gt; tp.List[&quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Get the DataFrame as a List of Series.
        &quot;&quot;&quot;
        return list(map(lambda s: pli.wrap_s(s), self._df.get_columns()))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeget_column"><a class="header" href="#polarsinternalsframedataframeget_column"><code>polars.internals.frame.DataFrame.get_column</code></a></h3>
<pre><code class="language-python">get_column(name: str) -&gt; pli.Series:
</code></pre>
<p>Get a single column as Series by name.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def get_column(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a single column as Series by name.
        &quot;&quot;&quot;
        return self[name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefill_null"><a class="header" href="#polarsinternalsframedataframefill_null"><code>polars.internals.frame.DataFrame.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(strategy: Union[str, pli.Expr]) -&gt; DataFrame:
</code></pre>
<p>Fill None/missing values by a filling strategy or an Expression evaluation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>strategy</code>]: One of:
<ul>
<li>&quot;backward&quot;</li>
<li>&quot;forward&quot;</li>
<li>&quot;mean&quot;</li>
<li>&quot;min'</li>
<li>&quot;max&quot;</li>
<li>&quot;zero&quot;</li>
<li>&quot;one&quot;
Or an expression.</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong></p>
<pre><code>DataFrame with None replaced with the filling strategy.
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, strategy: Union[str, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a filling strategy or an Expression evaluation.

        Parameters
        ----------
        strategy
            One of:
            - &quot;backward&quot;
            - &quot;forward&quot;
            - &quot;mean&quot;
            - &quot;min'
            - &quot;max&quot;
            - &quot;zero&quot;
            - &quot;one&quot;
            Or an expression.

        Returns
        -------
            DataFrame with None replaced with the filling strategy.
        &quot;&quot;&quot;
        if isinstance(strategy, pli.Expr):
            return self.lazy().fill_null(strategy).collect(no_optimization=True)
        if not isinstance(strategy, str):
            return self.fill_null(pli.lit(strategy))
        return wrap_df(self._df.fill_null(strategy))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefill_nan"><a class="header" href="#polarsinternalsframedataframefill_nan"><code>polars.internals.frame.DataFrame.fill_nan</code></a></h3>
<pre><code class="language-python">fill_nan(fill_value: Union[pli.Expr, int, float],) -&gt; DataFrame:
</code></pre>
<p>Fill None/missing values by a an Expression evaluation.</p>
<p><strong>Warnings:</strong></p>
<p>NOTE that floating point NaN (No a Number) are not missing values!
to replace missing values, use <code>fill_null</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>fill_value</code>]: value to fill NaN with</li>
</ul>
<p><strong>Returns:</strong></p>
<pre><code>DataFrame with NaN replaced with fill_value
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_nan(self, fill_value: Union[&quot;pli.Expr&quot;, int, float]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a an Expression evaluation.

        Warnings
        --------
        NOTE that floating point NaN (No a Number) are not missing values!
        to replace missing values, use `fill_null`.

        Parameters
        ----------
        fill_value
            value to fill NaN with

        Returns
        -------
            DataFrame with NaN replaced with fill_value
        &quot;&quot;&quot;
        return self.lazy().fill_nan(fill_value).collect(no_optimization=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeexplode"><a class="header" href="#polarsinternalsframedataframeexplode"><code>polars.internals.frame.DataFrame.explode</code></a></h3>
<pre><code class="language-python">explode(columns: Union[str, tp.List[str], pli.Expr, tp.List[pli.Expr]],) -&gt; DataFrame:
</code></pre>
<p>Explode <code>DataFrame</code> to long format by exploding a column with Lists.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: Column of LargeList type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
})
df
shape: (6, 2)
╭─────────┬────────────╮
│ letters ┆ nrs        │
│ ---     ┆ ---        │
│ str     ┆ list [i64] │
╞═════════╪════════════╡
│ &quot;c&quot;     ┆ [1, 2]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;c&quot;     ┆ [1, 3]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;a&quot;     ┆ [4, 3]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;c&quot;     ┆ [5, 5, 5]  │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;a&quot;     ┆ [6]        │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;b&quot;     ┆ [2, 1, 2]  │
╰─────────┴────────────╯
df.explode(&quot;nrs&quot;)
shape: (13, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ ...     ┆ ... │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 2   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(
        self, columns: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Explode `DataFrame` to long format by exploding a column with Lists.

        Parameters
        ----------
        columns
            Column of LargeList type.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬────────────╮
        │ letters ┆ nrs        │
        │ ---     ┆ ---        │
        │ str     ┆ list [i64] │
        ╞═════════╪════════════╡
        │ &quot;c&quot;     ┆ [1, 2]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [1, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [4, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [5, 5, 5]  │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [6]        │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ [2, 1, 2]  │
        ╰─────────┴────────────╯
        &gt;&gt;&gt; df.explode(&quot;nrs&quot;)
        shape: (13, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ ...     ┆ ... │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return self.lazy().explode(columns).collect(no_optimization=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemelt"><a class="header" href="#polarsinternalsframedataframemelt"><code>polars.internals.frame.DataFrame.melt</code></a></h3>
<pre><code class="language-python">melt(id_vars: Union[tp.List[str], str], 
    value_vars: Union[tp.List[str], str],) -&gt; DataFrame:
</code></pre>
<p>Unpivot DataFrame to long format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>id_vars</code>]: Columns to use as identifier variables.</p>
</li>
<li>
<p>[<code>value_vars</code>]: Values to use as identifier variables.</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def melt(
        self, id_vars: Union[tp.List[str], str], value_vars: Union[tp.List[str], str]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Unpivot DataFrame to long format.

        Parameters
        ----------
        id_vars
            Columns to use as identifier variables.

        value_vars
            Values to use as identifier variables.

        Returns
        -------

        &quot;&quot;&quot;
        if isinstance(value_vars, str):
            value_vars = [value_vars]
        if isinstance(id_vars, str):
            id_vars = [id_vars]
        return wrap_df(self._df.melt(id_vars, value_vars))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshift"><a class="header" href="#polarsinternalsframedataframeshift"><code>polars.internals.frame.DataFrame.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; DataFrame:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.shift(periods=1)
shape: (3, 3)
┌──────┬──────┬──────┐
│ foo  ┆ bar  ┆ ham  │
│ ---  ┆ ---  ┆ ---  │
│ i64  ┆ i64  ┆ str  │
╞══════╪══════╪══════╡
│ null ┆ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 1    ┆ 6    ┆ &quot;a&quot;  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ 7    ┆ &quot;b&quot;  │
└──────┴──────┴──────┘
df.shift(periods=-1)
shape: (3, 3)
┌──────┬──────┬──────┐
│ foo  ┆ bar  ┆ ham  │
│ ---  ┆ ---  ┆ ---  │
│ i64  ┆ i64  ┆ str  │
╞══════╪══════╪══════╡
│ 2    ┆ 7    ┆ &quot;b&quot;  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3    ┆ 8    ┆ &quot;c&quot;  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null ┆ null │
└──────┴──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift(periods=1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 6    ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        └──────┴──────┴──────┘
        &gt;&gt;&gt; df.shift(periods=-1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        └──────┴──────┴──────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshift_and_fill"><a class="header" href="#polarsinternalsframedataframeshift_and_fill"><code>polars.internals.frame.DataFrame.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, 
    fill_value: Union[int, str, float],) -&gt; DataFrame:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: fill None values with this value.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.shift_and_fill(periods=1, fill_value=0)
shape: (3, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 0   ┆ 0   ┆ &quot;0&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(
        self, periods: int, fill_value: Union[int, str, float]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            fill None values with this value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift_and_fill(periods=1, fill_value=0)
        shape: (3, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 0   ┆ 0   ┆ &quot;0&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .shift_and_fill(periods, fill_value)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeis_duplicated"><a class="header" href="#polarsinternalsframedataframeis_duplicated"><code>polars.internals.frame.DataFrame.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; pli.Series:
</code></pre>
<p>Get a mask of all duplicated rows in this DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all duplicated rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeis_unique"><a class="header" href="#polarsinternalsframedataframeis_unique"><code>polars.internals.frame.DataFrame.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; pli.Series:
</code></pre>
<p>Get a mask of all unique rows in this DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all unique rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframelazy"><a class="header" href="#polarsinternalsframedataframelazy"><code>polars.internals.frame.DataFrame.lazy</code></a></h3>
<pre><code class="language-python">lazy() -&gt; pli.LazyFrame:
</code></pre>
<p>Start a lazy query from this point. This returns a <code>LazyFrame</code> object.</p>
<p>Operations on a <code>LazyFrame</code> are not executed until this is requested by either calling:</p>
<ul>
<li><code>.fetch()</code> (run on a small number of rows)</li>
<li><code>.collect()</code> (run on all data)</li>
<li><code>.describe_plan()</code> (print unoptimized query plan)</li>
<li><code>.describe_optimized_plan()</code> (print optimized query plan)</li>
<li><code>.show_graph()</code> (show (un)optimized query plan) as graphiz graph)</li>
</ul>
<p>Lazy operations are advised because they allow for query optimization and more parallelization.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lazy(self) -&gt; &quot;pli.LazyFrame&quot;:
        &quot;&quot;&quot;
        Start a lazy query from this point. This returns a `LazyFrame` object.

        Operations on a `LazyFrame` are not executed until this is requested by either calling:

        * `.fetch()` (run on a small number of rows)
        * `.collect()` (run on all data)
        * `.describe_plan()` (print unoptimized query plan)
        * `.describe_optimized_plan()` (print optimized query plan)
        * `.show_graph()` (show (un)optimized query plan) as graphiz graph)

        Lazy operations are advised because they allow for query optimization and more parallelization.
        &quot;&quot;&quot;
        return pli.wrap_ldf(self._df.lazy())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeselect"><a class="header" href="#polarsinternalsframedataframeselect"><code>polars.internals.frame.DataFrame.select</code></a></h3>
<pre><code class="language-python">select(exprs: Union[str, pli.Expr, SequenceUnion[str, pli.Expr], Sequencebool, Sequenceint, Sequencefloat],) -&gt; DataFrame:
</code></pre>
<p>Select columns from this DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Column or columns to select.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.select('foo')
shape: (3, 1)
┌─────┐
│ foo │
│ --- │
│ i64 │
╞═════╡
│ 1   │
├╌╌╌╌╌┤
│ 2   │
├╌╌╌╌╌┤
│ 3   │
└─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def select(
        self,
        exprs: Union[
            str,
            &quot;pli.Expr&quot;,
            Sequence[Union[str, &quot;pli.Expr&quot;]],
            Sequence[bool],
            Sequence[int],
            Sequence[float],
        ],
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Select columns from this DataFrame.

        Parameters
        ----------
        exprs
            Column or columns to select.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select('foo')
        shape: (3, 1)
        ┌─────┐
        │ foo │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        └─────┘

        &quot;&quot;&quot;
        return (
            self.lazy().select(exprs).collect(no_optimization=True, string_cache=False)  # type: ignore
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_columns"><a class="header" href="#polarsinternalsframedataframewith_columns"><code>polars.internals.frame.DataFrame.with_columns</code></a></h3>
<pre><code class="language-python">with_columns(exprs: Union[pli.Expr, tp.List[pli.Expr]],) -&gt; DataFrame:
</code></pre>
<p>Add or overwrite multiple columns in a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: List of Expressions that evaluate to columns.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_columns(
        self, exprs: Union[&quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite multiple columns in a DataFrame.

        Parameters
        ----------
        exprs
            List of Expressions that evaluate to columns.
        &quot;&quot;&quot;
        if not isinstance(exprs, list):
            exprs = [exprs]
        return (
            self.lazy()
            .with_columns(exprs)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframen_chunks"><a class="header" href="#polarsinternalsframedataframen_chunks"><code>polars.internals.frame.DataFrame.n_chunks</code></a></h3>
<pre><code class="language-python">n_chunks() -&gt; int:
</code></pre>
<p>Get number of chunks used by the ChunkedArrays of this DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get number of chunks used by the ChunkedArrays of this DataFrame.
        &quot;&quot;&quot;
        return self._df.n_chunks()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemax"><a class="header" href="#polarsinternalsframedataframemax"><code>polars.internals.frame.DataFrame.max</code></a></h3>
<pre><code class="language-python">max(axis: int) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their maximum value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.max()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 3   ┆ 8   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their maximum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.max()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 3   ┆ 8   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.max())
        if axis == 1:
            return pli.wrap_s(self._df.hmax())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemin"><a class="header" href="#polarsinternalsframedataframemin"><code>polars.internals.frame.DataFrame.min</code></a></h3>
<pre><code class="language-python">min(axis: int) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their minimum value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.min()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 6   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their minimum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.min()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 6   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.min())
        if axis == 1:
            return pli.wrap_s(self._df.hmin())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframesum"><a class="header" href="#polarsinternalsframedataframesum"><code>polars.internals.frame.DataFrame.sum</code></a></h3>
<pre><code class="language-python">sum(axis: int, 
    null_strategy: str,) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their sum value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>axis</code>]: either 0 or 1</li>
<li>[<code>null_strategy</code>]: {'ignore', 'propagate'}
this argument is only used if axis == 1</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.sum()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 6   ┆ 21  ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their sum value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sum()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 6   ┆ 21  ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.sum())
        if axis == 1:
            return pli.wrap_s(self._df.hsum(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemean"><a class="header" href="#polarsinternalsframedataframemean"><code>polars.internals.frame.DataFrame.mean</code></a></h3>
<pre><code class="language-python">mean(axis: int, 
    null_strategy: str,) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their mean value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>axis</code>]: either 0 or 1</li>
<li>[<code>null_strategy</code>]: {'ignore', 'propagate'}
this argument is only used if axis == 1</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.mean()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 2   ┆ 7   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their mean value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.mean()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.mean())
        if axis == 1:
            return pli.wrap_s(self._df.hmean(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframestd"><a class="header" href="#polarsinternalsframedataframestd"><code>polars.internals.frame.DataFrame.std</code></a></h3>
<pre><code class="language-python">std() -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their standard deviation value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.std()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 1   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their standard deviation value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.std()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.std())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframevar"><a class="header" href="#polarsinternalsframedataframevar"><code>polars.internals.frame.DataFrame.var</code></a></h3>
<pre><code class="language-python">var() -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their variance value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.var()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 1   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their variance value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.var()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.var())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemedian"><a class="header" href="#polarsinternalsframedataframemedian"><code>polars.internals.frame.DataFrame.median</code></a></h3>
<pre><code class="language-python">median() -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their median value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.median()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 1   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their median value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.median()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.median())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframequantile"><a class="header" href="#polarsinternalsframedataframequantile"><code>polars.internals.frame.DataFrame.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their quantile value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.quantile(0.5)
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 2   ┆ 7   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their quantile value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.quantile(0.5)
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.quantile(quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_dummies"><a class="header" href="#polarsinternalsframedataframeto_dummies"><code>polars.internals.frame.DataFrame.to_dummies</code></a></h3>
<pre><code class="language-python">to_dummies() -&gt; DataFrame:
</code></pre>
<p>Get one hot encoded dummy variables.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.to_dummies()
shape: (3, 9)
╭───────┬───────┬───────┬───────┬─────┬───────┬───────┬───────┬───────╮
│ foo_1 ┆ foo_2 ┆ foo_3 ┆ bar_6 ┆ ... ┆ bar_8 ┆ ham_a ┆ ham_b ┆ ham_c │
│ ---   ┆ ---   ┆ ---   ┆ ---   ┆     ┆ ---   ┆ ---   ┆ ---   ┆ ---   │
│ u8    ┆ u8    ┆ u8    ┆ u8    ┆     ┆ u8    ┆ u8    ┆ u8    ┆ u8    │
╞═══════╪═══════╪═══════╪═══════╪═════╪═══════╪═══════╪═══════╪═══════╡
│ 1     ┆ 0     ┆ 0     ┆ 1     ┆ ... ┆ 0     ┆ 1     ┆ 0     ┆ 0     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 0     ┆ 1     ┆ 0     ┆ 0     ┆ ... ┆ 0     ┆ 0     ┆ 1     ┆ 0     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 0     ┆ 0     ┆ 1     ┆ 0     ┆ ... ┆ 1     ┆ 0     ┆ 0     ┆ 1     │
╰───────┴───────┴───────┴───────┴─────┴───────┴───────┴───────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dummies(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get one hot encoded dummy variables.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_dummies()
        shape: (3, 9)
        ╭───────┬───────┬───────┬───────┬─────┬───────┬───────┬───────┬───────╮
        │ foo_1 ┆ foo_2 ┆ foo_3 ┆ bar_6 ┆ ... ┆ bar_8 ┆ ham_a ┆ ham_b ┆ ham_c │
        │ ---   ┆ ---   ┆ ---   ┆ ---   ┆     ┆ ---   ┆ ---   ┆ ---   ┆ ---   │
        │ u8    ┆ u8    ┆ u8    ┆ u8    ┆     ┆ u8    ┆ u8    ┆ u8    ┆ u8    │
        ╞═══════╪═══════╪═══════╪═══════╪═════╪═══════╪═══════╪═══════╪═══════╡
        │ 1     ┆ 0     ┆ 0     ┆ 1     ┆ ... ┆ 0     ┆ 1     ┆ 0     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 1     ┆ 0     ┆ 0     ┆ ... ┆ 0     ┆ 0     ┆ 1     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 0     ┆ 1     ┆ 0     ┆ ... ┆ 1     ┆ 0     ┆ 0     ┆ 1     │
        ╰───────┴───────┴───────┴───────┴─────┴───────┴───────┴───────┴───────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.to_dummies())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop_duplicates"><a class="header" href="#polarsinternalsframedataframedrop_duplicates"><code>polars.internals.frame.DataFrame.drop_duplicates</code></a></h3>
<pre><code class="language-python">drop_duplicates(maintain_order: bool, 
    subset: OptionalUnion[str, tp.List[str]],) -&gt; DataFrame:
</code></pre>
<p>Drop duplicate rows from this DataFrame.
Note that this fails if there is a column of type <code>List</code> in the DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_duplicates(
        self,
        maintain_order: bool = True,
        subset: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Drop duplicate rows from this DataFrame.
        Note that this fails if there is a column of type `List` in the DataFrame.
        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_df(self._df.drop_duplicates(maintain_order, subset))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerechunk"><a class="header" href="#polarsinternalsframedataframerechunk"><code>polars.internals.frame.DataFrame.rechunk</code></a></h3>
<pre><code class="language-python">rechunk() -&gt; DataFrame:
</code></pre>
<p>Rechunk the data in this DataFrame to a contiguous allocation.</p>
<p>This will make sure all subsequent operations have optimal and predictable performance.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rechunk(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rechunk the data in this DataFrame to a contiguous allocation.

        This will make sure all subsequent operations have optimal and predictable performance.
        &quot;&quot;&quot;
        return wrap_df(self._df.rechunk())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframenull_count"><a class="header" href="#polarsinternalsframedataframenull_count"><code>polars.internals.frame.DataFrame.null_count</code></a></h3>
<pre><code class="language-python">null_count() -&gt; DataFrame:
</code></pre>
<p>Create a new DataFrame that shows the null counts per column.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, None, 3],
&quot;bar&quot;: [6, 7, None],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.null_count()
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ u32 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 0   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def null_count(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Create a new DataFrame that shows the null counts per column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, None, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, None],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.null_count()
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ u32 ┆ u32 ┆ u32 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 1   ┆ 0   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.null_count())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframesample"><a class="header" href="#polarsinternalsframedataframesample"><code>polars.internals.frame.DataFrame.sample</code></a></h3>
<pre><code class="language-python">sample(n: Optionalint, 
    frac: Optionalfloat, 
    with_replacement: bool,) -&gt; DataFrame:
</code></pre>
<p>Sample from this DataFrame by setting either <code>n</code> or <code>frac</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of samples &lt; self.len() .</li>
<li>[<code>frac</code>]: Fraction between 0.0 and 1.0 .</li>
<li>[<code>with_replacement</code>]: Sample with replacement.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.sample(n=2)
shape: (2, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sample from this DataFrame by setting either `n` or `frac`.

        Parameters
        ----------
        n
            Number of samples &lt; self.len() .
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            Sample with replacement.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sample(n=2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if n is not None:
            return wrap_df(self._df.sample_n(n, with_replacement))
        return wrap_df(self._df.sample_frac(frac, with_replacement))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefold"><a class="header" href="#polarsinternalsframedataframefold"><code>polars.internals.frame.DataFrame.fold</code></a></h3>
<pre><code class="language-python">fold(operation: Callable[[pli.Series, pli.Series], pli.Series],) -&gt; pli.Series:
</code></pre>
<p>Apply a horizontal reduction on a DataFrame. This can be used to effectively
determine aggregations on a row level, and can be applied to any DataType that
can be supercasted (casted to a similar parent type).</p>
<p>An example of the supercast rules when applying an arithmetic operation on two DataTypes are for instance:</p>
<p>Int8 + Utf8 = Utf8
Float32 + Int64 = Float32
Float32 + Float64 = Float64</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="a-horizontal-sum-operation"><a class="header" href="#a-horizontal-sum-operation">A horizontal sum operation</a></h1>
<p>df = pl.DataFrame(
{&quot;a&quot;: [2, 1, 3],
&quot;b&quot;: [1, 2, 3],
&quot;c&quot;: [1.0, 2.0, 3.0]
})
df.fold(lambda s1, s2: s1 + s2)
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>9
]</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<h1 id="a-horizontal-minimum-operation"><a class="header" href="#a-horizontal-minimum-operation">A horizontal minimum operation</a></h1>
<p>df = pl.DataFrame(
{&quot;a&quot;: [2, 1, 3],
&quot;b&quot;: [1, 2, 3],
&quot;c&quot;: [1.0, 2.0, 3.0]
})
df.fold(lambda s1, s2: s1.zip_with(s1 &lt; s2, s2))
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>3
]</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<h1 id="a-horizontal-string-concattenation"><a class="header" href="#a-horizontal-string-concattenation">A horizontal string concattenation</a></h1>
<p>df = pl.DataFrame(
{&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, 2],
&quot;b&quot;: [1, 2, 3],
&quot;c&quot;: [1.0, 2.0, 3.0]
})
df.fold(lambda s1, s2: s1 + s2)
Series: '' [f64]
[
&quot;foo11&quot;
&quot;bar22
&quot;233&quot;
]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>operation</code>]: function that takes two <code>Series</code> and returns a <code>Series</code>.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fold(
        self, operation: Callable[[&quot;pli.Series&quot;, &quot;pli.Series&quot;], &quot;pli.Series&quot;]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a horizontal reduction on a DataFrame. This can be used to effectively
        determine aggregations on a row level, and can be applied to any DataType that
        can be supercasted (casted to a similar parent type).

        An example of the supercast rules when applying an arithmetic operation on two DataTypes are for instance:

        Int8 + Utf8 = Utf8
        Float32 + Int64 = Float32
        Float32 + Float64 = Float64

        Examples
        --------
        &gt;&gt;&gt; # A horizontal sum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: 'a' [f64]
        [
            4
            5
            9
        ]

        &gt;&gt;&gt; # A horizontal minimum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1.zip_with(s1 &lt; s2, s2))
        Series: 'a' [f64]
        [
            1
            1
            3
        ]

        &gt;&gt;&gt; # A horizontal string concattenation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, 2],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: '' [f64]
        [
            &quot;foo11&quot;
            &quot;bar22
            &quot;233&quot;
        ]

        Parameters
        ----------
        operation
            function that takes two `Series` and returns a `Series`.

        &quot;&quot;&quot;
        if self.width == 1:
            return self.to_series(0)
        df = self
        acc = operation(df.to_series(0), df.to_series(1))

        for i in range(2, df.width):
            acc = operation(acc, df.to_series(i))
        return acc
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerow"><a class="header" href="#polarsinternalsframedataframerow"><code>polars.internals.frame.DataFrame.row</code></a></h3>
<pre><code class="language-python">row(index: int) -&gt; TupleAny:
</code></pre>
<p>Get a row as tuple.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Row index.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.row(2)
(3, 8, 'c')</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def row(self, index: int) -&gt; Tuple[Any]:
        &quot;&quot;&quot;
        Get a row as tuple.

        Parameters
        ----------
        index
            Row index.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.row(2)
        (3, 8, 'c')

        &quot;&quot;&quot;
        return self._df.row_tuple(index)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerows"><a class="header" href="#polarsinternalsframedataframerows"><code>polars.internals.frame.DataFrame.rows</code></a></h3>
<pre><code class="language-python">rows() -&gt; tp.List[Tuple]:
</code></pre>
<p>Convert columnar data to rows as python tuples.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rows(self) -&gt; tp.List[Tuple]:
        &quot;&quot;&quot;
        Convert columnar data to rows as python tuples.
        &quot;&quot;&quot;
        return self._df.row_tuples()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshrink_to_fit"><a class="header" href="#polarsinternalsframedataframeshrink_to_fit"><code>polars.internals.frame.DataFrame.shrink_to_fit</code></a></h3>
<pre><code class="language-python">shrink_to_fit(in_place: bool) -&gt; OptionalDataFrame:
</code></pre>
<p>Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._df.shrink_to_fit()
            return None
        else:
            df = self.clone()
            df._df.shrink_to_fit()
            return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframehash_rows"><a class="header" href="#polarsinternalsframedataframehash_rows"><code>polars.internals.frame.DataFrame.hash_rows</code></a></h3>
<pre><code class="language-python">hash_rows(k0: int, 
    k1: int, 
    k2: int, 
    k3: int,) -&gt; pli.Series:
</code></pre>
<p>Hash and combine the rows in this DataFrame.</p>
<p>Hash value is UInt64</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.hash(k0=42)
shape: (3,)
Series: '' [u64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  18282897888575762835
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash_rows(
        self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash and combine the rows in this DataFrame.

        Hash value is UInt64

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.hash(k0=42)
        shape: (3,)
        Series: '' [u64]
        [
                1208206736888326229
                8040480609798856146
                18282897888575762835
        ]
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.hash_rows(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeinterpolate"><a class="header" href="#polarsinternalsframedataframeinterpolate"><code>polars.internals.frame.DataFrame.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; DataFrame:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return self.select(pli.col(&quot;*&quot;).interpolate())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeis_empty"><a class="header" href="#polarsinternalsframedataframeis_empty"><code>polars.internals.frame.DataFrame.is_empty</code></a></h3>
<pre><code class="language-python">is_empty() -&gt; bool:
</code></pre>
<p>Check if the dataframe is empty</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if the dataframe is empty
        &quot;&quot;&quot;
        return self.height == 0
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsframegroupby"><a class="header" href="#polarsinternalsframegroupby"><code>polars.internals.frame.GroupBy</code></a></h1>
<p>Starts a new GroupBy operation.</p>
<p>You can also loop over this Object to loop over <code>DataFrames</code> with unique groups.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>for group in df.groupby(&quot;foo&quot;):
print(group)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyget_group"><code>get_group()</code></a>: Select a single group as a new DataFrame.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbygroups"><code>groups()</code></a>: Return a <code>DataFrame</code> with:</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyapply"><code>apply()</code></a>: Apply a function over the groups as a sub-DataFrame.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyagg"><code>agg()</code></a>: Use multiple aggregations on columns. This can be combined with complete lazy API</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyhead"><code>head()</code></a>: Return first n rows of each group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbytail"><code>tail()</code></a>: Return last n rows of each group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbypivot"><code>pivot()</code></a>: Do a pivot operation based on the group key, a pivot column and an aggregation function on the values column.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyfirst"><code>first()</code></a>: Aggregate the first values in the group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbylast"><code>last()</code></a>: Aggregate the last values in the group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbysum"><code>sum()</code></a>: Reduce the groups to the sum.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbymin"><code>min()</code></a>: Reduce the groups to the minimal value.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbymax"><code>max()</code></a>: Reduce the groups to the maximal value.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbycount"><code>count()</code></a>: Count the number of values in each group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbymean"><code>mean()</code></a>: Reduce the groups to the mean values.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyn_unique"><code>n_unique()</code></a>: Count the unique values per group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyquantile"><code>quantile()</code></a>: Compute the quantile per group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbymedian"><code>median()</code></a>: Return the median per group.</li>
<li><a href="polars/internals/frame/GroupBy.html#polarsinternalsframegroupbyagg_list"><code>agg_list()</code></a>: Aggregate the groups into Series.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class GroupBy:
    &quot;&quot;&quot;
    Starts a new GroupBy operation.

    You can also loop over this Object to loop over `DataFrames` with unique groups.

    Examples
    --------

    &gt;&gt;&gt; for group in df.groupby(&quot;foo&quot;):
    &gt;&gt;&gt;    print(group)
    &quot;&quot;&quot;

    def __init__(
        self,
        df: &quot;PyDataFrame&quot;,
        by: Union[str, tp.List[str]],
        maintain_order: bool = False,
        downsample: bool = False,
        rule: Optional[str] = None,
        downsample_n: int = 0,
    ):
        self._df = df
        self.by = by
        self.maintain_order = maintain_order
        self.downsample = downsample
        self.rule = rule
        self.downsample_n = downsample_n

    def __getitem__(self, item: Any) -&gt; &quot;GBSelection&quot;:
        return self._select(item)

    def _select(self, columns: Union[str, tp.List[str]]) -&gt; &quot;GBSelection&quot;:
        &quot;&quot;&quot;
        Select the columns that will be aggregated.

        Parameters
        ----------
        columns
            One or multiple columns.
        &quot;&quot;&quot;
        if self.downsample:
            raise ValueError(&quot;select not supported in downsample operation&quot;)
        if isinstance(columns, str):
            columns = [columns]
        return GBSelection(self._df, self.by, columns)

    def __iter__(self) -&gt; Iterable[Any]:
        groups_df = self.groups()
        groups = groups_df[&quot;groups&quot;]
        df = wrap_df(self._df)
        for i in range(groups_df.height):
            yield df[groups[i]]

    def get_group(self, group_value: Union[Any, Tuple[Any]]) -&gt; DataFrame:
        &quot;&quot;&quot;
        Select a single group as a new DataFrame.

        Parameters
        ----------
        group_value
            Group to select.
        &quot;&quot;&quot;
        groups_df = self.groups()
        groups = groups_df[&quot;groups&quot;]

        if not isinstance(group_value, list):
            group_value = [group_value]

        by = self.by
        if not isinstance(by, list):
            by = [by]

        mask = None
        for column, group_val in zip(by, group_value):
            local_mask = groups_df[column] == group_val
            if mask is None:
                mask = local_mask
            else:
                mask = mask &amp; local_mask

        # should be only one match
        try:
            groups_idx = groups[mask][0]
        except IndexError:
            raise ValueError(f&quot;no group: {group_value} found&quot;)

        df = wrap_df(self._df)
        return df[groups_idx]

    def groups(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return a `DataFrame` with:

        * the groupby keys
        * the group indexes aggregated as lists
        &quot;&quot;&quot;
        return wrap_df(self._df.groupby(self.by, None, &quot;groups&quot;))

    def apply(self, f: Callable[[DataFrame], DataFrame]) -&gt; DataFrame:
        &quot;&quot;&quot;
        Apply a function over the groups as a sub-DataFrame.

        Parameters
        ----------
        f
            Custom function.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return wrap_df(self._df.groupby_apply(self.by, f))

    def agg(
        self,
        column_to_agg: Union[
            tp.List[Tuple[str, tp.List[str]]],
            Dict[str, Union[str, tp.List[str]]],
            tp.List[&quot;pli.Expr&quot;],
            &quot;pli.Expr&quot;,
        ],
    ) -&gt; DataFrame:
        &quot;&quot;&quot;
        Use multiple aggregations on columns. This can be combined with complete lazy API
        and is considered idiomatic polars.

        Parameters
        ----------
        column_to_agg
            map column to aggregation functions.

            Examples:
                ## use lazy API syntax (recommended)
                [col(&quot;foo&quot;).sum(), col(&quot;bar&quot;).min()]

                ## column name to aggregation with tuples:
                [(&quot;foo&quot;, [&quot;sum&quot;, &quot;n_unique&quot;, &quot;min&quot;]),
                 (&quot;bar&quot;: [&quot;max&quot;])]

                ## column name to aggregation with dict:
                {&quot;foo&quot;: [&quot;sum&quot;, &quot;n_unique&quot;, &quot;min&quot;],
                &quot;bar&quot;: &quot;max&quot; }

        Returns
        -------
        Result of groupby split apply operations.


        Examples
        --------

        &gt;&gt;&gt; # use lazy API
        &gt;&gt;&gt; (df.groupby([&quot;foo&quot;, &quot;bar&quot;])
        &gt;&gt;&gt; .agg([pl.sum(&quot;ham&quot;), col(&quot;spam&quot;).tail(4).sum()])

        &gt;&gt;&gt; # use a dict
        &gt;&gt;&gt; (df.groupby([&quot;foo&quot;, &quot;bar&quot;])
        &gt;&gt;&gt; .agg({&quot;spam&quot;: [&quot;sum&quot;, &quot;min&quot;})

        &quot;&quot;&quot;
        if isinstance(column_to_agg, pli.Expr):
            column_to_agg = [column_to_agg]
        if isinstance(column_to_agg, dict):
            column_to_agg = [
                (column, [agg] if isinstance(agg, str) else agg)
                for (column, agg) in column_to_agg.items()
            ]
        elif isinstance(column_to_agg, list):

            if isinstance(column_to_agg[0], tuple):
                column_to_agg = [  # type: ignore[misc]
                    (column, [agg] if isinstance(agg, str) else agg)  # type: ignore[misc]
                    for (column, agg) in column_to_agg
                ]

            elif isinstance(column_to_agg[0], pli.Expr):
                return (
                    wrap_df(self._df)
                    .lazy()
                    .groupby(self.by, maintain_order=self.maintain_order)
                    .agg(column_to_agg)  # type: ignore[arg-type]
                    .collect(no_optimization=True, string_cache=False)
                )

                pass
            else:
                raise ValueError(
                    f&quot;argument: {column_to_agg} not understood, have you passed a list of expressions?&quot;
                )
        else:
            raise ValueError(
                f&quot;argument: {column_to_agg} not understood, have you passed a list of expressions?&quot;
            )

        if self.downsample:
            return wrap_df(
                self._df.downsample_agg(
                    self.by, self.rule, self.downsample_n, column_to_agg
                )
            )

        return wrap_df(self._df.groupby_agg(self.by, column_to_agg))

    def head(self, n: int = 5) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return first n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select


        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .head(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return (
            wrap_df(self._df)
            .lazy()
            .groupby(self.by, self.maintain_order)
            .head(n)  # type: ignore[arg-type]
            .collect(no_optimization=True, string_cache=False)
        )

    def tail(self, n: int = 5) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return last n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .tail(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return (
            wrap_df(self._df)
            .lazy()
            .groupby(self.by, self.maintain_order)
            .tail(n)  # type: ignore[arg-type]
            .collect(no_optimization=True, string_cache=False)
        )

    def _select_all(self) -&gt; &quot;GBSelection&quot;:
        &quot;&quot;&quot;
        Select all columns for aggregation.
        &quot;&quot;&quot;
        return GBSelection(
            self._df, self.by, None, self.downsample, self.rule, self.downsample_n
        )

    def pivot(self, pivot_column: str, values_column: str) -&gt; &quot;PivotOps&quot;:
        &quot;&quot;&quot;
        Do a pivot operation based on the group key, a pivot column and an aggregation function on the values column.

        Parameters
        ----------
        pivot_column
            Column to pivot.
        values_column
            Column that will be aggregated.
        &quot;&quot;&quot;
        if self.downsample:
            raise ValueError(&quot;Pivot not supported in downsample operation.&quot;)
        return PivotOps(self._df, self.by, pivot_column, values_column)

    def first(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the first values in the group.
        &quot;&quot;&quot;
        return self._select_all().first()

    def last(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the last values in the group.
        &quot;&quot;&quot;
        return self._select_all().last()

    def sum(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the sum.
        &quot;&quot;&quot;
        return self._select_all().sum()

    def min(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the minimal value.
        &quot;&quot;&quot;
        return self._select_all().min()

    def max(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the maximal value.
        &quot;&quot;&quot;
        return self._select_all().max()

    def count(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the number of values in each group.
        &quot;&quot;&quot;
        return self._select_all().count()

    def mean(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the mean values.
        &quot;&quot;&quot;
        return self._select_all().mean()

    def n_unique(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the unique values per group.
        &quot;&quot;&quot;
        return self._select_all().n_unique()

    def quantile(self, quantile: float) -&gt; DataFrame:
        &quot;&quot;&quot;
        Compute the quantile per group.
        &quot;&quot;&quot;
        return self._select_all().quantile(quantile)

    def median(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return the median per group.
        &quot;&quot;&quot;
        return self._select_all().median()

    def agg_list(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the groups into Series.
        &quot;&quot;&quot;
        return self._select_all().agg_list()
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-6"><a class="header" href="#constructor-6">Constructor</a></h2>
<pre><code class="language-python">GroupBy(df: PyDataFrame, 
    by: Union[str, tp.List[str]], 
    maintain_order: bool, 
    downsample: bool, 
    rule: Optionalstr, 
    downsample_n: int,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        df: &quot;PyDataFrame&quot;,
        by: Union[str, tp.List[str]],
        maintain_order: bool = False,
        downsample: bool = False,
        rule: Optional[str] = None,
        downsample_n: int = 0,
    ):
        self._df = df
        self.by = by
        self.maintain_order = maintain_order
        self.downsample = downsample
        self.rule = rule
        self.downsample_n = downsample_n
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-6"><a class="header" href="#methods-6">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyget_group"><a class="header" href="#polarsinternalsframegroupbyget_group"><code>polars.internals.frame.GroupBy.get_group</code></a></h3>
<pre><code class="language-python">get_group(group_value: Union[Any, TupleAny],) -&gt; DataFrame:
</code></pre>
<p>Select a single group as a new DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>group_value</code>]: Group to select.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def get_group(self, group_value: Union[Any, Tuple[Any]]) -&gt; DataFrame:
        &quot;&quot;&quot;
        Select a single group as a new DataFrame.

        Parameters
        ----------
        group_value
            Group to select.
        &quot;&quot;&quot;
        groups_df = self.groups()
        groups = groups_df[&quot;groups&quot;]

        if not isinstance(group_value, list):
            group_value = [group_value]

        by = self.by
        if not isinstance(by, list):
            by = [by]

        mask = None
        for column, group_val in zip(by, group_value):
            local_mask = groups_df[column] == group_val
            if mask is None:
                mask = local_mask
            else:
                mask = mask &amp; local_mask

        # should be only one match
        try:
            groups_idx = groups[mask][0]
        except IndexError:
            raise ValueError(f&quot;no group: {group_value} found&quot;)

        df = wrap_df(self._df)
        return df[groups_idx]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbygroups"><a class="header" href="#polarsinternalsframegroupbygroups"><code>polars.internals.frame.GroupBy.groups</code></a></h3>
<pre><code class="language-python">groups() -&gt; DataFrame:
</code></pre>
<p>Return a <code>DataFrame</code> with:</p>
<ul>
<li>the groupby keys</li>
<li>the group indexes aggregated as lists</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def groups(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return a `DataFrame` with:

        * the groupby keys
        * the group indexes aggregated as lists
        &quot;&quot;&quot;
        return wrap_df(self._df.groupby(self.by, None, &quot;groups&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyapply"><a class="header" href="#polarsinternalsframegroupbyapply"><code>polars.internals.frame.GroupBy.apply</code></a></h3>
<pre><code class="language-python">apply(f: Callable[[DataFrame], DataFrame],) -&gt; DataFrame:
</code></pre>
<p>Apply a function over the groups as a sub-DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Custom function.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(self, f: Callable[[DataFrame], DataFrame]) -&gt; DataFrame:
        &quot;&quot;&quot;
        Apply a function over the groups as a sub-DataFrame.

        Parameters
        ----------
        f
            Custom function.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return wrap_df(self._df.groupby_apply(self.by, f))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyagg"><a class="header" href="#polarsinternalsframegroupbyagg"><code>polars.internals.frame.GroupBy.agg</code></a></h3>
<pre><code class="language-python">agg(column_to_agg: Union[tp.List[Tuple[str, tp.List[str]]], Dict[str, Union[str, tp.List[str]]], tp.List[pli.Expr], pli.Expr],) -&gt; DataFrame:
</code></pre>
<p>Use multiple aggregations on columns. This can be combined with complete lazy API
and is considered idiomatic polars.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>column_to_agg</code>]: map column to aggregation functions.</p>
<p>Examples:
## use lazy API syntax (recommended)
[col(&quot;foo&quot;).sum(), col(&quot;bar&quot;).min()]</p>
<pre><code>  ## column name to aggregation with tuples:
  [(&quot;foo&quot;, [&quot;sum&quot;, &quot;n_unique&quot;, &quot;min&quot;]),
   (&quot;bar&quot;: [&quot;max&quot;])]

  ## column name to aggregation with dict:
  {&quot;foo&quot;: [&quot;sum&quot;, &quot;n_unique&quot;, &quot;min&quot;],
  &quot;bar&quot;: &quot;max&quot; }
</code></pre>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Result of groupby split apply operations.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="use-lazy-api"><a class="header" href="#use-lazy-api">use lazy API</a></h1>
<p>(df.groupby([&quot;foo&quot;, &quot;bar&quot;])
.agg([pl.sum(&quot;ham&quot;), col(&quot;spam&quot;).tail(4).sum()])</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="use-a-dict"><a class="header" href="#use-a-dict">use a dict</a></h1>
<p>(df.groupby([&quot;foo&quot;, &quot;bar&quot;])
.agg({&quot;spam&quot;: [&quot;sum&quot;, &quot;min&quot;})</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg(
        self,
        column_to_agg: Union[
            tp.List[Tuple[str, tp.List[str]]],
            Dict[str, Union[str, tp.List[str]]],
            tp.List[&quot;pli.Expr&quot;],
            &quot;pli.Expr&quot;,
        ],
    ) -&gt; DataFrame:
        &quot;&quot;&quot;
        Use multiple aggregations on columns. This can be combined with complete lazy API
        and is considered idiomatic polars.

        Parameters
        ----------
        column_to_agg
            map column to aggregation functions.

            Examples:
                ## use lazy API syntax (recommended)
                [col(&quot;foo&quot;).sum(), col(&quot;bar&quot;).min()]

                ## column name to aggregation with tuples:
                [(&quot;foo&quot;, [&quot;sum&quot;, &quot;n_unique&quot;, &quot;min&quot;]),
                 (&quot;bar&quot;: [&quot;max&quot;])]

                ## column name to aggregation with dict:
                {&quot;foo&quot;: [&quot;sum&quot;, &quot;n_unique&quot;, &quot;min&quot;],
                &quot;bar&quot;: &quot;max&quot; }

        Returns
        -------
        Result of groupby split apply operations.


        Examples
        --------

        &gt;&gt;&gt; # use lazy API
        &gt;&gt;&gt; (df.groupby([&quot;foo&quot;, &quot;bar&quot;])
        &gt;&gt;&gt; .agg([pl.sum(&quot;ham&quot;), col(&quot;spam&quot;).tail(4).sum()])

        &gt;&gt;&gt; # use a dict
        &gt;&gt;&gt; (df.groupby([&quot;foo&quot;, &quot;bar&quot;])
        &gt;&gt;&gt; .agg({&quot;spam&quot;: [&quot;sum&quot;, &quot;min&quot;})

        &quot;&quot;&quot;
        if isinstance(column_to_agg, pli.Expr):
            column_to_agg = [column_to_agg]
        if isinstance(column_to_agg, dict):
            column_to_agg = [
                (column, [agg] if isinstance(agg, str) else agg)
                for (column, agg) in column_to_agg.items()
            ]
        elif isinstance(column_to_agg, list):

            if isinstance(column_to_agg[0], tuple):
                column_to_agg = [  # type: ignore[misc]
                    (column, [agg] if isinstance(agg, str) else agg)  # type: ignore[misc]
                    for (column, agg) in column_to_agg
                ]

            elif isinstance(column_to_agg[0], pli.Expr):
                return (
                    wrap_df(self._df)
                    .lazy()
                    .groupby(self.by, maintain_order=self.maintain_order)
                    .agg(column_to_agg)  # type: ignore[arg-type]
                    .collect(no_optimization=True, string_cache=False)
                )

                pass
            else:
                raise ValueError(
                    f&quot;argument: {column_to_agg} not understood, have you passed a list of expressions?&quot;
                )
        else:
            raise ValueError(
                f&quot;argument: {column_to_agg} not understood, have you passed a list of expressions?&quot;
            )

        if self.downsample:
            return wrap_df(
                self._df.downsample_agg(
                    self.by, self.rule, self.downsample_n, column_to_agg
                )
            )

        return wrap_df(self._df.groupby_agg(self.by, column_to_agg))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyhead"><a class="header" href="#polarsinternalsframegroupbyhead"><code>polars.internals.frame.GroupBy.head</code></a></h3>
<pre><code class="language-python">head(n: int) -&gt; DataFrame:
</code></pre>
<p>Return first n rows of each group.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of values of the group to select</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
})
df
shape: (6, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 4   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
╰─────────┴─────╯
(df.groupby(&quot;letters&quot;)
.head(2)
.sort(&quot;letters&quot;)
)
shape: (5, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, n: int = 5) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return first n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select


        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .head(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return (
            wrap_df(self._df)
            .lazy()
            .groupby(self.by, self.maintain_order)
            .head(n)  # type: ignore[arg-type]
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbytail"><a class="header" href="#polarsinternalsframegroupbytail"><code>polars.internals.frame.GroupBy.tail</code></a></h3>
<pre><code class="language-python">tail(n: int) -&gt; DataFrame:
</code></pre>
<p>Return last n rows of each group.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of values of the group to select</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
})
df
shape: (6, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 4   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
╰─────────┴─────╯
(df.groupby(&quot;letters&quot;)
.tail(2)
.sort(&quot;letters&quot;)
)
shape: (5, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 4   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, n: int = 5) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return last n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .tail(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return (
            wrap_df(self._df)
            .lazy()
            .groupby(self.by, self.maintain_order)
            .tail(n)  # type: ignore[arg-type]
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbypivot"><a class="header" href="#polarsinternalsframegroupbypivot"><code>polars.internals.frame.GroupBy.pivot</code></a></h3>
<pre><code class="language-python">pivot(pivot_column: str, 
    values_column: str,) -&gt; PivotOps:
</code></pre>
<p>Do a pivot operation based on the group key, a pivot column and an aggregation function on the values column.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pivot_column</code>]: Column to pivot.</li>
<li>[<code>values_column</code>]: Column that will be aggregated.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pivot(self, pivot_column: str, values_column: str) -&gt; &quot;PivotOps&quot;:
        &quot;&quot;&quot;
        Do a pivot operation based on the group key, a pivot column and an aggregation function on the values column.

        Parameters
        ----------
        pivot_column
            Column to pivot.
        values_column
            Column that will be aggregated.
        &quot;&quot;&quot;
        if self.downsample:
            raise ValueError(&quot;Pivot not supported in downsample operation.&quot;)
        return PivotOps(self._df, self.by, pivot_column, values_column)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyfirst"><a class="header" href="#polarsinternalsframegroupbyfirst"><code>polars.internals.frame.GroupBy.first</code></a></h3>
<pre><code class="language-python">first() -&gt; DataFrame:
</code></pre>
<p>Aggregate the first values in the group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the first values in the group.
        &quot;&quot;&quot;
        return self._select_all().first()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbylast"><a class="header" href="#polarsinternalsframegroupbylast"><code>polars.internals.frame.GroupBy.last</code></a></h3>
<pre><code class="language-python">last() -&gt; DataFrame:
</code></pre>
<p>Aggregate the last values in the group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def last(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the last values in the group.
        &quot;&quot;&quot;
        return self._select_all().last()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbysum"><a class="header" href="#polarsinternalsframegroupbysum"><code>polars.internals.frame.GroupBy.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the sum.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the sum.
        &quot;&quot;&quot;
        return self._select_all().sum()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbymin"><a class="header" href="#polarsinternalsframegroupbymin"><code>polars.internals.frame.GroupBy.min</code></a></h3>
<pre><code class="language-python">min() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the minimal value.
        &quot;&quot;&quot;
        return self._select_all().min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbymax"><a class="header" href="#polarsinternalsframegroupbymax"><code>polars.internals.frame.GroupBy.max</code></a></h3>
<pre><code class="language-python">max() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the maximal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the maximal value.
        &quot;&quot;&quot;
        return self._select_all().max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbycount"><a class="header" href="#polarsinternalsframegroupbycount"><code>polars.internals.frame.GroupBy.count</code></a></h3>
<pre><code class="language-python">count() -&gt; DataFrame:
</code></pre>
<p>Count the number of values in each group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def count(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the number of values in each group.
        &quot;&quot;&quot;
        return self._select_all().count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbymean"><a class="header" href="#polarsinternalsframegroupbymean"><code>polars.internals.frame.GroupBy.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the mean values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the mean values.
        &quot;&quot;&quot;
        return self._select_all().mean()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyn_unique"><a class="header" href="#polarsinternalsframegroupbyn_unique"><code>polars.internals.frame.GroupBy.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; DataFrame:
</code></pre>
<p>Count the unique values per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the unique values per group.
        &quot;&quot;&quot;
        return self._select_all().n_unique()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyquantile"><a class="header" href="#polarsinternalsframegroupbyquantile"><code>polars.internals.frame.GroupBy.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; DataFrame:
</code></pre>
<p>Compute the quantile per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; DataFrame:
        &quot;&quot;&quot;
        Compute the quantile per group.
        &quot;&quot;&quot;
        return self._select_all().quantile(quantile)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbymedian"><a class="header" href="#polarsinternalsframegroupbymedian"><code>polars.internals.frame.GroupBy.median</code></a></h3>
<pre><code class="language-python">median() -&gt; DataFrame:
</code></pre>
<p>Return the median per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return the median per group.
        &quot;&quot;&quot;
        return self._select_all().median()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegroupbyagg_list"><a class="header" href="#polarsinternalsframegroupbyagg_list"><code>polars.internals.frame.GroupBy.agg_list</code></a></h3>
<pre><code class="language-python">agg_list() -&gt; DataFrame:
</code></pre>
<p>Aggregate the groups into Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg_list(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the groups into Series.
        &quot;&quot;&quot;
        return self._select_all().agg_list()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsframepivotops"><a class="header" href="#polarsinternalsframepivotops"><code>polars.internals.frame.PivotOps</code></a></h1>
<p>Utility class returned in a pivot operation.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopsfirst"><code>first()</code></a>: Get the first value per group.</li>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopssum"><code>sum()</code></a>: Get the sum per group.</li>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopsmin"><code>min()</code></a>: Get the minimal value per group.</li>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopsmax"><code>max()</code></a>: Get the maximal value per group.</li>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopsmean"><code>mean()</code></a>: Get the mean value per group.</li>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopscount"><code>count()</code></a>: Count the values per group.</li>
<li><a href="polars/internals/frame/PivotOps.html#polarsinternalsframepivotopsmedian"><code>median()</code></a>: Get the median value per group.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class PivotOps:
    &quot;&quot;&quot;
    Utility class returned in a pivot operation.
    &quot;&quot;&quot;

    def __init__(
        self,
        df: DataFrame,
        by: Union[str, tp.List[str]],
        pivot_column: str,
        values_column: str,
    ):
        self._df = df
        self.by = by
        self.pivot_column = pivot_column
        self.values_column = values_column

    def first(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the first value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;first&quot;)
        )

    def sum(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the sum per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;sum&quot;)
        )

    def min(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the minimal value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;min&quot;)
        )

    def max(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the maximal value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;max&quot;)
        )

    def mean(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the mean value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;mean&quot;)
        )

    def count(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the values per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;count&quot;)
        )

    def median(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the median value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;median&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-7"><a class="header" href="#constructor-7">Constructor</a></h2>
<pre><code class="language-python">PivotOps(df: DataFrame, 
    by: Union[str, tp.List[str]], 
    pivot_column: str, 
    values_column: str,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        df: DataFrame,
        by: Union[str, tp.List[str]],
        pivot_column: str,
        values_column: str,
    ):
        self._df = df
        self.by = by
        self.pivot_column = pivot_column
        self.values_column = values_column
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-7"><a class="header" href="#methods-7">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopsfirst"><a class="header" href="#polarsinternalsframepivotopsfirst"><code>polars.internals.frame.PivotOps.first</code></a></h3>
<pre><code class="language-python">first() -&gt; DataFrame:
</code></pre>
<p>Get the first value per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the first value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;first&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopssum"><a class="header" href="#polarsinternalsframepivotopssum"><code>polars.internals.frame.PivotOps.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; DataFrame:
</code></pre>
<p>Get the sum per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the sum per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;sum&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopsmin"><a class="header" href="#polarsinternalsframepivotopsmin"><code>polars.internals.frame.PivotOps.min</code></a></h3>
<pre><code class="language-python">min() -&gt; DataFrame:
</code></pre>
<p>Get the minimal value per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the minimal value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;min&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopsmax"><a class="header" href="#polarsinternalsframepivotopsmax"><code>polars.internals.frame.PivotOps.max</code></a></h3>
<pre><code class="language-python">max() -&gt; DataFrame:
</code></pre>
<p>Get the maximal value per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the maximal value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;max&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopsmean"><a class="header" href="#polarsinternalsframepivotopsmean"><code>polars.internals.frame.PivotOps.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; DataFrame:
</code></pre>
<p>Get the mean value per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the mean value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;mean&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopscount"><a class="header" href="#polarsinternalsframepivotopscount"><code>polars.internals.frame.PivotOps.count</code></a></h3>
<pre><code class="language-python">count() -&gt; DataFrame:
</code></pre>
<p>Count the values per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def count(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the values per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;count&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframepivotopsmedian"><a class="header" href="#polarsinternalsframepivotopsmedian"><code>polars.internals.frame.PivotOps.median</code></a></h3>
<pre><code class="language-python">median() -&gt; DataFrame:
</code></pre>
<p>Get the median value per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Get the median value per group.
        &quot;&quot;&quot;
        return wrap_df(
            self._df.pivot(self.by, self.pivot_column, self.values_column, &quot;median&quot;)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsframegbselection"><a class="header" href="#polarsinternalsframegbselection"><code>polars.internals.frame.GBSelection</code></a></h1>
<p>Utility class returned in a groupby operation.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionfirst"><code>first()</code></a>: Aggregate the first values in the group.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionlast"><code>last()</code></a>: Aggregate the last values in the group.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionsum"><code>sum()</code></a>: Reduce the groups to the sum.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionmin"><code>min()</code></a>: Reduce the groups to the minimal value.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionmax"><code>max()</code></a>: Reduce the groups to the maximal value.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectioncount"><code>count()</code></a>: Count the number of values in each group.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionmean"><code>mean()</code></a>: Reduce the groups to the mean values.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionn_unique"><code>n_unique()</code></a>: Count the unique values per group.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionquantile"><code>quantile()</code></a>: Compute the quantile per group.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionmedian"><code>median()</code></a>: Return the median per group.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionagg_list"><code>agg_list()</code></a>: Aggregate the groups into Series.</li>
<li><a href="polars/internals/frame/GBSelection.html#polarsinternalsframegbselectionapply"><code>apply()</code></a>: Apply a function over the groups.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class GBSelection:
    &quot;&quot;&quot;
    Utility class returned in a groupby operation.
    &quot;&quot;&quot;

    def __init__(
        self,
        df: &quot;PyDataFrame&quot;,
        by: Union[str, tp.List[str]],
        selection: Optional[tp.List[str]],
        downsample: bool = False,
        rule: Optional[str] = None,
        downsample_n: int = 0,
    ):
        self._df = df
        self.by = by
        self.selection = selection
        self.downsample = downsample
        self.rule = rule
        self.n = downsample_n

    def first(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the first values in the group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;first&quot;))

        return wrap_df(self._df.groupby(self.by, self.selection, &quot;first&quot;))

    def last(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the last values in the group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;last&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;last&quot;))

    def sum(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the sum.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;sum&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;sum&quot;))

    def min(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the minimal value.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;min&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;min&quot;))

    def max(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the maximal value.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;max&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;max&quot;))

    def count(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the number of values in each group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;count&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;count&quot;))

    def mean(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the mean values.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;mean&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;mean&quot;))

    def n_unique(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the unique values per group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;n_unique&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;n_unique&quot;))

    def quantile(self, quantile: float) -&gt; DataFrame:
        &quot;&quot;&quot;
        Compute the quantile per group.
        &quot;&quot;&quot;
        if self.downsample:
            raise ValueError(&quot;quantile operation not supported during downsample&quot;)
        return wrap_df(self._df.groupby_quantile(self.by, self.selection, quantile))

    def median(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return the median per group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;median&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;median&quot;))

    def agg_list(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the groups into Series.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;agg_list&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;agg_list&quot;))

    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; DataFrame:
        &quot;&quot;&quot;
        Apply a function over the groups.
        &quot;&quot;&quot;
        df = self.agg_list()
        if self.selection is None:
            raise TypeError(
                &quot;apply not available for Groupby.select_all(). Use select() instead.&quot;
            )
        for name in self.selection:
            s = df.drop_in_place(name + &quot;_agg_list&quot;).apply(func, return_dtype)
            s.rename(name, in_place=True)
            df[name] = s

        return df
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-8"><a class="header" href="#constructor-8">Constructor</a></h2>
<pre><code class="language-python">GBSelection(df: PyDataFrame, 
    by: Union[str, tp.List[str]], 
    selection: Optionaltp.List[str], 
    downsample: bool, 
    rule: Optionalstr, 
    downsample_n: int,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        df: &quot;PyDataFrame&quot;,
        by: Union[str, tp.List[str]],
        selection: Optional[tp.List[str]],
        downsample: bool = False,
        rule: Optional[str] = None,
        downsample_n: int = 0,
    ):
        self._df = df
        self.by = by
        self.selection = selection
        self.downsample = downsample
        self.rule = rule
        self.n = downsample_n
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-8"><a class="header" href="#methods-8">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionfirst"><a class="header" href="#polarsinternalsframegbselectionfirst"><code>polars.internals.frame.GBSelection.first</code></a></h3>
<pre><code class="language-python">first() -&gt; DataFrame:
</code></pre>
<p>Aggregate the first values in the group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the first values in the group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;first&quot;))

        return wrap_df(self._df.groupby(self.by, self.selection, &quot;first&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionlast"><a class="header" href="#polarsinternalsframegbselectionlast"><code>polars.internals.frame.GBSelection.last</code></a></h3>
<pre><code class="language-python">last() -&gt; DataFrame:
</code></pre>
<p>Aggregate the last values in the group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def last(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the last values in the group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;last&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;last&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionsum"><a class="header" href="#polarsinternalsframegbselectionsum"><code>polars.internals.frame.GBSelection.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the sum.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the sum.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;sum&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;sum&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionmin"><a class="header" href="#polarsinternalsframegbselectionmin"><code>polars.internals.frame.GBSelection.min</code></a></h3>
<pre><code class="language-python">min() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the minimal value.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;min&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;min&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionmax"><a class="header" href="#polarsinternalsframegbselectionmax"><code>polars.internals.frame.GBSelection.max</code></a></h3>
<pre><code class="language-python">max() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the maximal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the maximal value.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;max&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;max&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectioncount"><a class="header" href="#polarsinternalsframegbselectioncount"><code>polars.internals.frame.GBSelection.count</code></a></h3>
<pre><code class="language-python">count() -&gt; DataFrame:
</code></pre>
<p>Count the number of values in each group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def count(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the number of values in each group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;count&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;count&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionmean"><a class="header" href="#polarsinternalsframegbselectionmean"><code>polars.internals.frame.GBSelection.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; DataFrame:
</code></pre>
<p>Reduce the groups to the mean values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Reduce the groups to the mean values.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;mean&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;mean&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionn_unique"><a class="header" href="#polarsinternalsframegbselectionn_unique"><code>polars.internals.frame.GBSelection.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; DataFrame:
</code></pre>
<p>Count the unique values per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Count the unique values per group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;n_unique&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;n_unique&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionquantile"><a class="header" href="#polarsinternalsframegbselectionquantile"><code>polars.internals.frame.GBSelection.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; DataFrame:
</code></pre>
<p>Compute the quantile per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; DataFrame:
        &quot;&quot;&quot;
        Compute the quantile per group.
        &quot;&quot;&quot;
        if self.downsample:
            raise ValueError(&quot;quantile operation not supported during downsample&quot;)
        return wrap_df(self._df.groupby_quantile(self.by, self.selection, quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionmedian"><a class="header" href="#polarsinternalsframegbselectionmedian"><code>polars.internals.frame.GBSelection.median</code></a></h3>
<pre><code class="language-python">median() -&gt; DataFrame:
</code></pre>
<p>Return the median per group.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Return the median per group.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;median&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;median&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionagg_list"><a class="header" href="#polarsinternalsframegbselectionagg_list"><code>polars.internals.frame.GBSelection.agg_list</code></a></h3>
<pre><code class="language-python">agg_list() -&gt; DataFrame:
</code></pre>
<p>Aggregate the groups into Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg_list(self) -&gt; DataFrame:
        &quot;&quot;&quot;
        Aggregate the groups into Series.
        &quot;&quot;&quot;
        if self.downsample:
            return wrap_df(self._df.downsample(self.by, self.rule, self.n, &quot;agg_list&quot;))
        return wrap_df(self._df.groupby(self.by, self.selection, &quot;agg_list&quot;))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframegbselectionapply"><a class="header" href="#polarsinternalsframegbselectionapply"><code>polars.internals.frame.GBSelection.apply</code></a></h3>
<pre><code class="language-python">apply(func: Callable[[Any], Any], 
    return_dtype: OptionalTypeDataType,) -&gt; DataFrame:
</code></pre>
<p>Apply a function over the groups.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; DataFrame:
        &quot;&quot;&quot;
        Apply a function over the groups.
        &quot;&quot;&quot;
        df = self.agg_list()
        if self.selection is None:
            raise TypeError(
                &quot;apply not available for Groupby.select_all(). Use select() instead.&quot;
            )
        for name in self.selection:
            s = df.drop_in_place(name + &quot;_agg_list&quot;).apply(func, return_dtype)
            s.rename(name, in_place=True)
            df[name] = s

        return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalsfunctions"><a class="header" href="#module-polarsinternalsfunctions">Module <code>polars.internals.functions</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/internals/functions.html#polarsinternalsfunctionsget_dummies"><code>get_dummies()</code></a>: Convert categorical variables into dummy/indicator variables.</li>
<li><a href="polars/internals/functions.html#polarsinternalsfunctionsconcat"><code>concat()</code></a>: Aggregate all the Dataframes/Series in a List of DataFrames/Series to a single DataFrame/Series.</li>
<li><a href="polars/internals/functions.html#polarsinternalsfunctionsrepeat"><code>repeat()</code></a>: Repeat a single value n times and collect into a Series.</li>
<li><a href="polars/internals/functions.html#polarsinternalsfunctionsarg_where"><code>arg_where()</code></a>: Get index values where Boolean mask evaluate True.</li>
<li><a href="polars/internals/functions.html#polarsinternalsfunctionsdate_range"><code>date_range()</code></a>: Create a date range of type <code>Datetime</code>.</li>
</ul>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsfunctionsget_dummies"><a class="header" href="#polarsinternalsfunctionsget_dummies"><code>polars.internals.functions.get_dummies</code></a></h3>
<pre><code class="language-python">get_dummies(df: pli.DataFrame) -&gt; pli.DataFrame:
</code></pre>
<p>Convert categorical variables into dummy/indicator variables.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>df</code>]: DataFrame to convert.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def get_dummies(df: &quot;pli.DataFrame&quot;) -&gt; &quot;pli.DataFrame&quot;:
    &quot;&quot;&quot;
    Convert categorical variables into dummy/indicator variables.

    Parameters
    ----------
    df
        DataFrame to convert.
    &quot;&quot;&quot;
    return df.to_dummies()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsfunctionsconcat"><a class="header" href="#polarsinternalsfunctionsconcat"><code>polars.internals.functions.concat</code></a></h3>
<pre><code class="language-python">concat(
    items: Union[Sequencepli.DataFrame, Sequencepli.Series, Sequencepli.LazyFrame], 
    rechunk: bool, 
    how: str,
) -&gt; Union[pli.DataFrame, pli.Series, pli.LazyFrame]:
</code></pre>
<p>Aggregate all the Dataframes/Series in a List of DataFrames/Series to a single DataFrame/Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>items</code>]: DataFrames/Series/LazyFrames to concatenate.</p>
</li>
<li>
<p>[<code>rechunk</code>]: rechunk the final DataFrame/Series.</p>
</li>
<li>
<p>[<code>how</code>]: Only used if the items are DataFrames.</p>
<p>On of {&quot;vertical&quot;, &quot;diagonal&quot;}.
Vertical: Applies multiple <code>vstack</code> operations.
Diagonal: Finds a union between the column schemas and fills missing column values with null.</p>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def concat(
    items: Union[
        Sequence[&quot;pli.DataFrame&quot;], Sequence[&quot;pli.Series&quot;], Sequence[&quot;pli.LazyFrame&quot;]
    ],
    rechunk: bool = True,
    how: str = &quot;vertical&quot;,
) -&gt; Union[&quot;pli.DataFrame&quot;, &quot;pli.Series&quot;, &quot;pli.LazyFrame&quot;]:
    &quot;&quot;&quot;
    Aggregate all the Dataframes/Series in a List of DataFrames/Series to a single DataFrame/Series.

    Parameters
    ----------
    items
        DataFrames/Series/LazyFrames to concatenate.
    rechunk
        rechunk the final DataFrame/Series.
    how
        Only used if the items are DataFrames.

        On of {&quot;vertical&quot;, &quot;diagonal&quot;}.
        Vertical: Applies multiple `vstack` operations.
        Diagonal: Finds a union between the column schemas and fills missing column values with null.
    &quot;&quot;&quot;
    if not len(items) &gt; 0:
        raise ValueError(&quot;cannot concat empty list&quot;)

    out: Union[&quot;pli.Series&quot;, &quot;pli.DataFrame&quot;, &quot;pli.LazyFrame&quot;]
    if isinstance(items[0], pli.DataFrame):
        if how == &quot;vertical&quot;:
            out = pli.wrap_df(_concat_df(items))
        elif how == &quot;diagonal&quot;:
            out = pli.wrap_df(_diag_concat_df(items))
        else:
            raise ValueError(
                f&quot;how should be one of {'vertical', 'diagonal'}, got {how}&quot;
            )
    elif isinstance(items[0], pli.LazyFrame):
        return pli.wrap_ldf(_concat_lf(items, rechunk))
    else:
        out = pli.wrap_s(_concat_series(items))

    if rechunk:
        return out.rechunk()  # type: ignore
    return out
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsfunctionsrepeat"><a class="header" href="#polarsinternalsfunctionsrepeat"><code>polars.internals.functions.repeat</code></a></h3>
<pre><code class="language-python">repeat(
    val: Union[int, float, str, bool], 
    n: int, 
    name: Optionalstr,
) -&gt; pli.Series:
</code></pre>
<p>Repeat a single value n times and collect into a Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>val</code>]: Value to repeat.</li>
<li>[<code>n</code>]: Number of repeats.</li>
<li>[<code>name</code>]: Optional name of the Series.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def repeat(
    val: Union[int, float, str, bool], n: int, name: Optional[str] = None
) -&gt; &quot;pli.Series&quot;:
    &quot;&quot;&quot;
    Repeat a single value n times and collect into a Series.

    Parameters
    ----------
    val
        Value to repeat.
    n
        Number of repeats.
    name
        Optional name of the Series.
    &quot;&quot;&quot;
    if name is None:
        name = &quot;&quot;

    dtype = py_type_to_dtype(type(val))
    s = pli.Series._repeat(name, val, n, dtype)
    return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsfunctionsarg_where"><a class="header" href="#polarsinternalsfunctionsarg_where"><code>polars.internals.functions.arg_where</code></a></h3>
<pre><code class="language-python">arg_where(mask: pli.Series) -&gt; pli.Series:
</code></pre>
<p>Get index values where Boolean mask evaluate True.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mask</code>]: Boolean Series.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>UInt32 Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def arg_where(mask: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
    &quot;&quot;&quot;
    Get index values where Boolean mask evaluate True.

    Parameters
    ----------
    mask
        Boolean Series.

    Returns
    -------
    UInt32 Series
    &quot;&quot;&quot;
    return mask.arg_true()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsfunctionsdate_range"><a class="header" href="#polarsinternalsfunctionsdate_range"><code>polars.internals.functions.date_range</code></a></h3>
<pre><code class="language-python">date_range(
    low: datetime, 
    high: datetime, 
    interval: timedelta, 
    closed: Optionalstr, 
    name: Optionalstr,
) -&gt; pli.Series:
</code></pre>
<p>Create a date range of type <code>Datetime</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>low</code>]: Lower bound of the date range</li>
<li>[<code>high</code>]: Upper bound of the date range</li>
<li>[<code>interval</code>]: Interval periods
closed {None, 'left', 'right'}
Make the interval closed to the 'left', 'right', or both sides (None, the default).</li>
<li>[<code>name</code>]: Name of the output Series
<strong>Returns:</strong></li>
</ul>
<p>A Series of type <code>Datetime</code></p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import polars as pl
from datetime import datetime, timedelta
pl.date_range(datetime(1985, 1, 1), datetime(2015, 7, 1), timedelta(days=1, hours=12))
shape: (7426,)
Series: '' [datetime]
[
1985-01-01 00:00:00
1985-01-02 12:00:00
1985-01-04 00:00:00
1985-01-05 12:00:00
1985-01-07 00:00:00
1985-01-08 12:00:00
1985-01-10 00:00:00
1985-01-11 12:00:00
1985-01-13 00:00:00
1985-01-14 12:00:00
1985-01-16 00:00:00
1985-01-17 12:00:00
...
2015-06-14 00:00:00
2015-06-15 12:00:00
2015-06-17 00:00:00
2015-06-18 12:00:00
2015-06-20 00:00:00
2015-06-21 12:00:00
2015-06-23 00:00:00
2015-06-24 12:00:00
2015-06-26 00:00:00
2015-06-27 12:00:00
2015-06-29 00:00:00
2015-06-30 12:00:00
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def date_range(
    low: datetime,
    high: datetime,
    interval: timedelta,
    closed: Optional[str] = None,
    name: Optional[str] = None,
) -&gt; &quot;pli.Series&quot;:
    &quot;&quot;&quot;
    Create a date range of type `Datetime`.

    Parameters
    ----------
    low
        Lower bound of the date range
    high
        Upper bound of the date range
    interval
        Interval periods
    closed {None, 'left', 'right'}
        Make the interval closed to the 'left', 'right', or both sides (None, the default).
    name
        Name of the output Series
    Returns
    -------
    A Series of type `Datetime`

    Examples
    --------
    &gt;&gt;&gt; import polars as pl
    &gt;&gt;&gt; from datetime import datetime, timedelta
    &gt;&gt;&gt; pl.date_range(datetime(1985, 1, 1), datetime(2015, 7, 1), timedelta(days=1, hours=12))
    shape: (7426,)
    Series: '' [datetime]
    [
        1985-01-01 00:00:00
        1985-01-02 12:00:00
        1985-01-04 00:00:00
        1985-01-05 12:00:00
        1985-01-07 00:00:00
        1985-01-08 12:00:00
        1985-01-10 00:00:00
        1985-01-11 12:00:00
        1985-01-13 00:00:00
        1985-01-14 12:00:00
        1985-01-16 00:00:00
        1985-01-17 12:00:00
        ...
        2015-06-14 00:00:00
        2015-06-15 12:00:00
        2015-06-17 00:00:00
        2015-06-18 12:00:00
        2015-06-20 00:00:00
        2015-06-21 12:00:00
        2015-06-23 00:00:00
        2015-06-24 12:00:00
        2015-06-26 00:00:00
        2015-06-27 12:00:00
        2015-06-29 00:00:00
        2015-06-30 12:00:00
    ]
    &quot;&quot;&quot;
    values = np.arange(low, high, interval, dtype=&quot;datetime64[ms]&quot;)
    if closed in (None, &quot;right&quot;) and (high - low) % interval == timedelta(0):
        values = np.append(values, np.array(high, dtype=&quot;datetime64[ms]&quot;))
    if closed == &quot;right&quot;:
        values = values[1:]
    return pli.Series(name=name, values=values.astype(np.int64)).cast(Datetime)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalslazy_frame"><a class="header" href="#module-polarsinternalslazy_frame">Module <code>polars.internals.lazy_frame</code></a></h1>
<p>This module contains all expressions and classes needed for lazy computation/ query execution.</p>
<p><strong>Functions:</strong></p>
<p>: </p>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framewrap_ldf"><a class="header" href="#polarsinternalslazy_framewrap_ldf"><code>polars.internals.lazy_frame.wrap_ldf</code></a></h3>
<pre><code class="language-python">wrap_ldf(ldf: PyLazyFrame) -&gt; LazyFrame:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def wrap_ldf(ldf: &quot;PyLazyFrame&quot;) -&gt; &quot;LazyFrame&quot;:
    return LazyFrame._from_pyldf(ldf)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalslazy_framelazyframe"><a class="header" href="#polarsinternalslazy_framelazyframe"><code>polars.internals.lazy_frame.LazyFrame</code></a></h1>
<p>Representation of a Lazy computation graph/ query.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframescan_csv"><code>scan_csv()</code></a>: See Also: <code>pl.scan_csv</code></li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframescan_parquet"><code>scan_parquet()</code></a>: See Also: <code>pl.scan_parquet</code></li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframescan_ipc"><code>scan_ipc()</code></a>: See Also: <code>pl.scan_ipc</code></li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframepipe"><code>pipe()</code></a>: Apply a function on Self.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframedescribe_plan"><code>describe_plan()</code></a>: A string representation of the unoptimized query plan.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframedescribe_optimized_plan"><code>describe_optimized_plan()</code></a>: A string representation of the optimized query plan.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeshow_graph"><code>show_graph()</code></a>: Show a plot of the query plan. Note that you should have graphviz installed.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeinspect"><code>inspect()</code></a>: Prints the value that this node in the computation graph evaluates to and passes on the value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeinspectinspect"><code>inspect()</code></a>: </li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframesort"><code>sort()</code></a>: Sort the DataFrame by:</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframecollect"><code>collect()</code></a>: Collect into a DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframefetch"><code>fetch()</code></a>: Fetch is like a collect operation, but it overwrites the number of rows read by every scan</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframecolumns"><code>columns()</code></a>: Get or set column names.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframecache"><code>cache()</code></a>: Cache the result once the execution of the physical plan hits this node.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframefilter"><code>filter()</code></a>: Filter the rows in the DataFrame based on a predicate expression.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeselect"><code>select()</code></a>: Select columns from this DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframegroupby"><code>groupby()</code></a>: Start a groupby operation.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframejoin"><code>join()</code></a>: Add a join operation to the Logical Plan.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframewith_columns"><code>with_columns()</code></a>: Add or overwrite multiple columns in a DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframewith_column"><code>with_column()</code></a>: Add or overwrite column in a DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframedrop"><code>drop()</code></a>: Remove one or multiple columns from a DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframewith_column_renamed"><code>with_column_renamed()</code></a>: Rename a column in the DataFrame</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframerename"><code>rename()</code></a>: Rename column names. This does not preserve column order.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframereverse"><code>reverse()</code></a>: Reverse the DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeslice"><code>slice()</code></a>: Slice the DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframelimit"><code>limit()</code></a>: Limit the DataFrame to the first <code>n</code> rows. Note if you don't want the rows to be scanned,</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframehead"><code>head()</code></a>: Gets the first <code>n</code> rows of the DataFrame. You probably don't want to use this!</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframetail"><code>tail()</code></a>: Get the last <code>n</code> rows of the DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframelast"><code>last()</code></a>: Get the last row of the DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframefirst"><code>first()</code></a>: Get the first row of the DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframewith_row_count"><code>with_row_count()</code></a>: Add a column at index 0 that counts the rows.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframefill_null"><code>fill_null()</code></a>: Fill missing values</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframefill_nan"><code>fill_nan()</code></a>: Fill floating point NaN values.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframestd"><code>std()</code></a>: Aggregate the columns in the DataFrame to their standard deviation value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframevar"><code>var()</code></a>: Aggregate the columns in the DataFrame to their variance value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframemax"><code>max()</code></a>: Aggregate the columns in the DataFrame to their maximum value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframemin"><code>min()</code></a>: Aggregate the columns in the DataFrame to their minimum value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframesum"><code>sum()</code></a>: Aggregate the columns in the DataFrame to their sum value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframemean"><code>mean()</code></a>: Aggregate the columns in the DataFrame to their mean value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframemedian"><code>median()</code></a>: Aggregate the columns in the DataFrame to their median value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframequantile"><code>quantile()</code></a>: Aggregate the columns in the DataFrame to their quantile value.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeexplode"><code>explode()</code></a>: Explode lists to long format.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframedrop_duplicates"><code>drop_duplicates()</code></a>: Drop duplicate rows from this DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframedrop_nulls"><code>drop_nulls()</code></a>: Drop rows with null values from this DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframemelt"><code>melt()</code></a>: Unpivot DataFrame to long format.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframemap"><code>map()</code></a>: Apply a custom function. It is important that the function returns a Polars DataFrame.</li>
<li><a href="polars/internals/lazy_frame/LazyFrame.html#polarsinternalslazy_framelazyframeinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class LazyFrame:
    &quot;&quot;&quot;
    Representation of a Lazy computation graph/ query.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._ldf: PyLazyFrame

    @staticmethod
    def _from_pyldf(ldf: &quot;PyLazyFrame&quot;) -&gt; &quot;LazyFrame&quot;:
        self = LazyFrame.__new__(LazyFrame)
        self._ldf = ldf
        return self

    @staticmethod
    def scan_csv(
        file: str,
        infer_schema_length: Optional[int] = 100,
        has_headers: bool = True,
        ignore_errors: bool = False,
        sep: str = &quot;,&quot;,
        skip_rows: int = 0,
        stop_after_n_rows: Optional[int] = None,
        cache: bool = True,
        dtype: Optional[Dict[str, Type[DataType]]] = None,
        low_memory: bool = False,
        comment_char: Optional[str] = None,
        quote_char: Optional[str] = r'&quot;',
        null_values: Optional[Union[str, tp.List[str], Dict[str, str]]] = None,
        with_column_names: Optional[Callable[[tp.List[str]], tp.List[str]]] = None,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        See Also: `pl.scan_csv`
        &quot;&quot;&quot;
        dtype_list: Optional[tp.List[Tuple[str, Type[DataType]]]] = None
        if dtype is not None:
            dtype_list = []
            for k, v in dtype.items():
                dtype_list.append((k, py_type_to_dtype(v)))
        processed_null_values = _process_null_values(null_values)

        self = LazyFrame.__new__(LazyFrame)
        self._ldf = PyLazyFrame.new_from_csv(
            file,
            sep,
            has_headers,
            ignore_errors,
            skip_rows,
            stop_after_n_rows,
            cache,
            dtype_list,
            low_memory,
            comment_char,
            quote_char,
            processed_null_values,
            infer_schema_length,
            with_column_names,
        )
        return self

    @staticmethod
    def scan_parquet(
        file: str, stop_after_n_rows: Optional[int] = None, cache: bool = True
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        See Also: `pl.scan_parquet`
        &quot;&quot;&quot;

        self = LazyFrame.__new__(LazyFrame)
        self._ldf = PyLazyFrame.new_from_parquet(file, stop_after_n_rows, cache)
        return self

    @staticmethod
    def scan_ipc(
        file: str, stop_after_n_rows: Optional[int] = None, cache: bool = True
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        See Also: `pl.scan_ipc`
        &quot;&quot;&quot;

        self = LazyFrame.__new__(LazyFrame)
        self._ldf = PyLazyFrame.new_from_ipc(file, stop_after_n_rows, cache)
        return self

    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:
        &quot;&quot;&quot;
        Apply a function on Self.

        Parameters
        ----------
        func
            Callable.
        args
            Arguments.
        kwargs
            Keyword arguments.
        &quot;&quot;&quot;
        return func(self, *args, **kwargs)

    def describe_plan(self) -&gt; str:
        &quot;&quot;&quot;
        A string representation of the unoptimized query plan.
        &quot;&quot;&quot;
        return self._ldf.describe_plan()

    def describe_optimized_plan(
        self,
        type_coercion: bool = True,
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        simplify_expression: bool = True,
    ) -&gt; str:
        &quot;&quot;&quot;
        A string representation of the optimized query plan.
        &quot;&quot;&quot;

        ldf = self._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache=False,
        )

        return ldf.describe_optimized_plan()

    def show_graph(
        self,
        optimized: bool = True,
        show: bool = True,
        output_path: Optional[str] = None,
        raw_output: bool = False,
        figsize: Tuple[float, float] = (16.0, 12.0),
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Show a plot of the query plan. Note that you should have graphviz installed.

        Parameters
        ----------
        optimized
            Optimize the query plan.
        show
            Show the figure.
        output_path
            Write the figure to disk.
        raw_output
            Return dot syntax.
        figsize
            Passed to matlotlib if `show` == True.
        &quot;&quot;&quot;
        try:
            import matplotlib.image as mpimg
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError(
                &quot;Graphviz dot binary should be on your PATH and matplotlib should be installed to show graph.&quot;
            )
        dot = self._ldf.to_dot(optimized)
        if raw_output:
            return dot
        with tempfile.TemporaryDirectory() as tmpdir_name:
            dot_path = os.path.join(tmpdir_name, &quot;dot&quot;)
            with open(dot_path, &quot;w&quot;) as f:
                f.write(dot)

            subprocess.run([&quot;dot&quot;, &quot;-Nshape=box&quot;, &quot;-Tpng&quot;, &quot;-O&quot;, dot_path])
            out_path = os.path.join(tmpdir_name, &quot;dot.png&quot;)

            if output_path is not None:
                shutil.copy(out_path, output_path)

            if show:
                plt.figure(figsize=figsize)
                img = mpimg.imread(out_path)
                plt.imshow(img)
                plt.show()
        return None

    def inspect(self, fmt: str = &quot;{}&quot;) -&gt; &quot;LazyFrame&quot;:  # type: ignore
        &quot;&quot;&quot;
        Prints the value that this node in the computation graph evaluates to and passes on the value.

        &gt;&gt;&gt; (df.select(pl.col(&quot;foo&quot;).cumsum().alias(&quot;bar&quot;))
        &gt;&gt;&gt;    .inspect()  # print the node before the filter
        &gt;&gt;&gt;    .filter(pl.col(&quot;bar&quot;) == pl.col(&quot;foo&quot;)))
        &quot;&quot;&quot;

        def inspect(s: pli.DataFrame) -&gt; pli.DataFrame:
            print(fmt.format(s))  # type: ignore
            return s

        return self.map(inspect, predicate_pushdown=True, projection_pushdown=True)

    def sort(
        self,
        by: Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]],
        reverse: Union[bool, tp.List[bool]] = False,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Sort the DataFrame by:

            - A single column name
            - An expression
            - Multiple expressions

        Parameters
        ----------
        by
            Column (expressions) to sort by.
        reverse
            Whether or not to sort in reverse order.
        &quot;&quot;&quot;
        if type(by) is str:
            return wrap_ldf(self._ldf.sort(by, reverse))
        if type(reverse) is bool:
            reverse = [reverse]

        by = pli.expr_to_lit_or_expr(by, str_to_lit=False)
        by = pli._selection_to_pyexpr_list(by)
        return wrap_ldf(self._ldf.sort_by_exprs(by, reverse))

    def collect(
        self,
        type_coercion: bool = True,
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        simplify_expression: bool = True,
        string_cache: bool = False,
        no_optimization: bool = False,
    ) -&gt; pli.DataFrame:
        &quot;&quot;&quot;
        Collect into a DataFrame.

        Note: use `fetch` if you want to run this query on the first `n` rows only.
        This can be a huge time saver in debugging queries.

        Parameters
        ----------
        type_coercion
            Do type coercion optimization.
        predicate_pushdown
            Do predicate pushdown optimization.
        projection_pushdown
            Do projection pushdown optimization.
        simplify_expression
            Run simplify expressions optimization.
        string_cache
            Use a global string cache in this query.
            This is needed if you want to join on categorical columns.

            Caution!
                If you already have set a global string cache, set this to `False` as this will reset the
                global cache when the query is finished.
        no_optimization
            Turn off optimizations.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        if no_optimization:
            predicate_pushdown = False
            projection_pushdown = False

        ldf = self._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache,
        )
        return pli.wrap_df(ldf.collect())

    def fetch(
        self,
        n_rows: int = 500,
        type_coercion: bool = True,
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        simplify_expression: bool = True,
        string_cache: bool = True,
        no_optimization: bool = False,
    ) -&gt; pli.DataFrame:
        &quot;&quot;&quot;
        Fetch is like a collect operation, but it overwrites the number of rows read by every scan
        operation. This is a utility that helps debug a query on a smaller number of rows.

        Note that the fetch does not guarantee the final number of rows in the DataFrame.
        Filter, join operations and a lower number of rows available in the scanned file influence
        the final number of rows.

        Parameters
        ----------
        n_rows
            Collect n_rows from the data sources.
        type_coercion
            Run type coercion optimization.
        predicate_pushdown
            Run predicate pushdown optimization.
        projection_pushdown
            Run projection pushdown optimization.
        simplify_expression
            Run simplify expressions optimization.
        string_cache
            Use a global string cache in this query.
            This is needed if you want to join on categorical columns.
        no_optimization
            Turn off optimizations.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        if no_optimization:
            predicate_pushdown = False
            projection_pushdown = False

        ldf = self._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache,
        )
        return pli.wrap_df(ldf.fetch(n_rows))

    @property
    def columns(self) -&gt; tp.List[str]:
        &quot;&quot;&quot;
        Get or set column names.

        Examples
        --------

        &gt;&gt;&gt; df = (pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    }).lazy()
        &gt;&gt;&gt;     .select([&quot;foo&quot;, &quot;bar&quot;]))

        &gt;&gt;&gt; df.columns
        [&quot;foo&quot;, &quot;bar&quot;]

        &quot;&quot;&quot;
        return self._ldf.columns()

    def cache(
        self,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Cache the result once the execution of the physical plan hits this node.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.cache())

    def filter(self, predicate: Union[&quot;pli.Expr&quot;, str]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Filter the rows in the DataFrame based on a predicate expression.

        Parameters
        ----------
        predicate
            Expression that evaluates to a boolean Series.

        Examples
        --------

        &gt;&gt;&gt; lf = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; }).lazy()
        &gt;&gt;&gt; # Filter on one condition
        &gt;&gt;&gt; lf.filter(pl.col(&quot;foo&quot;) &lt; 3).collect()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ b   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt;  # Filter on multiple conditions
        &gt;&gt;&gt; lf.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;)).collect()
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        if isinstance(predicate, str):
            predicate = pli.col(predicate)
        return wrap_ldf(self._ldf.filter(predicate._pyexpr))

    def select(
        self, exprs: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Select columns from this DataFrame.

        Parameters
        ----------
        exprs
            Column or columns to select.
        &quot;&quot;&quot;
        exprs = pli._selection_to_pyexpr_list(exprs)
        return wrap_ldf(self._ldf.select(exprs))

    def groupby(
        self,
        by: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]],
        maintain_order: bool = False,
    ) -&gt; &quot;LazyGroupBy&quot;:
        &quot;&quot;&quot;
        Start a groupby operation.

        Parameters
        ----------
        by
            Column(s) to group by.
        maintain_order
            Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
        &quot;&quot;&quot;
        new_by: tp.List[PyExpr]
        if isinstance(by, list):
            new_by = []
            for e in by:
                if isinstance(e, str):
                    e = pli.col(e)
                new_by.append(e._pyexpr)
        elif isinstance(by, str):
            new_by = [pli.col(by)._pyexpr]
        elif isinstance(by, pli.Expr):
            new_by = [by._pyexpr]
        lgb = self._ldf.groupby(new_by, maintain_order)
        return LazyGroupBy(lgb)

    def join(
        self,
        ldf: &quot;LazyFrame&quot;,
        left_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        right_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        on: Optional[Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]] = None,
        how: str = &quot;inner&quot;,
        suffix: str = &quot;_right&quot;,
        allow_parallel: bool = True,
        force_parallel: bool = False,
        asof_by: Optional[Union[str, tp.List[str]]] = None,
        asof_by_left: Optional[Union[str, tp.List[str]]] = None,
        asof_by_right: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add a join operation to the Logical Plan.

        Parameters
        ----------
        ldf
            Lazy DataFrame to join with.
        left_on
            Join column of the left DataFrame.
        right_on
            Join column of the right DataFrame.
        on
            Join column of both DataFrames. If set, `left_on` and `right_on` should be None.
        how
            one of:
                &quot;inner&quot;
                &quot;left&quot;
                &quot;outer&quot;
                &quot;asof&quot;,
                &quot;cross&quot;
        suffix
            Suffix to append to columns with a duplicate name.
        allow_parallel
            Allow the physical plan to optionally evaluate the computation of both DataFrames up to the join in parallel.
        force_parallel
            Force the physical plan to evaluate the computation of both DataFrames up to the join in parallel.
        asof_by
            join on these columns before doing asof join
        asof_by_left
            join on these columns before doing asof join
        asof_by_right
            join on these columns before doing asof join

        # Asof joins
        This is similar to a left-join except that we match on nearest key rather than equal keys.
        The keys must be sorted to perform an asof join

        &quot;&quot;&quot;
        if how == &quot;cross&quot;:
            return wrap_ldf(
                self._ldf.join(
                    ldf._ldf,
                    [],
                    [],
                    allow_parallel,
                    force_parallel,
                    how,
                    suffix,
                    [],
                    [],
                )
            )

        left_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(left_on, (str, pli.Expr)):
            left_on_ = [left_on]  # type: ignore[assignment]
        else:
            left_on_ = left_on

        right_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(right_on, (str, pli.Expr)):
            right_on_ = [right_on]  # type: ignore[assignment]
        else:
            right_on_ = right_on

        if isinstance(on, str):
            left_on_ = [on]
            right_on_ = [on]
        elif isinstance(on, list):
            left_on_ = on
            right_on_ = on

        if left_on_ is None or right_on_ is None:
            raise ValueError(&quot;You should pass the column to join on as an argument.&quot;)

        new_left_on = []
        for column in left_on_:
            if isinstance(column, str):
                column = pli.col(column)
            new_left_on.append(column._pyexpr)
        new_right_on = []
        for column in right_on_:
            if isinstance(column, str):
                column = pli.col(column)
            new_right_on.append(column._pyexpr)

        # set asof_by

        left_asof_by_: Union[tp.List[str], None]
        if isinstance(asof_by_left, str):
            left_asof_by_ = [asof_by_left]  # type: ignore[assignment]
        else:
            left_asof_by_ = asof_by_left

        right_asof_by_: Union[tp.List[str], None]
        if isinstance(asof_by_right, (str, pli.Expr)):
            right_asof_by_ = [asof_by_right]  # type: ignore[assignment]
        else:
            right_asof_by_ = asof_by_right

        if isinstance(asof_by, str):
            left_asof_by_ = [asof_by]
            right_asof_by_ = [asof_by]
        elif isinstance(asof_by, list):
            left_asof_by_ = asof_by
            right_asof_by_ = asof_by

        if left_asof_by_ is None:
            left_asof_by_ = []
        if right_asof_by_ is None:
            right_asof_by_ = []

        return wrap_ldf(
            self._ldf.join(
                ldf._ldf,
                new_left_on,
                new_right_on,
                allow_parallel,
                force_parallel,
                how,
                suffix,
                left_asof_by_,
                right_asof_by_,
            )
        )

    def with_columns(
        self, exprs: Union[tp.List[&quot;pli.Expr&quot;], &quot;pli.Expr&quot;]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite multiple columns in a DataFrame.

        Parameters
        ----------
        exprs
            List of Expressions that evaluate to columns.
        &quot;&quot;&quot;
        if isinstance(exprs, pli.Expr):
            return self.with_column(exprs)

        pyexprs = []

        for e in exprs:
            if isinstance(e, pli.Expr):
                pyexprs.append(e._pyexpr)
            elif isinstance(e, pli.Series):
                pyexprs.append(pli.lit(e)._pyexpr)

        return wrap_ldf(self._ldf.with_columns(pyexprs))

    def with_column(self, expr: &quot;pli.Expr&quot;) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite column in a DataFrame.

        Parameters
        ----------
        expr
            Expression that evaluates to column.
        &quot;&quot;&quot;
        return self.with_columns([expr])

    def drop(self, columns: Union[str, tp.List[str]]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Remove one or multiple columns from a DataFrame.

        Parameters
        ----------
        columns
            - Name of the column that should be removed.
            - List of column names.

        &quot;&quot;&quot;
        if isinstance(columns, str):
            columns = [columns]
        return wrap_ldf(self._ldf.drop_columns(columns))

    def with_column_renamed(self, existing_name: str, new_name: str) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Rename a column in the DataFrame
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.with_column_renamed(existing_name, new_name))

    def rename(self, mapping: Dict[str, str]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Rename column names. This does not preserve column order.

        Parameters
        ----------
        mapping
            Key value pairs that map from old name to new name.
        &quot;&quot;&quot;
        existing = list(mapping.keys())
        new = list(mapping.values())
        return wrap_ldf(self._ldf.rename(existing, new))

    def reverse(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Reverse the DataFrame.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.reverse())

    def shift(self, periods: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.shift(periods))

    def shift_and_fill(
        self, periods: int, fill_value: Union[&quot;pli.Expr&quot;, int, str, float]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            fill None values with the result of this expression.
        &quot;&quot;&quot;
        if not isinstance(fill_value, pli.Expr):
            fill_value = pli.lit(fill_value)
        return wrap_ldf(self._ldf.shift_and_fill(periods, fill_value._pyexpr))

    def slice(self, offset: int, length: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Slice the DataFrame.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.slice(offset, length))

    def limit(self, n: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Limit the DataFrame to the first `n` rows. Note if you don't want the rows to be scanned,
        use the `fetch` operation.

        Parameters
        ----------
        n
            Number of rows.
        &quot;&quot;&quot;
        return self.slice(0, n)

    def head(self, n: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Gets the first `n` rows of the DataFrame. You probably don't want to use this!

        Consider using the `fetch` operation. The `fetch` operation will truly load the first `n`
        rows lazily.

        This operation instead loads all the rows and only applies the `head` at the end.

        Parameters
        ----------
        n
            Number of rows.
        &quot;&quot;&quot;
        return self.limit(n)

    def tail(self, n: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Get the last `n` rows of the DataFrame.

        Parameters
        ----------
        n
            Number of rows.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.tail(n))

    def last(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Get the last row of the DataFrame.
        &quot;&quot;&quot;
        return self.tail(1)

    def first(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Get the first row of the DataFrame.
        &quot;&quot;&quot;
        return self.slice(0, 1)

    def with_row_count(self, name: str = &quot;row_nr&quot;) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add a column at index 0 that counts the rows.

        Parameters
        ----------
        name
            Name of the column to add.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.with_row_count(name))

    def fill_null(self, fill_value: Union[int, str, &quot;pli.Expr&quot;]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Fill missing values

        Parameters
        ----------
        fill_value
            Value to fill the missing values with
        &quot;&quot;&quot;
        if not isinstance(fill_value, pli.Expr):
            fill_value = pli.lit(fill_value)
        return wrap_ldf(self._ldf.fill_null(fill_value._pyexpr))

    def fill_nan(self, fill_value: Union[int, str, float, &quot;pli.Expr&quot;]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Fill floating point NaN values.

        ..warning::

            NOTE that floating point NaN (No a Number) are not missing values!
            to replace missing values, use `fill_null`.


        Parameters
        ----------
        fill_value
            Value to fill the NaN values with
        &quot;&quot;&quot;
        if not isinstance(fill_value, pli.Expr):
            fill_value = pli.lit(fill_value)
        return wrap_ldf(self._ldf.fill_nan(fill_value._pyexpr))

    def std(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their standard deviation value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.std())

    def var(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their variance value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.var())

    def max(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their maximum value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.max())

    def min(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their minimum value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.min())

    def sum(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their sum value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.sum())

    def mean(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their mean value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.mean())

    def median(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their median value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.median())

    def quantile(self, quantile: float) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their quantile value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.quantile(quantile))

    def explode(
        self, columns: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Explode lists to long format.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬────────────╮
        │ letters ┆ nrs        │
        │ ---     ┆ ---        │
        │ str     ┆ list [i64] │
        ╞═════════╪════════════╡
        │ &quot;c&quot;     ┆ [1, 2]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [1, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [4, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [5, 5, 5]  │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [6]        │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ [2, 1, 2]  │
        ╰─────────┴────────────╯
        &gt;&gt;&gt; df.explode(&quot;nrs&quot;)
        shape: (13, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ ...     ┆ ... │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        columns = pli._selection_to_pyexpr_list(columns)
        return wrap_ldf(self._ldf.explode(columns))

    def drop_duplicates(
        self,
        maintain_order: bool = False,
        subset: Optional[Union[tp.List[str], str]] = None,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Drop duplicate rows from this DataFrame.
        Note that this fails if there is a column of type `List` in the DataFrame.
        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_ldf(self._ldf.drop_duplicates(maintain_order, subset))

    def drop_nulls(
        self, subset: Optional[Union[tp.List[str], str]] = None
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Drop rows with null values from this DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, None, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.lazy().drop_nulls().collect()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        This method only drops nulls row-wise if any single value of the row is null.

        Below are some example snippets that show how you could drop null values based on other
        conditions

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {
        &gt;&gt;&gt;        &quot;a&quot;: [None, None, None, None],
        &gt;&gt;&gt;        &quot;b&quot;: [1, 2, None, 1],
        &gt;&gt;&gt;        &quot;c&quot;: [1, None, None, 1],
        &gt;&gt;&gt;    }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df
        shape: (4, 3)
        ┌──────┬──────┬──────┐
        │ a    ┆ b    ┆ c    │
        │ ---  ┆ ---  ┆ ---  │
        │ f64  ┆ i64  ┆ i64  │
        ╞══════╪══════╪══════╡
        │ null ┆ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1    ┆ 1    │
        └──────┴──────┴──────┘

        &gt;&gt;&gt; # drop a row only if all values are null
        &gt;&gt;&gt; df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
        shape: (3, 3)
        ┌──────┬─────┬──────┐
        │ a    ┆ b   ┆ c    │
        │ ---  ┆ --- ┆ ---  │
        │ f64  ┆ i64 ┆ i64  │
        ╞══════╪═════╪══════╡
        │ null ┆ 1   ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2   ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1   ┆ 1    │
        └──────┴─────┴──────┘

        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_ldf(self._ldf.drop_nulls(subset))

    def melt(
        self, id_vars: Union[str, tp.List[str]], value_vars: Union[str, tp.List[str]]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Unpivot DataFrame to long format.

        Parameters
        ----------
        id_vars
            Columns to use as identifier variables.
        value_vars
            Values to use as identifier variables.
        &quot;&quot;&quot;
        if isinstance(value_vars, str):
            value_vars = [value_vars]
        if isinstance(id_vars, str):
            id_vars = [id_vars]
        return wrap_ldf(self._ldf.melt(id_vars, value_vars))

    def map(
        self,
        f: Callable[[pli.DataFrame], pli.DataFrame],
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        no_optimizations: bool = False,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Apply a custom function. It is important that the function returns a Polars DataFrame.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        predicate_pushdown
            Allow predicate pushdown optimization to pass this node.
        projection_pushdown
            Allow projection pushdown optimization to pass this node.
        no_optimizations
            Turn off all optimizations past this point.
        &quot;&quot;&quot;
        if not no_optimizations:
            predicate_pushdown = False
            projection_pushdown = False
        return wrap_ldf(self._ldf.map(f, predicate_pushdown, projection_pushdown))

    def interpolate(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return self.select(pli.col(&quot;*&quot;).interpolate())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-9"><a class="header" href="#constructor-9">Constructor</a></h2>
<pre><code class="language-python">LazyFrame()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self) -&gt; None:
        self._ldf: PyLazyFrame
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-9"><a class="header" href="#methods-9">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframescan_csv"><a class="header" href="#polarsinternalslazy_framelazyframescan_csv"><code>polars.internals.lazy_frame.LazyFrame.scan_csv</code></a></h3>
<pre><code class="language-python">scan_csv(file: str, 
    infer_schema_length: Optionalint, 
    has_headers: bool, 
    ignore_errors: bool, 
    sep: str, 
    skip_rows: int, 
    stop_after_n_rows: Optionalint, 
    cache: bool, 
    dtype: OptionalDict[str, TypeDataType], 
    low_memory: bool, 
    comment_char: Optionalstr, 
    quote_char: Optionalstr, 
    null_values: OptionalUnion[str, tp.List[str], Dict[str, str]], 
    with_column_names: OptionalCallable[[tp.List[str]], tp.List[str]],) -&gt; LazyFrame:
</code></pre>
<p>See Also: <code>pl.scan_csv</code></p>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def scan_csv(
        file: str,
        infer_schema_length: Optional[int] = 100,
        has_headers: bool = True,
        ignore_errors: bool = False,
        sep: str = &quot;,&quot;,
        skip_rows: int = 0,
        stop_after_n_rows: Optional[int] = None,
        cache: bool = True,
        dtype: Optional[Dict[str, Type[DataType]]] = None,
        low_memory: bool = False,
        comment_char: Optional[str] = None,
        quote_char: Optional[str] = r'&quot;',
        null_values: Optional[Union[str, tp.List[str], Dict[str, str]]] = None,
        with_column_names: Optional[Callable[[tp.List[str]], tp.List[str]]] = None,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        See Also: `pl.scan_csv`
        &quot;&quot;&quot;
        dtype_list: Optional[tp.List[Tuple[str, Type[DataType]]]] = None
        if dtype is not None:
            dtype_list = []
            for k, v in dtype.items():
                dtype_list.append((k, py_type_to_dtype(v)))
        processed_null_values = _process_null_values(null_values)

        self = LazyFrame.__new__(LazyFrame)
        self._ldf = PyLazyFrame.new_from_csv(
            file,
            sep,
            has_headers,
            ignore_errors,
            skip_rows,
            stop_after_n_rows,
            cache,
            dtype_list,
            low_memory,
            comment_char,
            quote_char,
            processed_null_values,
            infer_schema_length,
            with_column_names,
        )
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframescan_parquet"><a class="header" href="#polarsinternalslazy_framelazyframescan_parquet"><code>polars.internals.lazy_frame.LazyFrame.scan_parquet</code></a></h3>
<pre><code class="language-python">scan_parquet(file: str, 
    stop_after_n_rows: Optionalint, 
    cache: bool,) -&gt; LazyFrame:
</code></pre>
<p>See Also: <code>pl.scan_parquet</code></p>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def scan_parquet(
        file: str, stop_after_n_rows: Optional[int] = None, cache: bool = True
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        See Also: `pl.scan_parquet`
        &quot;&quot;&quot;

        self = LazyFrame.__new__(LazyFrame)
        self._ldf = PyLazyFrame.new_from_parquet(file, stop_after_n_rows, cache)
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframescan_ipc"><a class="header" href="#polarsinternalslazy_framelazyframescan_ipc"><code>polars.internals.lazy_frame.LazyFrame.scan_ipc</code></a></h3>
<pre><code class="language-python">scan_ipc(file: str, 
    stop_after_n_rows: Optionalint, 
    cache: bool,) -&gt; LazyFrame:
</code></pre>
<p>See Also: <code>pl.scan_ipc</code></p>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def scan_ipc(
        file: str, stop_after_n_rows: Optional[int] = None, cache: bool = True
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        See Also: `pl.scan_ipc`
        &quot;&quot;&quot;

        self = LazyFrame.__new__(LazyFrame)
        self._ldf = PyLazyFrame.new_from_ipc(file, stop_after_n_rows, cache)
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframepipe"><a class="header" href="#polarsinternalslazy_framelazyframepipe"><code>polars.internals.lazy_frame.LazyFrame.pipe</code></a></h3>
<pre><code class="language-python">pipe(func: Callable[, Any], *args, **kwargs) -&gt; Any:
</code></pre>
<p>Apply a function on Self.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li></li>
<li></li>
<li>[<code>kwargs</code>]: Keyword arguments.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:
        &quot;&quot;&quot;
        Apply a function on Self.

        Parameters
        ----------
        func
            Callable.
        args
            Arguments.
        kwargs
            Keyword arguments.
        &quot;&quot;&quot;
        return func(self, *args, **kwargs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframedescribe_plan"><a class="header" href="#polarsinternalslazy_framelazyframedescribe_plan"><code>polars.internals.lazy_frame.LazyFrame.describe_plan</code></a></h3>
<pre><code class="language-python">describe_plan() -&gt; str:
</code></pre>
<p>A string representation of the unoptimized query plan.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe_plan(self) -&gt; str:
        &quot;&quot;&quot;
        A string representation of the unoptimized query plan.
        &quot;&quot;&quot;
        return self._ldf.describe_plan()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframedescribe_optimized_plan"><a class="header" href="#polarsinternalslazy_framelazyframedescribe_optimized_plan"><code>polars.internals.lazy_frame.LazyFrame.describe_optimized_plan</code></a></h3>
<pre><code class="language-python">describe_optimized_plan(type_coercion: bool, 
    predicate_pushdown: bool, 
    projection_pushdown: bool, 
    simplify_expression: bool,) -&gt; str:
</code></pre>
<p>A string representation of the optimized query plan.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe_optimized_plan(
        self,
        type_coercion: bool = True,
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        simplify_expression: bool = True,
    ) -&gt; str:
        &quot;&quot;&quot;
        A string representation of the optimized query plan.
        &quot;&quot;&quot;

        ldf = self._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache=False,
        )

        return ldf.describe_optimized_plan()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeshow_graph"><a class="header" href="#polarsinternalslazy_framelazyframeshow_graph"><code>polars.internals.lazy_frame.LazyFrame.show_graph</code></a></h3>
<pre><code class="language-python">show_graph(optimized: bool, 
    show: bool, 
    output_path: Optionalstr, 
    raw_output: bool, 
    figsize: Tuple[float, float],) -&gt; Optionalstr:
</code></pre>
<p>Show a plot of the query plan. Note that you should have graphviz installed.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>optimized</code>]: Optimize the query plan.</li>
<li>[<code>show</code>]: Show the figure.</li>
<li>[<code>output_path</code>]: Write the figure to disk.</li>
<li>[<code>raw_output</code>]: Return dot syntax.</li>
<li>[<code>figsize</code>]: Passed to matlotlib if <code>show</code> == True.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def show_graph(
        self,
        optimized: bool = True,
        show: bool = True,
        output_path: Optional[str] = None,
        raw_output: bool = False,
        figsize: Tuple[float, float] = (16.0, 12.0),
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Show a plot of the query plan. Note that you should have graphviz installed.

        Parameters
        ----------
        optimized
            Optimize the query plan.
        show
            Show the figure.
        output_path
            Write the figure to disk.
        raw_output
            Return dot syntax.
        figsize
            Passed to matlotlib if `show` == True.
        &quot;&quot;&quot;
        try:
            import matplotlib.image as mpimg
            import matplotlib.pyplot as plt
        except ImportError:
            raise ImportError(
                &quot;Graphviz dot binary should be on your PATH and matplotlib should be installed to show graph.&quot;
            )
        dot = self._ldf.to_dot(optimized)
        if raw_output:
            return dot
        with tempfile.TemporaryDirectory() as tmpdir_name:
            dot_path = os.path.join(tmpdir_name, &quot;dot&quot;)
            with open(dot_path, &quot;w&quot;) as f:
                f.write(dot)

            subprocess.run([&quot;dot&quot;, &quot;-Nshape=box&quot;, &quot;-Tpng&quot;, &quot;-O&quot;, dot_path])
            out_path = os.path.join(tmpdir_name, &quot;dot.png&quot;)

            if output_path is not None:
                shutil.copy(out_path, output_path)

            if show:
                plt.figure(figsize=figsize)
                img = mpimg.imread(out_path)
                plt.imshow(img)
                plt.show()
        return None
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeinspect"><a class="header" href="#polarsinternalslazy_framelazyframeinspect"><code>polars.internals.lazy_frame.LazyFrame.inspect</code></a></h3>
<pre><code class="language-python">inspect(fmt: str) -&gt; LazyFrame:
</code></pre>
<p>Prints the value that this node in the computation graph evaluates to and passes on the value.</p>
<blockquote>
<blockquote>
<blockquote>
<p>(df.select(pl.col(&quot;foo&quot;).cumsum().alias(&quot;bar&quot;))
.inspect()  # print the node before the filter
.filter(pl.col(&quot;bar&quot;) == pl.col(&quot;foo&quot;)))</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def inspect(self, fmt: str = &quot;{}&quot;) -&gt; &quot;LazyFrame&quot;:  # type: ignore
        &quot;&quot;&quot;
        Prints the value that this node in the computation graph evaluates to and passes on the value.

        &gt;&gt;&gt; (df.select(pl.col(&quot;foo&quot;).cumsum().alias(&quot;bar&quot;))
        &gt;&gt;&gt;    .inspect()  # print the node before the filter
        &gt;&gt;&gt;    .filter(pl.col(&quot;bar&quot;) == pl.col(&quot;foo&quot;)))
        &quot;&quot;&quot;

        def inspect(s: pli.DataFrame) -&gt; pli.DataFrame:
            print(fmt.format(s))  # type: ignore
            return s

        return self.map(inspect, predicate_pushdown=True, projection_pushdown=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeinspectinspect"><a class="header" href="#polarsinternalslazy_framelazyframeinspectinspect"><code>polars.internals.lazy_frame.LazyFrame.inspect.inspect</code></a></h3>
<pre><code class="language-python">inspect(s: pli.DataFrame) -&gt; pli.DataFrame:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def inspect(s: pli.DataFrame) -&gt; pli.DataFrame:
            print(fmt.format(s))  # type: ignore
            return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframesort"><a class="header" href="#polarsinternalslazy_framelazyframesort"><code>polars.internals.lazy_frame.LazyFrame.sort</code></a></h3>
<pre><code class="language-python">sort(by: Union[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    reverse: Union[bool, tp.List[bool]],) -&gt; LazyFrame:
</code></pre>
<p>Sort the DataFrame by:</p>
<pre><code>- A single column name
- An expression
- Multiple expressions
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Column (expressions) to sort by.</li>
<li>[<code>reverse</code>]: Whether or not to sort in reverse order.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(
        self,
        by: Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]],
        reverse: Union[bool, tp.List[bool]] = False,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Sort the DataFrame by:

            - A single column name
            - An expression
            - Multiple expressions

        Parameters
        ----------
        by
            Column (expressions) to sort by.
        reverse
            Whether or not to sort in reverse order.
        &quot;&quot;&quot;
        if type(by) is str:
            return wrap_ldf(self._ldf.sort(by, reverse))
        if type(reverse) is bool:
            reverse = [reverse]

        by = pli.expr_to_lit_or_expr(by, str_to_lit=False)
        by = pli._selection_to_pyexpr_list(by)
        return wrap_ldf(self._ldf.sort_by_exprs(by, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframecollect"><a class="header" href="#polarsinternalslazy_framelazyframecollect"><code>polars.internals.lazy_frame.LazyFrame.collect</code></a></h3>
<pre><code class="language-python">collect(type_coercion: bool, 
    predicate_pushdown: bool, 
    projection_pushdown: bool, 
    simplify_expression: bool, 
    string_cache: bool, 
    no_optimization: bool,) -&gt; pli.DataFrame:
</code></pre>
<p>Collect into a DataFrame.</p>
<p>Note: use <code>fetch</code> if you want to run this query on the first <code>n</code> rows only.
This can be a huge time saver in debugging queries.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>type_coercion</code>]: Do type coercion optimization.</p>
</li>
<li>
<p>[<code>predicate_pushdown</code>]: Do predicate pushdown optimization.</p>
</li>
<li>
<p>[<code>projection_pushdown</code>]: Do projection pushdown optimization.</p>
</li>
<li>
<p>[<code>simplify_expression</code>]: Run simplify expressions optimization.</p>
</li>
<li>
<p>[<code>string_cache</code>]: Use a global string cache in this query.
This is needed if you want to join on categorical columns.</p>
<p>Caution!
If you already have set a global string cache, set this to <code>False</code> as this will reset the
global cache when the query is finished.</p>
</li>
<li>
<p>[<code>no_optimization</code>]: Turn off optimizations.</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def collect(
        self,
        type_coercion: bool = True,
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        simplify_expression: bool = True,
        string_cache: bool = False,
        no_optimization: bool = False,
    ) -&gt; pli.DataFrame:
        &quot;&quot;&quot;
        Collect into a DataFrame.

        Note: use `fetch` if you want to run this query on the first `n` rows only.
        This can be a huge time saver in debugging queries.

        Parameters
        ----------
        type_coercion
            Do type coercion optimization.
        predicate_pushdown
            Do predicate pushdown optimization.
        projection_pushdown
            Do projection pushdown optimization.
        simplify_expression
            Run simplify expressions optimization.
        string_cache
            Use a global string cache in this query.
            This is needed if you want to join on categorical columns.

            Caution!
                If you already have set a global string cache, set this to `False` as this will reset the
                global cache when the query is finished.
        no_optimization
            Turn off optimizations.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        if no_optimization:
            predicate_pushdown = False
            projection_pushdown = False

        ldf = self._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache,
        )
        return pli.wrap_df(ldf.collect())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframefetch"><a class="header" href="#polarsinternalslazy_framelazyframefetch"><code>polars.internals.lazy_frame.LazyFrame.fetch</code></a></h3>
<pre><code class="language-python">fetch(n_rows: int, 
    type_coercion: bool, 
    predicate_pushdown: bool, 
    projection_pushdown: bool, 
    simplify_expression: bool, 
    string_cache: bool, 
    no_optimization: bool,) -&gt; pli.DataFrame:
</code></pre>
<p>Fetch is like a collect operation, but it overwrites the number of rows read by every scan
operation. This is a utility that helps debug a query on a smaller number of rows.</p>
<p>Note that the fetch does not guarantee the final number of rows in the DataFrame.
Filter, join operations and a lower number of rows available in the scanned file influence
the final number of rows.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n_rows</code>]: Collect n_rows from the data sources.</li>
<li>[<code>type_coercion</code>]: Run type coercion optimization.</li>
<li>[<code>predicate_pushdown</code>]: Run predicate pushdown optimization.</li>
<li>[<code>projection_pushdown</code>]: Run projection pushdown optimization.</li>
<li>[<code>simplify_expression</code>]: Run simplify expressions optimization.</li>
<li>[<code>string_cache</code>]: Use a global string cache in this query.
This is needed if you want to join on categorical columns.</li>
<li>[<code>no_optimization</code>]: Turn off optimizations.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fetch(
        self,
        n_rows: int = 500,
        type_coercion: bool = True,
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        simplify_expression: bool = True,
        string_cache: bool = True,
        no_optimization: bool = False,
    ) -&gt; pli.DataFrame:
        &quot;&quot;&quot;
        Fetch is like a collect operation, but it overwrites the number of rows read by every scan
        operation. This is a utility that helps debug a query on a smaller number of rows.

        Note that the fetch does not guarantee the final number of rows in the DataFrame.
        Filter, join operations and a lower number of rows available in the scanned file influence
        the final number of rows.

        Parameters
        ----------
        n_rows
            Collect n_rows from the data sources.
        type_coercion
            Run type coercion optimization.
        predicate_pushdown
            Run predicate pushdown optimization.
        projection_pushdown
            Run projection pushdown optimization.
        simplify_expression
            Run simplify expressions optimization.
        string_cache
            Use a global string cache in this query.
            This is needed if you want to join on categorical columns.
        no_optimization
            Turn off optimizations.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        if no_optimization:
            predicate_pushdown = False
            projection_pushdown = False

        ldf = self._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache,
        )
        return pli.wrap_df(ldf.fetch(n_rows))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframecolumns"><a class="header" href="#polarsinternalslazy_framelazyframecolumns"><code>polars.internals.lazy_frame.LazyFrame.columns</code></a></h3>
<pre><code class="language-python">columns() -&gt; tp.List[str]:
</code></pre>
<p>Get or set column names.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = (pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
}).lazy()
.select([&quot;foo&quot;, &quot;bar&quot;]))</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>df.columns
[&quot;foo&quot;, &quot;bar&quot;]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def columns(self) -&gt; tp.List[str]:
        &quot;&quot;&quot;
        Get or set column names.

        Examples
        --------

        &gt;&gt;&gt; df = (pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    }).lazy()
        &gt;&gt;&gt;     .select([&quot;foo&quot;, &quot;bar&quot;]))

        &gt;&gt;&gt; df.columns
        [&quot;foo&quot;, &quot;bar&quot;]

        &quot;&quot;&quot;
        return self._ldf.columns()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframecache"><a class="header" href="#polarsinternalslazy_framelazyframecache"><code>polars.internals.lazy_frame.LazyFrame.cache</code></a></h3>
<pre><code class="language-python">cache() -&gt; LazyFrame:
</code></pre>
<p>Cache the result once the execution of the physical plan hits this node.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cache(
        self,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Cache the result once the execution of the physical plan hits this node.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.cache())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframefilter"><a class="header" href="#polarsinternalslazy_framelazyframefilter"><code>polars.internals.lazy_frame.LazyFrame.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Union[pli.Expr, str]) -&gt; LazyFrame:
</code></pre>
<p>Filter the rows in the DataFrame based on a predicate expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Expression that evaluates to a boolean Series.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>lf = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
}).lazy()</p>
<h1 id="filter-on-one-condition-1"><a class="header" href="#filter-on-one-condition-1">Filter on one condition</a></h1>
<p>lf.filter(pl.col(&quot;foo&quot;) &lt; 3).collect()
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ b   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="filter-on-multiple-conditions-1"><a class="header" href="#filter-on-multiple-conditions-1">Filter on multiple conditions</a></h1>
<p>lf.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;)).collect()
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: Union[&quot;pli.Expr&quot;, str]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Filter the rows in the DataFrame based on a predicate expression.

        Parameters
        ----------
        predicate
            Expression that evaluates to a boolean Series.

        Examples
        --------

        &gt;&gt;&gt; lf = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; }).lazy()
        &gt;&gt;&gt; # Filter on one condition
        &gt;&gt;&gt; lf.filter(pl.col(&quot;foo&quot;) &lt; 3).collect()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ b   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt;  # Filter on multiple conditions
        &gt;&gt;&gt; lf.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;)).collect()
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        if isinstance(predicate, str):
            predicate = pli.col(predicate)
        return wrap_ldf(self._ldf.filter(predicate._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeselect"><a class="header" href="#polarsinternalslazy_framelazyframeselect"><code>polars.internals.lazy_frame.LazyFrame.select</code></a></h3>
<pre><code class="language-python">select(exprs: Union[str, pli.Expr, Sequencestr, Sequencepli.Expr],) -&gt; LazyFrame:
</code></pre>
<p>Select columns from this DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Column or columns to select.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def select(
        self, exprs: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Select columns from this DataFrame.

        Parameters
        ----------
        exprs
            Column or columns to select.
        &quot;&quot;&quot;
        exprs = pli._selection_to_pyexpr_list(exprs)
        return wrap_ldf(self._ldf.select(exprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframegroupby"><a class="header" href="#polarsinternalslazy_framelazyframegroupby"><code>polars.internals.lazy_frame.LazyFrame.groupby</code></a></h3>
<pre><code class="language-python">groupby(by: Union[str, tp.List[str], pli.Expr, tp.List[pli.Expr]], 
    maintain_order: bool,) -&gt; LazyGroupBy:
</code></pre>
<p>Start a groupby operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Column(s) to group by.</li>
<li>[<code>maintain_order</code>]: Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def groupby(
        self,
        by: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]],
        maintain_order: bool = False,
    ) -&gt; &quot;LazyGroupBy&quot;:
        &quot;&quot;&quot;
        Start a groupby operation.

        Parameters
        ----------
        by
            Column(s) to group by.
        maintain_order
            Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
        &quot;&quot;&quot;
        new_by: tp.List[PyExpr]
        if isinstance(by, list):
            new_by = []
            for e in by:
                if isinstance(e, str):
                    e = pli.col(e)
                new_by.append(e._pyexpr)
        elif isinstance(by, str):
            new_by = [pli.col(by)._pyexpr]
        elif isinstance(by, pli.Expr):
            new_by = [by._pyexpr]
        lgb = self._ldf.groupby(new_by, maintain_order)
        return LazyGroupBy(lgb)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframejoin"><a class="header" href="#polarsinternalslazy_framelazyframejoin"><code>polars.internals.lazy_frame.LazyFrame.join</code></a></h3>
<pre><code class="language-python">join(ldf: LazyFrame, 
    left_on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    right_on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    how: str, 
    suffix: str, 
    allow_parallel: bool, 
    force_parallel: bool, 
    asof_by: OptionalUnion[str, tp.List[str]], 
    asof_by_left: OptionalUnion[str, tp.List[str]], 
    asof_by_right: OptionalUnion[str, tp.List[str]],) -&gt; LazyFrame:
</code></pre>
<p>Add a join operation to the Logical Plan.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ldf</code>]: Lazy DataFrame to join with.</li>
<li>[<code>left_on</code>]: Join column of the left DataFrame.</li>
<li>[<code>right_on</code>]: Join column of the right DataFrame.</li>
<li>[<code>on</code>]: Join column of both DataFrames. If set, <code>left_on</code> and <code>right_on</code> should be None.</li>
<li>[<code>how</code>]: one of:
&quot;inner&quot;
&quot;left&quot;
&quot;outer&quot;
&quot;asof&quot;,
&quot;cross&quot;</li>
<li>[<code>suffix</code>]: Suffix to append to columns with a duplicate name.</li>
<li>[<code>allow_parallel</code>]: Allow the physical plan to optionally evaluate the computation of both DataFrames up to the join in parallel.</li>
<li>[<code>force_parallel</code>]: Force the physical plan to evaluate the computation of both DataFrames up to the join in parallel.</li>
<li>[<code>asof_by</code>]: join on these columns before doing asof join</li>
<li>[<code>asof_by_left</code>]: join on these columns before doing asof join</li>
<li>[<code>asof_by_right</code>]: join on these columns before doing asof join</li>
</ul>
<p><strong>Asof:</strong>
joins
This is similar to a left-join except that we match on nearest key rather than equal keys.
The keys must be sorted to perform an asof join</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def join(
        self,
        ldf: &quot;LazyFrame&quot;,
        left_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        right_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        on: Optional[Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]] = None,
        how: str = &quot;inner&quot;,
        suffix: str = &quot;_right&quot;,
        allow_parallel: bool = True,
        force_parallel: bool = False,
        asof_by: Optional[Union[str, tp.List[str]]] = None,
        asof_by_left: Optional[Union[str, tp.List[str]]] = None,
        asof_by_right: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add a join operation to the Logical Plan.

        Parameters
        ----------
        ldf
            Lazy DataFrame to join with.
        left_on
            Join column of the left DataFrame.
        right_on
            Join column of the right DataFrame.
        on
            Join column of both DataFrames. If set, `left_on` and `right_on` should be None.
        how
            one of:
                &quot;inner&quot;
                &quot;left&quot;
                &quot;outer&quot;
                &quot;asof&quot;,
                &quot;cross&quot;
        suffix
            Suffix to append to columns with a duplicate name.
        allow_parallel
            Allow the physical plan to optionally evaluate the computation of both DataFrames up to the join in parallel.
        force_parallel
            Force the physical plan to evaluate the computation of both DataFrames up to the join in parallel.
        asof_by
            join on these columns before doing asof join
        asof_by_left
            join on these columns before doing asof join
        asof_by_right
            join on these columns before doing asof join

        # Asof joins
        This is similar to a left-join except that we match on nearest key rather than equal keys.
        The keys must be sorted to perform an asof join

        &quot;&quot;&quot;
        if how == &quot;cross&quot;:
            return wrap_ldf(
                self._ldf.join(
                    ldf._ldf,
                    [],
                    [],
                    allow_parallel,
                    force_parallel,
                    how,
                    suffix,
                    [],
                    [],
                )
            )

        left_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(left_on, (str, pli.Expr)):
            left_on_ = [left_on]  # type: ignore[assignment]
        else:
            left_on_ = left_on

        right_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(right_on, (str, pli.Expr)):
            right_on_ = [right_on]  # type: ignore[assignment]
        else:
            right_on_ = right_on

        if isinstance(on, str):
            left_on_ = [on]
            right_on_ = [on]
        elif isinstance(on, list):
            left_on_ = on
            right_on_ = on

        if left_on_ is None or right_on_ is None:
            raise ValueError(&quot;You should pass the column to join on as an argument.&quot;)

        new_left_on = []
        for column in left_on_:
            if isinstance(column, str):
                column = pli.col(column)
            new_left_on.append(column._pyexpr)
        new_right_on = []
        for column in right_on_:
            if isinstance(column, str):
                column = pli.col(column)
            new_right_on.append(column._pyexpr)

        # set asof_by

        left_asof_by_: Union[tp.List[str], None]
        if isinstance(asof_by_left, str):
            left_asof_by_ = [asof_by_left]  # type: ignore[assignment]
        else:
            left_asof_by_ = asof_by_left

        right_asof_by_: Union[tp.List[str], None]
        if isinstance(asof_by_right, (str, pli.Expr)):
            right_asof_by_ = [asof_by_right]  # type: ignore[assignment]
        else:
            right_asof_by_ = asof_by_right

        if isinstance(asof_by, str):
            left_asof_by_ = [asof_by]
            right_asof_by_ = [asof_by]
        elif isinstance(asof_by, list):
            left_asof_by_ = asof_by
            right_asof_by_ = asof_by

        if left_asof_by_ is None:
            left_asof_by_ = []
        if right_asof_by_ is None:
            right_asof_by_ = []

        return wrap_ldf(
            self._ldf.join(
                ldf._ldf,
                new_left_on,
                new_right_on,
                allow_parallel,
                force_parallel,
                how,
                suffix,
                left_asof_by_,
                right_asof_by_,
            )
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframewith_columns"><a class="header" href="#polarsinternalslazy_framelazyframewith_columns"><code>polars.internals.lazy_frame.LazyFrame.with_columns</code></a></h3>
<pre><code class="language-python">with_columns(exprs: Union[tp.List[pli.Expr], pli.Expr],) -&gt; LazyFrame:
</code></pre>
<p>Add or overwrite multiple columns in a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: List of Expressions that evaluate to columns.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_columns(
        self, exprs: Union[tp.List[&quot;pli.Expr&quot;], &quot;pli.Expr&quot;]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite multiple columns in a DataFrame.

        Parameters
        ----------
        exprs
            List of Expressions that evaluate to columns.
        &quot;&quot;&quot;
        if isinstance(exprs, pli.Expr):
            return self.with_column(exprs)

        pyexprs = []

        for e in exprs:
            if isinstance(e, pli.Expr):
                pyexprs.append(e._pyexpr)
            elif isinstance(e, pli.Series):
                pyexprs.append(pli.lit(e)._pyexpr)

        return wrap_ldf(self._ldf.with_columns(pyexprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframewith_column"><a class="header" href="#polarsinternalslazy_framelazyframewith_column"><code>polars.internals.lazy_frame.LazyFrame.with_column</code></a></h3>
<pre><code class="language-python">with_column(expr: pli.Expr) -&gt; LazyFrame:
</code></pre>
<p>Add or overwrite column in a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>expr</code>]: Expression that evaluates to column.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_column(self, expr: &quot;pli.Expr&quot;) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite column in a DataFrame.

        Parameters
        ----------
        expr
            Expression that evaluates to column.
        &quot;&quot;&quot;
        return self.with_columns([expr])
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframedrop"><a class="header" href="#polarsinternalslazy_framelazyframedrop"><code>polars.internals.lazy_frame.LazyFrame.drop</code></a></h3>
<pre><code class="language-python">drop(columns: Union[str, tp.List[str]]) -&gt; LazyFrame:
</code></pre>
<p>Remove one or multiple columns from a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: - Name of the column that should be removed.
<ul>
<li>List of column names.</li>
</ul>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop(self, columns: Union[str, tp.List[str]]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Remove one or multiple columns from a DataFrame.

        Parameters
        ----------
        columns
            - Name of the column that should be removed.
            - List of column names.

        &quot;&quot;&quot;
        if isinstance(columns, str):
            columns = [columns]
        return wrap_ldf(self._ldf.drop_columns(columns))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframewith_column_renamed"><a class="header" href="#polarsinternalslazy_framelazyframewith_column_renamed"><code>polars.internals.lazy_frame.LazyFrame.with_column_renamed</code></a></h3>
<pre><code class="language-python">with_column_renamed(existing_name: str, 
    new_name: str,) -&gt; LazyFrame:
</code></pre>
<p>Rename a column in the DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_column_renamed(self, existing_name: str, new_name: str) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Rename a column in the DataFrame
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.with_column_renamed(existing_name, new_name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframerename"><a class="header" href="#polarsinternalslazy_framelazyframerename"><code>polars.internals.lazy_frame.LazyFrame.rename</code></a></h3>
<pre><code class="language-python">rename(mapping: Dict[str, str]) -&gt; LazyFrame:
</code></pre>
<p>Rename column names. This does not preserve column order.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mapping</code>]: Key value pairs that map from old name to new name.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rename(self, mapping: Dict[str, str]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Rename column names. This does not preserve column order.

        Parameters
        ----------
        mapping
            Key value pairs that map from old name to new name.
        &quot;&quot;&quot;
        existing = list(mapping.keys())
        new = list(mapping.values())
        return wrap_ldf(self._ldf.rename(existing, new))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframereverse"><a class="header" href="#polarsinternalslazy_framelazyframereverse"><code>polars.internals.lazy_frame.LazyFrame.reverse</code></a></h3>
<pre><code class="language-python">reverse() -&gt; LazyFrame:
</code></pre>
<p>Reverse the DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reverse(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Reverse the DataFrame.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.reverse())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeshift"><a class="header" href="#polarsinternalslazy_framelazyframeshift"><code>polars.internals.lazy_frame.LazyFrame.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; LazyFrame:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeshift_and_fill"><a class="header" href="#polarsinternalslazy_framelazyframeshift_and_fill"><code>polars.internals.lazy_frame.LazyFrame.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, 
    fill_value: Union[pli.Expr, int, str, float],) -&gt; LazyFrame:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: fill None values with the result of this expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(
        self, periods: int, fill_value: Union[&quot;pli.Expr&quot;, int, str, float]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            fill None values with the result of this expression.
        &quot;&quot;&quot;
        if not isinstance(fill_value, pli.Expr):
            fill_value = pli.lit(fill_value)
        return wrap_ldf(self._ldf.shift_and_fill(periods, fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeslice"><a class="header" href="#polarsinternalslazy_framelazyframeslice"><code>polars.internals.lazy_frame.LazyFrame.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; LazyFrame:
</code></pre>
<p>Slice the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Start index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Slice the DataFrame.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframelimit"><a class="header" href="#polarsinternalslazy_framelazyframelimit"><code>polars.internals.lazy_frame.LazyFrame.limit</code></a></h3>
<pre><code class="language-python">limit(n: int) -&gt; LazyFrame:
</code></pre>
<p>Limit the DataFrame to the first <code>n</code> rows. Note if you don't want the rows to be scanned,
use the <code>fetch</code> operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of rows.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def limit(self, n: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Limit the DataFrame to the first `n` rows. Note if you don't want the rows to be scanned,
        use the `fetch` operation.

        Parameters
        ----------
        n
            Number of rows.
        &quot;&quot;&quot;
        return self.slice(0, n)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframehead"><a class="header" href="#polarsinternalslazy_framelazyframehead"><code>polars.internals.lazy_frame.LazyFrame.head</code></a></h3>
<pre><code class="language-python">head(n: int) -&gt; LazyFrame:
</code></pre>
<p>Gets the first <code>n</code> rows of the DataFrame. You probably don't want to use this!</p>
<p>Consider using the <code>fetch</code> operation. The <code>fetch</code> operation will truly load the first <code>n</code>
rows lazily.</p>
<p>This operation instead loads all the rows and only applies the <code>head</code> at the end.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of rows.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, n: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Gets the first `n` rows of the DataFrame. You probably don't want to use this!

        Consider using the `fetch` operation. The `fetch` operation will truly load the first `n`
        rows lazily.

        This operation instead loads all the rows and only applies the `head` at the end.

        Parameters
        ----------
        n
            Number of rows.
        &quot;&quot;&quot;
        return self.limit(n)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframetail"><a class="header" href="#polarsinternalslazy_framelazyframetail"><code>polars.internals.lazy_frame.LazyFrame.tail</code></a></h3>
<pre><code class="language-python">tail(n: int) -&gt; LazyFrame:
</code></pre>
<p>Get the last <code>n</code> rows of the DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of rows.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, n: int) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Get the last `n` rows of the DataFrame.

        Parameters
        ----------
        n
            Number of rows.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.tail(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframelast"><a class="header" href="#polarsinternalslazy_framelazyframelast"><code>polars.internals.lazy_frame.LazyFrame.last</code></a></h3>
<pre><code class="language-python">last() -&gt; LazyFrame:
</code></pre>
<p>Get the last row of the DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def last(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Get the last row of the DataFrame.
        &quot;&quot;&quot;
        return self.tail(1)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframefirst"><a class="header" href="#polarsinternalslazy_framelazyframefirst"><code>polars.internals.lazy_frame.LazyFrame.first</code></a></h3>
<pre><code class="language-python">first() -&gt; LazyFrame:
</code></pre>
<p>Get the first row of the DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Get the first row of the DataFrame.
        &quot;&quot;&quot;
        return self.slice(0, 1)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframewith_row_count"><a class="header" href="#polarsinternalslazy_framelazyframewith_row_count"><code>polars.internals.lazy_frame.LazyFrame.with_row_count</code></a></h3>
<pre><code class="language-python">with_row_count(name: str) -&gt; LazyFrame:
</code></pre>
<p>Add a column at index 0 that counts the rows.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Name of the column to add.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_row_count(self, name: str = &quot;row_nr&quot;) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Add a column at index 0 that counts the rows.

        Parameters
        ----------
        name
            Name of the column to add.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.with_row_count(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframefill_null"><a class="header" href="#polarsinternalslazy_framelazyframefill_null"><code>polars.internals.lazy_frame.LazyFrame.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(fill_value: Union[int, str, pli.Expr],) -&gt; LazyFrame:
</code></pre>
<p>Fill missing values</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>fill_value</code>]: Value to fill the missing values with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, fill_value: Union[int, str, &quot;pli.Expr&quot;]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Fill missing values

        Parameters
        ----------
        fill_value
            Value to fill the missing values with
        &quot;&quot;&quot;
        if not isinstance(fill_value, pli.Expr):
            fill_value = pli.lit(fill_value)
        return wrap_ldf(self._ldf.fill_null(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframefill_nan"><a class="header" href="#polarsinternalslazy_framelazyframefill_nan"><code>polars.internals.lazy_frame.LazyFrame.fill_nan</code></a></h3>
<pre><code class="language-python">fill_nan(fill_value: Union[int, str, float, pli.Expr],) -&gt; LazyFrame:
</code></pre>
<p>Fill floating point NaN values.</p>
<p>..warning::</p>
<pre><code>NOTE that floating point NaN (No a Number) are not missing values!
to replace missing values, use `fill_null`.
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>fill_value</code>]: Value to fill the NaN values with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_nan(self, fill_value: Union[int, str, float, &quot;pli.Expr&quot;]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Fill floating point NaN values.

        ..warning::

            NOTE that floating point NaN (No a Number) are not missing values!
            to replace missing values, use `fill_null`.


        Parameters
        ----------
        fill_value
            Value to fill the NaN values with
        &quot;&quot;&quot;
        if not isinstance(fill_value, pli.Expr):
            fill_value = pli.lit(fill_value)
        return wrap_ldf(self._ldf.fill_nan(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframestd"><a class="header" href="#polarsinternalslazy_framelazyframestd"><code>polars.internals.lazy_frame.LazyFrame.std</code></a></h3>
<pre><code class="language-python">std() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their standard deviation value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their standard deviation value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.std())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframevar"><a class="header" href="#polarsinternalslazy_framelazyframevar"><code>polars.internals.lazy_frame.LazyFrame.var</code></a></h3>
<pre><code class="language-python">var() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their variance value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their variance value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.var())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframemax"><a class="header" href="#polarsinternalslazy_framelazyframemax"><code>polars.internals.lazy_frame.LazyFrame.max</code></a></h3>
<pre><code class="language-python">max() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their maximum value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframemin"><a class="header" href="#polarsinternalslazy_framelazyframemin"><code>polars.internals.lazy_frame.LazyFrame.min</code></a></h3>
<pre><code class="language-python">min() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their minimum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their minimum value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframesum"><a class="header" href="#polarsinternalslazy_framelazyframesum"><code>polars.internals.lazy_frame.LazyFrame.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their sum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their sum value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.sum())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframemean"><a class="header" href="#polarsinternalslazy_framelazyframemean"><code>polars.internals.lazy_frame.LazyFrame.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their mean value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their mean value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.mean())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframemedian"><a class="header" href="#polarsinternalslazy_framelazyframemedian"><code>polars.internals.lazy_frame.LazyFrame.median</code></a></h3>
<pre><code class="language-python">median() -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their median value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their median value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.median())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframequantile"><a class="header" href="#polarsinternalslazy_framelazyframequantile"><code>polars.internals.lazy_frame.LazyFrame.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; LazyFrame:
</code></pre>
<p>Aggregate the columns in the DataFrame to their quantile value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns in the DataFrame to their quantile value.
        &quot;&quot;&quot;
        return wrap_ldf(self._ldf.quantile(quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeexplode"><a class="header" href="#polarsinternalslazy_framelazyframeexplode"><code>polars.internals.lazy_frame.LazyFrame.explode</code></a></h3>
<pre><code class="language-python">explode(columns: Union[str, tp.List[str], pli.Expr, tp.List[pli.Expr]],) -&gt; LazyFrame:
</code></pre>
<p>Explode lists to long format.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
})
df
shape: (6, 2)
╭─────────┬────────────╮
│ letters ┆ nrs        │
│ ---     ┆ ---        │
│ str     ┆ list [i64] │
╞═════════╪════════════╡
│ &quot;c&quot;     ┆ [1, 2]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;c&quot;     ┆ [1, 3]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;a&quot;     ┆ [4, 3]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;c&quot;     ┆ [5, 5, 5]  │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;a&quot;     ┆ [6]        │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;b&quot;     ┆ [2, 1, 2]  │
╰─────────┴────────────╯
df.explode(&quot;nrs&quot;)
shape: (13, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ ...     ┆ ... │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 2   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(
        self, columns: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Explode lists to long format.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬────────────╮
        │ letters ┆ nrs        │
        │ ---     ┆ ---        │
        │ str     ┆ list [i64] │
        ╞═════════╪════════════╡
        │ &quot;c&quot;     ┆ [1, 2]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [1, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [4, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [5, 5, 5]  │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [6]        │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ [2, 1, 2]  │
        ╰─────────┴────────────╯
        &gt;&gt;&gt; df.explode(&quot;nrs&quot;)
        shape: (13, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ ...     ┆ ... │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        columns = pli._selection_to_pyexpr_list(columns)
        return wrap_ldf(self._ldf.explode(columns))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframedrop_duplicates"><a class="header" href="#polarsinternalslazy_framelazyframedrop_duplicates"><code>polars.internals.lazy_frame.LazyFrame.drop_duplicates</code></a></h3>
<pre><code class="language-python">drop_duplicates(maintain_order: bool, 
    subset: OptionalUnion[tp.List[str], str],) -&gt; LazyFrame:
</code></pre>
<p>Drop duplicate rows from this DataFrame.
Note that this fails if there is a column of type <code>List</code> in the DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_duplicates(
        self,
        maintain_order: bool = False,
        subset: Optional[Union[tp.List[str], str]] = None,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Drop duplicate rows from this DataFrame.
        Note that this fails if there is a column of type `List` in the DataFrame.
        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_ldf(self._ldf.drop_duplicates(maintain_order, subset))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframedrop_nulls"><a class="header" href="#polarsinternalslazy_framelazyframedrop_nulls"><code>polars.internals.lazy_frame.LazyFrame.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls(subset: OptionalUnion[tp.List[str], str],) -&gt; LazyFrame:
</code></pre>
<p>Drop rows with null values from this DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, None, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.lazy().drop_nulls().collect()
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>This method only drops nulls row-wise if any single value of the row is null.</p>
<p>Below are some example snippets that show how you could drop null values based on other
conditions</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;a&quot;: [None, None, None, None],
&quot;b&quot;: [1, 2, None, 1],
&quot;c&quot;: [1, None, None, 1],
}
)
df
shape: (4, 3)
┌──────┬──────┬──────┐
│ a    ┆ b    ┆ c    │
│ ---  ┆ ---  ┆ ---  │
│ f64  ┆ i64  ┆ i64  │
╞══════╪══════╪══════╡
│ null ┆ 1    ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 2    ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 1    ┆ 1    │
└──────┴──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="drop-a-row-only-if-all-values-are-null-1"><a class="header" href="#drop-a-row-only-if-all-values-are-null-1">drop a row only if all values are null</a></h1>
<p>df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
shape: (3, 3)
┌──────┬─────┬──────┐
│ a    ┆ b   ┆ c    │
│ ---  ┆ --- ┆ ---  │
│ f64  ┆ i64 ┆ i64  │
╞══════╪═════╪══════╡
│ null ┆ 1   ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 2   ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 1   ┆ 1    │
└──────┴─────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(
        self, subset: Optional[Union[tp.List[str], str]] = None
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Drop rows with null values from this DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, None, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.lazy().drop_nulls().collect()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        This method only drops nulls row-wise if any single value of the row is null.

        Below are some example snippets that show how you could drop null values based on other
        conditions

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {
        &gt;&gt;&gt;        &quot;a&quot;: [None, None, None, None],
        &gt;&gt;&gt;        &quot;b&quot;: [1, 2, None, 1],
        &gt;&gt;&gt;        &quot;c&quot;: [1, None, None, 1],
        &gt;&gt;&gt;    }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df
        shape: (4, 3)
        ┌──────┬──────┬──────┐
        │ a    ┆ b    ┆ c    │
        │ ---  ┆ ---  ┆ ---  │
        │ f64  ┆ i64  ┆ i64  │
        ╞══════╪══════╪══════╡
        │ null ┆ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1    ┆ 1    │
        └──────┴──────┴──────┘

        &gt;&gt;&gt; # drop a row only if all values are null
        &gt;&gt;&gt; df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
        shape: (3, 3)
        ┌──────┬─────┬──────┐
        │ a    ┆ b   ┆ c    │
        │ ---  ┆ --- ┆ ---  │
        │ f64  ┆ i64 ┆ i64  │
        ╞══════╪═════╪══════╡
        │ null ┆ 1   ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2   ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1   ┆ 1    │
        └──────┴─────┴──────┘

        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_ldf(self._ldf.drop_nulls(subset))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframemelt"><a class="header" href="#polarsinternalslazy_framelazyframemelt"><code>polars.internals.lazy_frame.LazyFrame.melt</code></a></h3>
<pre><code class="language-python">melt(id_vars: Union[str, tp.List[str]], 
    value_vars: Union[str, tp.List[str]],) -&gt; LazyFrame:
</code></pre>
<p>Unpivot DataFrame to long format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>id_vars</code>]: Columns to use as identifier variables.</li>
<li>[<code>value_vars</code>]: Values to use as identifier variables.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def melt(
        self, id_vars: Union[str, tp.List[str]], value_vars: Union[str, tp.List[str]]
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Unpivot DataFrame to long format.

        Parameters
        ----------
        id_vars
            Columns to use as identifier variables.
        value_vars
            Values to use as identifier variables.
        &quot;&quot;&quot;
        if isinstance(value_vars, str):
            value_vars = [value_vars]
        if isinstance(id_vars, str):
            id_vars = [id_vars]
        return wrap_ldf(self._ldf.melt(id_vars, value_vars))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframemap"><a class="header" href="#polarsinternalslazy_framelazyframemap"><code>polars.internals.lazy_frame.LazyFrame.map</code></a></h3>
<pre><code class="language-python">map(f: Callable[[pli.DataFrame], pli.DataFrame], 
    predicate_pushdown: bool, 
    projection_pushdown: bool, 
    no_optimizations: bool,) -&gt; LazyFrame:
</code></pre>
<p>Apply a custom function. It is important that the function returns a Polars DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>predicate_pushdown</code>]: Allow predicate pushdown optimization to pass this node.</li>
<li>[<code>projection_pushdown</code>]: Allow projection pushdown optimization to pass this node.</li>
<li>[<code>no_optimizations</code>]: Turn off all optimizations past this point.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def map(
        self,
        f: Callable[[pli.DataFrame], pli.DataFrame],
        predicate_pushdown: bool = True,
        projection_pushdown: bool = True,
        no_optimizations: bool = False,
    ) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Apply a custom function. It is important that the function returns a Polars DataFrame.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        predicate_pushdown
            Allow predicate pushdown optimization to pass this node.
        projection_pushdown
            Allow projection pushdown optimization to pass this node.
        no_optimizations
            Turn off all optimizations past this point.
        &quot;&quot;&quot;
        if not no_optimizations:
            predicate_pushdown = False
            projection_pushdown = False
        return wrap_ldf(self._ldf.map(f, predicate_pushdown, projection_pushdown))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazyframeinterpolate"><a class="header" href="#polarsinternalslazy_framelazyframeinterpolate"><code>polars.internals.lazy_frame.LazyFrame.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; LazyFrame:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return self.select(pli.col(&quot;*&quot;).interpolate())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalslazy_framelazygroupby"><a class="header" href="#polarsinternalslazy_framelazygroupby"><code>polars.internals.lazy_frame.LazyGroupBy</code></a></h1>
<p>Created by <code>df.lazy().groupby(&quot;foo)&quot;</code></p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/lazy_frame/LazyGroupBy.html#polarsinternalslazy_framelazygroupbyagg"><code>agg()</code></a>: Describe the aggregation that need to be done on a group.</li>
<li><a href="polars/internals/lazy_frame/LazyGroupBy.html#polarsinternalslazy_framelazygroupbyhead"><code>head()</code></a>: Return first n rows of each group.</li>
<li><a href="polars/internals/lazy_frame/LazyGroupBy.html#polarsinternalslazy_framelazygroupbytail"><code>tail()</code></a>: Return last n rows of each group.</li>
<li><a href="polars/internals/lazy_frame/LazyGroupBy.html#polarsinternalslazy_framelazygroupbyapply"><code>apply()</code></a>: Apply a function over the groups as a new <code>DataFrame</code>. It is not recommended that you use</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class LazyGroupBy:
    &quot;&quot;&quot;
    Created by `df.lazy().groupby(&quot;foo)&quot;`
    &quot;&quot;&quot;

    def __init__(self, lgb: &quot;PyLazyGroupBy&quot;):
        self.lgb = lgb

    def agg(self, aggs: Union[tp.List[&quot;pli.Expr&quot;], &quot;pli.Expr&quot;]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Describe the aggregation that need to be done on a group.

        Parameters
        ----------
        aggs
            Single/ Multiple aggregation expression(s).

        Examples
        --------

        &gt;&gt;&gt; (pl.scan_csv(&quot;data.csv&quot;)
            .groupby(&quot;groups&quot;)
            .agg([
                    pl.col(&quot;name&quot;).n_unique().alias(&quot;unique_names&quot;),
                    pl.max(&quot;values&quot;)
                ])
        )
        &quot;&quot;&quot;
        aggs = pli._selection_to_pyexpr_list(aggs)
        return wrap_ldf(self.lgb.agg(aggs))

    def head(self, n: int = 5) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Return first n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .head(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return wrap_ldf(self.lgb.head(n))

    def tail(self, n: int = 5) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Return last n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .tail(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return wrap_ldf(self.lgb.tail(n))

    def apply(self, f: Callable[[pli.DataFrame], pli.DataFrame]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Apply a function over the groups as a new `DataFrame`. It is not recommended that you use
        this as materializing the `DataFrame` is quite expensive.

        Parameters
        ----------
        f
            Function to apply over the `DataFrame`.
        &quot;&quot;&quot;
        return wrap_ldf(self.lgb.apply(f))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-10"><a class="header" href="#constructor-10">Constructor</a></h2>
<pre><code class="language-python">LazyGroupBy(lgb: PyLazyGroupBy)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, lgb: &quot;PyLazyGroupBy&quot;):
        self.lgb = lgb
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-10"><a class="header" href="#methods-10">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazygroupbyagg"><a class="header" href="#polarsinternalslazy_framelazygroupbyagg"><code>polars.internals.lazy_frame.LazyGroupBy.agg</code></a></h3>
<pre><code class="language-python">agg(aggs: Union[tp.List[pli.Expr], pli.Expr],) -&gt; LazyFrame:
</code></pre>
<p>Describe the aggregation that need to be done on a group.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>aggs</code>]: Single/ Multiple aggregation expression(s).</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>(pl.scan_csv(&quot;data.csv&quot;)
.groupby(&quot;groups&quot;)
.agg([
pl.col(&quot;name&quot;).n_unique().alias(&quot;unique_names&quot;),
pl.max(&quot;values&quot;)
])
)</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg(self, aggs: Union[tp.List[&quot;pli.Expr&quot;], &quot;pli.Expr&quot;]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Describe the aggregation that need to be done on a group.

        Parameters
        ----------
        aggs
            Single/ Multiple aggregation expression(s).

        Examples
        --------

        &gt;&gt;&gt; (pl.scan_csv(&quot;data.csv&quot;)
            .groupby(&quot;groups&quot;)
            .agg([
                    pl.col(&quot;name&quot;).n_unique().alias(&quot;unique_names&quot;),
                    pl.max(&quot;values&quot;)
                ])
        )
        &quot;&quot;&quot;
        aggs = pli._selection_to_pyexpr_list(aggs)
        return wrap_ldf(self.lgb.agg(aggs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazygroupbyhead"><a class="header" href="#polarsinternalslazy_framelazygroupbyhead"><code>polars.internals.lazy_frame.LazyGroupBy.head</code></a></h3>
<pre><code class="language-python">head(n: int) -&gt; LazyFrame:
</code></pre>
<p>Return first n rows of each group.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of values of the group to select</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
})
df
shape: (6, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 4   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
╰─────────┴─────╯
(df.groupby(&quot;letters&quot;)
.head(2)
.sort(&quot;letters&quot;)
)
shape: (5, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, n: int = 5) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Return first n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .head(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return wrap_ldf(self.lgb.head(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazygroupbytail"><a class="header" href="#polarsinternalslazy_framelazygroupbytail"><code>polars.internals.lazy_frame.LazyGroupBy.tail</code></a></h3>
<pre><code class="language-python">tail(n: int) -&gt; LazyFrame:
</code></pre>
<p>Return last n rows of each group.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of values of the group to select</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
})
df
shape: (6, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 4   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
╰─────────┴─────╯
(df.groupby(&quot;letters&quot;)
.tail(2)
.sort(&quot;letters&quot;)
)
shape: (5, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;a&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 4   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, n: int = 5) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Return last n rows of each group.

        Parameters
        ----------
        n
            Number of values of the group to select

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [1, 2, 3, 4, 5, 6]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ╰─────────┴─────╯
        &gt;&gt;&gt; (df.groupby(&quot;letters&quot;)
        &gt;&gt;&gt;  .tail(2)
        &gt;&gt;&gt;  .sort(&quot;letters&quot;)
        &gt;&gt;&gt; )
        shape: (5, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;a&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 4   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return wrap_ldf(self.lgb.tail(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_framelazygroupbyapply"><a class="header" href="#polarsinternalslazy_framelazygroupbyapply"><code>polars.internals.lazy_frame.LazyGroupBy.apply</code></a></h3>
<pre><code class="language-python">apply(f: Callable[[pli.DataFrame], pli.DataFrame],) -&gt; LazyFrame:
</code></pre>
<p>Apply a function over the groups as a new <code>DataFrame</code>. It is not recommended that you use
this as materializing the <code>DataFrame</code> is quite expensive.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Function to apply over the <code>DataFrame</code>.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(self, f: Callable[[pli.DataFrame], pli.DataFrame]) -&gt; &quot;LazyFrame&quot;:
        &quot;&quot;&quot;
        Apply a function over the groups as a new `DataFrame`. It is not recommended that you use
        this as materializing the `DataFrame` is quite expensive.

        Parameters
        ----------
        f
            Function to apply over the `DataFrame`.
        &quot;&quot;&quot;
        return wrap_ldf(self.lgb.apply(f))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalslazy_functions"><a class="header" href="#module-polarsinternalslazy_functions">Module <code>polars.internals.lazy_functions</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionscol"><code>col()</code></a>: A column in a DataFrame.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionscount"><code>count()</code></a>: Count the number of values in this column.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsto_list"><code>to_list()</code></a>: Aggregate to list.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsstd"><code>std()</code></a>: Get the standard deviation.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsvar"><code>var()</code></a>: Get the variance.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsmax"><code>max()</code></a>: Get the maximum value. Can be used horizontally or vertically.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsmin"><code>min()</code></a>: Get the minimum value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionssum"><code>sum()</code></a>: Get the sum value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsmean"><code>mean()</code></a>: Get the mean value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsavg"><code>avg()</code></a>: Alias for mean.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsmedian"><code>median()</code></a>: Get the median value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsn_unique"><code>n_unique()</code></a>: Count unique values.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsfirst"><code>first()</code></a>: Get the first value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionslast"><code>last()</code></a>: Get the last value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionshead"><code>head()</code></a>: Get the first n rows of an Expression.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionstail"><code>tail()</code></a>: Get the last n rows of an Expression.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionslit"><code>lit()</code></a>: A literal value.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsspearman_rank_corr"><code>spearman_rank_corr()</code></a>: Compute the spearman rank correlation between two columns.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionspearson_corr"><code>pearson_corr()</code></a>: Compute the pearson's correlation between two columns.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionscov"><code>cov()</code></a>: Compute the covariance between two columns/ expressions.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsmap"><code>map()</code></a>: Map a custom function over multiple columns/expressions and produce a single Series result.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsapply"><code>apply()</code></a>: Apply a custom function in a GroupBy context.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsmap_binary"><code>map_binary()</code></a>: .. deprecated:: 0.10.4</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsfold"><code>fold()</code></a>: Accumulate over multiple columns horizontally/ row wise with a left fold.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsany"><code>any()</code></a>: Evaluate columnwise or elementwise with a bitwise OR operation.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsexclude"><code>exclude()</code></a>: Exclude certain columns from a wildcard expression.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsall"><code>all()</code></a>: This function is two things</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsgroups"><code>groups()</code></a>: Syntactic sugar for <code>column(&quot;foo&quot;).agg_groups()</code>.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsquantile"><code>quantile()</code></a>: Syntactic sugar for <code>column(&quot;foo&quot;).quantile(..)</code>.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsarange"><code>arange()</code></a>: Create a range expression. This can be used in a <code>select</code>, <code>with_column</code> etc.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsargsort_by"><code>argsort_by()</code></a>: Find the indexes that would sort the columns.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsconcat_str"><code>concat_str()</code></a>: Concat Utf8 Series in linear time. Non utf8 columns are cast to utf8.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsformat"><code>format()</code></a>: String format utility for expressions</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsconcat_list"><code>concat_list()</code></a>: Concat the arrays in a Series dtype List in linear time.</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionscollect_all"><code>collect_all()</code></a>: Collect multiple LazyFrames at the same time. This runs all the computation graphs in parallel on</li>
<li><a href="polars/internals/lazy_functions.html#polarsinternalslazy_functionsselect"><code>select()</code></a>: Run polars expressions without a context.</li>
</ul>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionscol"><a class="header" href="#polarsinternalslazy_functionscol"><code>polars.internals.lazy_functions.col</code></a></h3>
<pre><code class="language-python">col(
    name: Union[str, tp.List[str], tp.List[TypeDataType], pli.Series, TypeDataType],
) -&gt; pli.Expr:
</code></pre>
<p>A column in a DataFrame.
Can be used to select:</p>
<ul>
<li>a single column by name</li>
<li>all columns by using a wildcard <code>&quot;*&quot;</code></li>
<li>column by regular expression if the regex starts with <code>^</code> and ends with <code>$</code></li>
</ul>
<p>Parameters</p>
<ul>
<li>[<code>col</code>]: A string that holds the name of the column</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;ham&quot;: [1, 2, 3],
&quot;hamburger&quot;: [11, 22, 33],
&quot;foo&quot;: [3, 2, 1]})
df.select(col(&quot;foo&quot;))
shape: (3, 1)
╭─────╮
│ foo │
│ --- │
│ i64 │
╞═════╡
│ 3   │
├╌╌╌╌╌┤
│ 2   │
├╌╌╌╌╌┤
│ 1   │
╰─────╯
df.select(col(&quot;<em>&quot;))
shape: (3, 3)
╭─────┬───────────┬─────╮
│ ham ┆ hamburger ┆ foo │
│ --- ┆ ---       ┆ --- │
│ i64 ┆ i64       ┆ i64 │
╞═════╪═══════════╪═════╡
│ 1   ┆ 11        ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 22        ┆ 2   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 33        ┆ 1   │
╰─────┴───────────┴─────╯
df.select(col(&quot;^ham.</em>$&quot;))
shape: (3, 2)
╭─────┬───────────╮
│ ham ┆ hamburger │
│ --- ┆ ---       │
│ i64 ┆ i64       │
╞═════╪═══════════╡
│ 1   ┆ 11        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ 22        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ 33        │
╰─────┴───────────╯
df.select(col(&quot;*&quot;).exclude(&quot;ham&quot;))
shape: (3, 2)
╭───────────┬─────╮
│ hamburger ┆ foo │
│ ---       ┆ --- │
│ i64       ┆ i64 │
╞═══════════╪═════╡
│ 11        ┆ 3   │
├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 22        ┆ 2   │
├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 33        ┆ 1   │
╰───────────┴─────╯
df.select(col([&quot;hamburger&quot;, &quot;foo&quot;])
shape: (3, 2)
╭───────────┬─────╮
│ hamburger ┆ foo │
│ ---       ┆ --- │
│ i64       ┆ i64 │
╞═══════════╪═════╡
│ 11        ┆ 3   │
├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 22        ┆ 2   │
├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 33        ┆ 1   │
╰───────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def col(
    name: Union[
        str, tp.List[str], tp.List[Type[DataType]], &quot;pli.Series&quot;, Type[DataType]
    ]
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    A column in a DataFrame.
    Can be used to select:

     * a single column by name
     * all columns by using a wildcard `&quot;*&quot;`
     * column by regular expression if the regex starts with `^` and ends with `$`

    Parameters
    col
        A string that holds the name of the column

    Examples
    --------

    &gt;&gt;&gt; df = pl.DataFrame({
    &gt;&gt;&gt; &quot;ham&quot;: [1, 2, 3],
    &gt;&gt;&gt; &quot;hamburger&quot;: [11, 22, 33],
    &gt;&gt;&gt; &quot;foo&quot;: [3, 2, 1]})
    &gt;&gt;&gt; df.select(col(&quot;foo&quot;))
    shape: (3, 1)
    ╭─────╮
    │ foo │
    │ --- │
    │ i64 │
    ╞═════╡
    │ 3   │
    ├╌╌╌╌╌┤
    │ 2   │
    ├╌╌╌╌╌┤
    │ 1   │
    ╰─────╯
    &gt;&gt;&gt; df.select(col(&quot;*&quot;))
    shape: (3, 3)
    ╭─────┬───────────┬─────╮
    │ ham ┆ hamburger ┆ foo │
    │ --- ┆ ---       ┆ --- │
    │ i64 ┆ i64       ┆ i64 │
    ╞═════╪═══════════╪═════╡
    │ 1   ┆ 11        ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 22        ┆ 2   │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
    │ 3   ┆ 33        ┆ 1   │
    ╰─────┴───────────┴─────╯
    &gt;&gt;&gt; df.select(col(&quot;^ham.*$&quot;))
    shape: (3, 2)
    ╭─────┬───────────╮
    │ ham ┆ hamburger │
    │ --- ┆ ---       │
    │ i64 ┆ i64       │
    ╞═════╪═══════════╡
    │ 1   ┆ 11        │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
    │ 2   ┆ 22        │
    ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
    │ 3   ┆ 33        │
    ╰─────┴───────────╯
    &gt;&gt;&gt; df.select(col(&quot;*&quot;).exclude(&quot;ham&quot;))
    shape: (3, 2)
    ╭───────────┬─────╮
    │ hamburger ┆ foo │
    │ ---       ┆ --- │
    │ i64       ┆ i64 │
    ╞═══════════╪═════╡
    │ 11        ┆ 3   │
    ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
    │ 22        ┆ 2   │
    ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
    │ 33        ┆ 1   │
    ╰───────────┴─────╯
    &gt;&gt;&gt; df.select(col([&quot;hamburger&quot;, &quot;foo&quot;])
    shape: (3, 2)
    ╭───────────┬─────╮
    │ hamburger ┆ foo │
    │ ---       ┆ --- │
    │ i64       ┆ i64 │
    ╞═══════════╪═════╡
    │ 11        ┆ 3   │
    ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
    │ 22        ┆ 2   │
    ├╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
    │ 33        ┆ 1   │
    ╰───────────┴─────╯

    &quot;&quot;&quot;
    if isinstance(name, pli.Series):
        name = name.to_list()  # type: ignore

    if isclass(name) and issubclass(name, DataType):  # type: ignore
        name = [name]  # type: ignore

    if isinstance(name, list):
        if len(name) == 0 or isinstance(name[0], str):
            return pli.wrap_expr(pycols(name))
        elif isclass(name[0]) and issubclass(name[0], DataType):
            return pli.wrap_expr(_dtype_cols(name))
        else:
            raise ValueError(&quot;did expect argument of List[str] or List[DataType]&quot;)
    return pli.wrap_expr(pycol(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionscount"><a class="header" href="#polarsinternalslazy_functionscount"><code>polars.internals.lazy_functions.count</code></a></h3>
<pre><code class="language-python">count(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, int]:
</code></pre>
<p>Count the number of values in this column.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def count(column: Union[str, &quot;pli.Series&quot;] = &quot;&quot;) -&gt; Union[&quot;pli.Expr&quot;, int]:
    &quot;&quot;&quot;
    Count the number of values in this column.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.len()
    return col(column).count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsto_list"><a class="header" href="#polarsinternalslazy_functionsto_list"><code>polars.internals.lazy_functions.to_list</code></a></h3>
<pre><code class="language-python">to_list(name: str) -&gt; pli.Expr:
</code></pre>
<p>Aggregate to list.</p>
<p>Re-exported as <code>pl.list()</code></p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def to_list(name: str) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Aggregate to list.

    Re-exported as `pl.list()`
    &quot;&quot;&quot;
    return col(name).list()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsstd"><a class="header" href="#polarsinternalslazy_functionsstd"><code>polars.internals.lazy_functions.std</code></a></h3>
<pre><code class="language-python">std(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, Optionalfloat]:
</code></pre>
<p>Get the standard deviation.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def std(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, Optional[float]]:
    &quot;&quot;&quot;
    Get the standard deviation.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.std()
    return col(column).std()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsvar"><a class="header" href="#polarsinternalslazy_functionsvar"><code>polars.internals.lazy_functions.var</code></a></h3>
<pre><code class="language-python">var(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, Optionalfloat]:
</code></pre>
<p>Get the variance.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def var(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, Optional[float]]:
    &quot;&quot;&quot;
    Get the variance.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.var()
    return col(column).var()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsmax"><a class="header" href="#polarsinternalslazy_functionsmax"><code>polars.internals.lazy_functions.max</code></a></h3>
<pre><code class="language-python">max(
    column: Union[str, tp.List[Union[pli.Expr, str]], pli.Series],
) -&gt; Union[pli.Expr, Any]:
</code></pre>
<p>Get the maximum value. Can be used horizontally or vertically.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Column(s) to be used in aggregation. Will lead to different behavior based on the input.
input:
- Union[str, Series] -&gt; aggregate the maximum value of that column.
- tp.List[Expr] -&gt; aggregate the maximum value horizontally.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def max(
    column: Union[str, tp.List[Union[&quot;pli.Expr&quot;, str]], &quot;pli.Series&quot;]
) -&gt; Union[&quot;pli.Expr&quot;, Any]:
    &quot;&quot;&quot;
    Get the maximum value. Can be used horizontally or vertically.

    Parameters
    ----------
    column
        Column(s) to be used in aggregation. Will lead to different behavior based on the input.
        input:
            - Union[str, Series] -&gt; aggregate the maximum value of that column.
            - tp.List[Expr] -&gt; aggregate the maximum value horizontally.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.max()
    elif isinstance(column, list):

        def max_(acc: &quot;pli.Series&quot;, val: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            mask = acc &gt; val
            return acc.zip_with(mask, val)

        first = column[0]
        if isinstance(first, str):
            first = col(first)
        return fold(first, max_, column[1:]).alias(&quot;max&quot;)
    else:
        return col(column).max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsmin"><a class="header" href="#polarsinternalslazy_functionsmin"><code>polars.internals.lazy_functions.min</code></a></h3>
<pre><code class="language-python">min(
    column: Union[str, tp.List[Union[pli.Expr, str]], pli.Series],
) -&gt; Union[pli.Expr, Any]:
</code></pre>
<p>Get the minimum value.</p>
<ul>
<li>[<code>column</code>]: Column(s) to be used in aggregation. Will lead to different behavior based on the input.
input:
- Union[str, Series] -&gt; aggregate the sum value of that column.
- tp.List[Expr] -&gt; aggregate the sum value horizontally.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def min(
    column: Union[str, tp.List[Union[&quot;pli.Expr&quot;, str]], &quot;pli.Series&quot;]
) -&gt; Union[&quot;pli.Expr&quot;, Any]:
    &quot;&quot;&quot;
    Get the minimum value.

    column
        Column(s) to be used in aggregation. Will lead to different behavior based on the input.
        input:
            - Union[str, Series] -&gt; aggregate the sum value of that column.
            - tp.List[Expr] -&gt; aggregate the sum value horizontally.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.min()
    elif isinstance(column, list):

        def min_(acc: &quot;pli.Series&quot;, val: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            mask = acc &lt; val
            return acc.zip_with(mask, val)

        first = column[0]
        if isinstance(first, str):
            first = col(first)
        return fold(first, min_, column[1:]).alias(&quot;min&quot;)
    else:
        return col(column).min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionssum"><a class="header" href="#polarsinternalslazy_functionssum"><code>polars.internals.lazy_functions.sum</code></a></h3>
<pre><code class="language-python">sum(
    column: Union[str, tp.List[Union[pli.Expr, str]], pli.Series],
) -&gt; Union[pli.Expr, Any]:
</code></pre>
<p>Get the sum value.</p>
<ul>
<li>[<code>column</code>]: Column(s) to be used in aggregation. Will lead to different behavior based on the input.
input:
- Union[str, Series] -&gt; aggregate the sum value of that column.
- tp.List[Expr] -&gt; aggregate the sum value horizontally.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def sum(
    column: Union[str, tp.List[Union[&quot;pli.Expr&quot;, str]], &quot;pli.Series&quot;]
) -&gt; Union[&quot;pli.Expr&quot;, Any]:
    &quot;&quot;&quot;
    Get the sum value.

    column
        Column(s) to be used in aggregation. Will lead to different behavior based on the input.
        input:
            - Union[str, Series] -&gt; aggregate the sum value of that column.
            - tp.List[Expr] -&gt; aggregate the sum value horizontally.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.sum()
    elif isinstance(column, list):
        first = column[0]
        if isinstance(first, str):
            first = col(first)
        return fold(first, lambda a, b: a + b, column[1:]).alias(&quot;sum&quot;)
    else:
        return col(column).sum()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsmean"><a class="header" href="#polarsinternalslazy_functionsmean"><code>polars.internals.lazy_functions.mean</code></a></h3>
<pre><code class="language-python">mean(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, float]:
</code></pre>
<p>Get the mean value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def mean(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, float]:
    &quot;&quot;&quot;
    Get the mean value.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.mean()
    return col(column).mean()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsavg"><a class="header" href="#polarsinternalslazy_functionsavg"><code>polars.internals.lazy_functions.avg</code></a></h3>
<pre><code class="language-python">avg(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, float]:
</code></pre>
<p>Alias for mean.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def avg(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, float]:
    &quot;&quot;&quot;
    Alias for mean.
    &quot;&quot;&quot;
    return mean(column)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsmedian"><a class="header" href="#polarsinternalslazy_functionsmedian"><code>polars.internals.lazy_functions.median</code></a></h3>
<pre><code class="language-python">median(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, float, int]:
</code></pre>
<p>Get the median value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def median(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, float, int]:
    &quot;&quot;&quot;
    Get the median value.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.median()
    return col(column).median()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsn_unique"><a class="header" href="#polarsinternalslazy_functionsn_unique"><code>polars.internals.lazy_functions.n_unique</code></a></h3>
<pre><code class="language-python">n_unique(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, int]:
</code></pre>
<p>Count unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def n_unique(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, int]:
    &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.n_unique()
    return col(column).n_unique()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsfirst"><a class="header" href="#polarsinternalslazy_functionsfirst"><code>polars.internals.lazy_functions.first</code></a></h3>
<pre><code class="language-python">first(
    column: Union[str, pli.Series],
) -&gt; Union[pli.Expr, Any]:
</code></pre>
<p>Get the first value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def first(column: Union[str, &quot;pli.Series&quot;]) -&gt; Union[&quot;pli.Expr&quot;, Any]:
    &quot;&quot;&quot;
    Get the first value.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        if column.len() &gt; 0:
            return column[0]
        else:
            raise IndexError(&quot;The series is empty, so no first value can be returned.&quot;)
    return col(column).first()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionslast"><a class="header" href="#polarsinternalslazy_functionslast"><code>polars.internals.lazy_functions.last</code></a></h3>
<pre><code class="language-python">last(column: Union[str, pli.Series]) -&gt; pli.Expr:
</code></pre>
<p>Get the last value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def last(column: Union[str, &quot;pli.Series&quot;]) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Get the last value.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        if column.len() &gt; 0:
            return column[-1]
        else:
            raise IndexError(&quot;The series is empty, so no last value can be returned,&quot;)
    return col(column).last()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionshead"><a class="header" href="#polarsinternalslazy_functionshead"><code>polars.internals.lazy_functions.head</code></a></h3>
<pre><code class="language-python">head(
    column: Union[str, pli.Series], 
    n: Optionalint,
) -&gt; Union[pli.Expr, pli.Series]:
</code></pre>
<p>Get the first n rows of an Expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Column name or Series.</li>
<li>[<code>n</code>]: Number of rows to take.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def head(
    column: Union[str, &quot;pli.Series&quot;], n: Optional[int] = None
) -&gt; Union[&quot;pli.Expr&quot;, &quot;pli.Series&quot;]:
    &quot;&quot;&quot;
    Get the first n rows of an Expression.

    Parameters
    ----------
    column
        Column name or Series.
    n
        Number of rows to take.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.head(n)
    return col(column).head(n)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionstail"><a class="header" href="#polarsinternalslazy_functionstail"><code>polars.internals.lazy_functions.tail</code></a></h3>
<pre><code class="language-python">tail(
    column: Union[str, pli.Series], 
    n: Optionalint,
) -&gt; Union[pli.Expr, pli.Series]:
</code></pre>
<p>Get the last n rows of an Expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Column name or Series.</li>
<li>[<code>n</code>]: Number of rows to take.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def tail(
    column: Union[str, &quot;pli.Series&quot;], n: Optional[int] = None
) -&gt; Union[&quot;pli.Expr&quot;, &quot;pli.Series&quot;]:
    &quot;&quot;&quot;
    Get the last n rows of an Expression.

    Parameters
    ----------
    column
        Column name or Series.
    n
        Number of rows to take.
    &quot;&quot;&quot;
    if isinstance(column, pli.Series):
        return column.tail(n)
    return col(column).tail(n)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionslit"><a class="header" href="#polarsinternalslazy_functionslit"><code>polars.internals.lazy_functions.lit</code></a></h3>
<pre><code class="language-python">lit(
    value: OptionalUnion[float, int, str, date, datetime, pli.Series], 
    dtype: OptionalTypeDataType,
) -&gt; pli.Expr:
</code></pre>
<p>A literal value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>value</code>]: Value that should be used as a <code>literal</code>.</li>
<li>[<code>dtype</code>]: Optionally define a dtype.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="literal-integer"><a class="header" href="#literal-integer">literal integer</a></h1>
<p>lit(1)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="literal-str"><a class="header" href="#literal-str">literal str.</a></h1>
<p>lit(&quot;foo&quot;)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="literal-datetime"><a class="header" href="#literal-datetime">literal datetime</a></h1>
<p>lit(datetime(2021, 1, 20))</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="literal-null"><a class="header" href="#literal-null">literal Null</a></h1>
<p>lit(None)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="literal-eager-series"><a class="header" href="#literal-eager-series">literal eager Series</a></h1>
<p>lit(Series(&quot;a&quot;, [1, 2, 3])</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def lit(
    value: Optional[Union[float, int, str, date, datetime, &quot;pli.Series&quot;]],
    dtype: Optional[Type[DataType]] = None,
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    A literal value.

    Parameters
    ----------
    value
        Value that should be used as a `literal`.
    dtype
        Optionally define a dtype.

    Examples
    --------

    &gt;&gt;&gt; # literal integer
    &gt;&gt;&gt; lit(1)

    &gt;&gt;&gt; # literal str.
    &gt;&gt;&gt; lit(&quot;foo&quot;)

    &gt;&gt;&gt; # literal datetime
    &gt;&gt;&gt; lit(datetime(2021, 1, 20))

    &gt;&gt;&gt; # literal Null
    &gt;&gt;&gt; lit(None)

    &gt;&gt;&gt; # literal eager Series
    &gt;&gt;&gt; lit(Series(&quot;a&quot;, [1, 2, 3])
    &quot;&quot;&quot;
    if isinstance(value, datetime):
        return lit(int((value.replace(tzinfo=timezone.utc)).timestamp() * 1e3)).cast(
            Datetime
        )
    if isinstance(value, date):
        return lit(datetime(value.year, value.month, value.day)).cast(Date)

    if isinstance(value, pli.Series):
        name = value.name
        value = value._s
        return pli.wrap_expr(pylit(value)).alias(name)

    if isinstance(value, np.ndarray):
        return lit(pli.Series(&quot;&quot;, value))

    if dtype:
        return pli.wrap_expr(pylit(value)).cast(dtype)
    return pli.wrap_expr(pylit(value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsspearman_rank_corr"><a class="header" href="#polarsinternalslazy_functionsspearman_rank_corr"><code>polars.internals.lazy_functions.spearman_rank_corr</code></a></h3>
<pre><code class="language-python">spearman_rank_corr(
    a: Union[str, pli.Expr], 
    b: Union[str, pli.Expr],
) -&gt; pli.Expr:
</code></pre>
<p>Compute the spearman rank correlation between two columns.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>a</code>]: Column name or Expression.</li>
<li>[<code>b</code>]: Column name or Expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def spearman_rank_corr(
    a: Union[str, &quot;pli.Expr&quot;],
    b: Union[str, &quot;pli.Expr&quot;],
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Compute the spearman rank correlation between two columns.

    Parameters
    ----------
    a
        Column name or Expression.
    b
        Column name or Expression.
    &quot;&quot;&quot;
    if isinstance(a, str):
        a = col(a)
    if isinstance(b, str):
        b = col(b)
    return pli.wrap_expr(pyspearman_rank_corr(a._pyexpr, b._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionspearson_corr"><a class="header" href="#polarsinternalslazy_functionspearson_corr"><code>polars.internals.lazy_functions.pearson_corr</code></a></h3>
<pre><code class="language-python">pearson_corr(
    a: Union[str, pli.Expr], 
    b: Union[str, pli.Expr],
) -&gt; pli.Expr:
</code></pre>
<p>Compute the pearson's correlation between two columns.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>a</code>]: Column name or Expression.</li>
<li>[<code>b</code>]: Column name or Expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def pearson_corr(
    a: Union[str, &quot;pli.Expr&quot;],
    b: Union[str, &quot;pli.Expr&quot;],
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Compute the pearson's correlation between two columns.

    Parameters
    ----------
    a
        Column name or Expression.
    b
        Column name or Expression.
    &quot;&quot;&quot;
    if isinstance(a, str):
        a = col(a)
    if isinstance(b, str):
        b = col(b)
    return pli.wrap_expr(pypearson_corr(a._pyexpr, b._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionscov"><a class="header" href="#polarsinternalslazy_functionscov"><code>polars.internals.lazy_functions.cov</code></a></h3>
<pre><code class="language-python">cov(
    a: Union[str, pli.Expr], 
    b: Union[str, pli.Expr],
) -&gt; pli.Expr:
</code></pre>
<p>Compute the covariance between two columns/ expressions.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>a</code>]: Column name or Expression.</li>
<li>[<code>b</code>]: Column name or Expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def cov(
    a: Union[str, &quot;pli.Expr&quot;],
    b: Union[str, &quot;pli.Expr&quot;],
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Compute the covariance between two columns/ expressions.

    Parameters
    ----------
    a
        Column name or Expression.
    b
        Column name or Expression.
    &quot;&quot;&quot;
    if isinstance(a, str):
        a = col(a)
    if isinstance(b, str):
        b = col(b)
    return pli.wrap_expr(pycov(a._pyexpr, b._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsmap"><a class="header" href="#polarsinternalslazy_functionsmap"><code>polars.internals.lazy_functions.map</code></a></h3>
<pre><code class="language-python">map(
    exprs: Union[tp.List[str], tp.List[pli.Expr]], 
    f: Callable[[tp.List[pli.Series]], pli.Series], 
    return_dtype: OptionalTypeDataType,
) -&gt; pli.Expr:
</code></pre>
<p>Map a custom function over multiple columns/expressions and produce a single Series result.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Input Series to f</li>
<li>[<code>f</code>]: Function to apply over the input</li>
<li>[<code>return_dtype</code>]: dtype of the output Series</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def map(
    exprs: Union[tp.List[str], tp.List[&quot;pli.Expr&quot;]],
    f: Callable[[tp.List[&quot;pli.Series&quot;]], &quot;pli.Series&quot;],
    return_dtype: Optional[Type[DataType]] = None,
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Map a custom function over multiple columns/expressions and produce a single Series result.

    Parameters
    ----------
    exprs
        Input Series to f
    f
        Function to apply over the input
    return_dtype
        dtype of the output Series

    Returns
    -------
    Expr
    &quot;&quot;&quot;
    exprs = pli._selection_to_pyexpr_list(exprs)
    return pli.wrap_expr(_map_mul(exprs, f, return_dtype, apply_groups=False))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsapply"><a class="header" href="#polarsinternalslazy_functionsapply"><code>polars.internals.lazy_functions.apply</code></a></h3>
<pre><code class="language-python">apply(
    exprs: tp.List[Union[str, pli.Expr]], 
    f: Callable[[tp.List[pli.Series]], pli.Series], 
    return_dtype: OptionalTypeDataType,
) -&gt; pli.Expr:
</code></pre>
<p>Apply a custom function in a GroupBy context.</p>
<p>Depending on the context it has the following behavior:</p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<ul>
<li>Select/Project
Don't do this, use <code>map</code></li>
<li>GroupBy
expected type <code>f</code>: Callable[[Series], Series]
Applies a python function over each group.</li>
</ul>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Input Series to f</li>
<li>[<code>f</code>]: Function to apply over the input</li>
<li>[<code>return_dtype</code>]: dtype of the output Series</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def apply(
    exprs: tp.List[Union[str, &quot;pli.Expr&quot;]],
    f: Callable[[tp.List[&quot;pli.Series&quot;]], &quot;pli.Series&quot;],
    return_dtype: Optional[Type[DataType]] = None,
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Apply a custom function in a GroupBy context.

    Depending on the context it has the following behavior:

    ## Context

    * Select/Project
        Don't do this, use `map`
    * GroupBy
        expected type `f`: Callable[[Series], Series]
        Applies a python function over each group.

    Parameters
    ----------
    exprs
        Input Series to f
    f
        Function to apply over the input
    return_dtype
        dtype of the output Series

    Returns
    -------
    Expr
    &quot;&quot;&quot;
    exprs = pli._selection_to_pyexpr_list(exprs)
    return pli.wrap_expr(_map_mul(exprs, f, return_dtype, apply_groups=True))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsmap_binary"><a class="header" href="#polarsinternalslazy_functionsmap_binary"><code>polars.internals.lazy_functions.map_binary</code></a></h3>
<pre><code class="language-python">map_binary(
    a: Union[str, pli.Expr], 
    b: Union[str, pli.Expr], 
    f: Callable[[pli.Series, pli.Series], pli.Series], 
    return_dtype: OptionalTypeDataType,
) -&gt; pli.Expr:
</code></pre>
<p>.. deprecated:: 0.10.4
use <code>map</code> or <code>apply</code>
Map a custom function over two columns and produce a single Series result.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>a</code>]: Input Series a.</li>
<li>[<code>b</code>]: Input Series b.</li>
<li>[<code>f</code>]: Function to apply.</li>
<li>[<code>return_dtype</code>]: Output type of the udf.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def map_binary(
    a: Union[str, &quot;pli.Expr&quot;],
    b: Union[str, &quot;pli.Expr&quot;],
    f: Callable[[&quot;pli.Series&quot;, &quot;pli.Series&quot;], &quot;pli.Series&quot;],
    return_dtype: Optional[Type[DataType]] = None,
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
     .. deprecated:: 0.10.4
       use `map` or `apply`
    Map a custom function over two columns and produce a single Series result.

    Parameters
    ----------
    a
        Input Series a.
    b
        Input Series b.
    f
        Function to apply.
    return_dtype
        Output type of the udf.
    &quot;&quot;&quot;
    if isinstance(a, str):
        a = col(a)
    if isinstance(b, str):
        b = col(b)
    return pli.wrap_expr(pybinary_function(a._pyexpr, b._pyexpr, f, return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsfold"><a class="header" href="#polarsinternalslazy_functionsfold"><code>polars.internals.lazy_functions.fold</code></a></h3>
<pre><code class="language-python">fold(
    acc: pli.Expr, 
    f: Callable[[pli.Series, pli.Series], pli.Series], 
    exprs: Union[tp.SequenceUnion[pli.Expr, str], pli.Expr],
) -&gt; pli.Expr:
</code></pre>
<p>Accumulate over multiple columns horizontally/ row wise with a left fold.</p>
<p><strong>Parameters:</strong></p>
<p>acc
Accumulator Expression. This is the value that will be initialized when the fold starts.
For a sum this could for instance be lit(0).</p>
<ul>
<li>[<code>f</code>]: Function to apply over the accumulator and the value.
Fn(acc, value) -&gt; new_value</li>
<li>[<code>exprs</code>]: Expressions to aggregate over. May also be a wildcard expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def fold(
    acc: &quot;pli.Expr&quot;,
    f: Callable[[&quot;pli.Series&quot;, &quot;pli.Series&quot;], &quot;pli.Series&quot;],
    exprs: Union[tp.Sequence[Union[&quot;pli.Expr&quot;, str]], &quot;pli.Expr&quot;],
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Accumulate over multiple columns horizontally/ row wise with a left fold.

    Parameters
    ----------
    acc
     Accumulator Expression. This is the value that will be initialized when the fold starts.
     For a sum this could for instance be lit(0).

    f
        Function to apply over the accumulator and the value.
        Fn(acc, value) -&gt; new_value
    exprs
        Expressions to aggregate over. May also be a wildcard expression.
    &quot;&quot;&quot;
    # in case of pl.col(&quot;*&quot;)
    acc = pli.expr_to_lit_or_expr(acc, str_to_lit=True)
    if isinstance(exprs, pli.Expr):
        exprs = [exprs]

    exprs = pli._selection_to_pyexpr_list(exprs)
    return pli.wrap_expr(pyfold(acc._pyexpr, f, exprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsany"><a class="header" href="#polarsinternalslazy_functionsany"><code>polars.internals.lazy_functions.any</code></a></h3>
<pre><code class="language-python">any(name: Union[str, tp.List[pli.Expr]]) -&gt; pli.Expr:
</code></pre>
<p>Evaluate columnwise or elementwise with a bitwise OR operation.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def any(name: Union[str, tp.List[&quot;pli.Expr&quot;]]) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Evaluate columnwise or elementwise with a bitwise OR operation.
    &quot;&quot;&quot;
    if isinstance(name, list):
        return fold(lit(0), lambda a, b: a | b, name).alias(&quot;any&quot;)
    return col(name).sum() &gt; 0
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsexclude"><a class="header" href="#polarsinternalslazy_functionsexclude"><code>polars.internals.lazy_functions.exclude</code></a></h3>
<pre><code class="language-python">exclude(columns: Union[str, tp.List[str]]) -&gt; pli.Expr:
</code></pre>
<p>Exclude certain columns from a wildcard expression.</p>
<p>Syntactic sugar for:
&gt;&gt;&gt; col(&quot;*&quot;).exclude()</p>
<h2 id="parameters-1"><a class="header" href="#parameters-1">Parameters</a></h2>
<ul>
<li>[<code> columns</code>]: Column(s) to exclude from selection</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
&quot;c&quot;: [None, 2, 1]
})
df
shape: (3, 3)
╭─────┬──────┬──────╮
│ a   ┆ b    ┆ c    │
│ --- ┆ ---  ┆ ---  │
│ i64 ┆ str  ┆ i64  │
╞═════╪══════╪══════╡
│ 1   ┆ &quot;a&quot;  ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  ┆ 2    │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null ┆ 1    │
╰─────┴──────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>df.select(pl.exclude(&quot;b&quot;))
shape: (3, 2)
╭─────┬──────╮
│ a   ┆ c    │
│ --- ┆ ---  │
│ i64 ┆ i64  │
╞═════╪══════╡
│ 1   ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ 2    │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ 1    │
╰─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def exclude(columns: Union[str, tp.List[str]]) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
     Exclude certain columns from a wildcard expression.

     Syntactic sugar for:
     &gt;&gt;&gt; col(&quot;*&quot;).exclude()

     Parameters
     ----------
     columns
         Column(s) to exclude from selection


    Examples
    --------

     &gt;&gt;&gt; df = pl.DataFrame({
     &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
     &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
     &gt;&gt;&gt;     &quot;c&quot;: [None, 2, 1]
     &gt;&gt;&gt; })
     &gt;&gt;&gt; df
     shape: (3, 3)
     ╭─────┬──────┬──────╮
     │ a   ┆ b    ┆ c    │
     │ --- ┆ ---  ┆ ---  │
     │ i64 ┆ str  ┆ i64  │
     ╞═════╪══════╪══════╡
     │ 1   ┆ &quot;a&quot;  ┆ null │
     ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
     │ 2   ┆ &quot;b&quot;  ┆ 2    │
     ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
     │ 3   ┆ null ┆ 1    │
     ╰─────┴──────┴──────╯

     &gt;&gt;&gt; df.select(pl.exclude(&quot;b&quot;))
     shape: (3, 2)
     ╭─────┬──────╮
     │ a   ┆ c    │
     │ --- ┆ ---  │
     │ i64 ┆ i64  │
     ╞═════╪══════╡
     │ 1   ┆ null │
     ├╌╌╌╌╌┼╌╌╌╌╌╌┤
     │ 2   ┆ 2    │
     ├╌╌╌╌╌┼╌╌╌╌╌╌┤
     │ 3   ┆ 1    │
     ╰─────┴──────╯

    &quot;&quot;&quot;
    return col(&quot;*&quot;).exclude(columns)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsall"><a class="header" href="#polarsinternalslazy_functionsall"><code>polars.internals.lazy_functions.all</code></a></h3>
<pre><code class="language-python">all(name: OptionalUnion[str, tp.List[pli.Expr]]) -&gt; pli.Expr:
</code></pre>
<p>This function is two things</p>
<ul>
<li>function can do a columnwise or elementwise AND operation</li>
<li>a wildcard column selection</li>
</ul>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: If given this function will apply a bitwise &amp; on the columns.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="sum-all-columns"><a class="header" href="#sum-all-columns">sum all columns</a></h1>
<p>df.select(pl.all().sum())</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>df.select(pl.all([col(name).is_not_null() for name in df.columns]))</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def all(name: Optional[Union[str, tp.List[&quot;pli.Expr&quot;]]] = None) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    This function is two things

    * function can do a columnwise or elementwise AND operation
    * a wildcard column selection

    Parameters
    ----------

    name
        If given this function will apply a bitwise &amp; on the columns.

    Examples
    --------

    &gt;&gt;&gt; # sum all columns
    &gt;&gt;&gt; df.select(pl.all().sum())


    &gt;&gt;&gt; df.select(pl.all([col(name).is_not_null() for name in df.columns]))
    &quot;&quot;&quot;
    if name is None:
        return col(&quot;*&quot;)
    if isinstance(name, list):
        return fold(lit(0), lambda a, b: a &amp; b, name).alias(&quot;all&quot;)
    return col(name).cast(bool).sum() == col(name).count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsgroups"><a class="header" href="#polarsinternalslazy_functionsgroups"><code>polars.internals.lazy_functions.groups</code></a></h3>
<pre><code class="language-python">groups(column: str) -&gt; pli.Expr:
</code></pre>
<p>Syntactic sugar for <code>column(&quot;foo&quot;).agg_groups()</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def groups(column: str) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Syntactic sugar for `column(&quot;foo&quot;).agg_groups()`.
    &quot;&quot;&quot;
    return col(column).agg_groups()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsquantile"><a class="header" href="#polarsinternalslazy_functionsquantile"><code>polars.internals.lazy_functions.quantile</code></a></h3>
<pre><code class="language-python">quantile(column: str, quantile: float) -&gt; pli.Expr:
</code></pre>
<p>Syntactic sugar for <code>column(&quot;foo&quot;).quantile(..)</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def quantile(column: str, quantile: float) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Syntactic sugar for `column(&quot;foo&quot;).quantile(..)`.
    &quot;&quot;&quot;
    return col(column).quantile(quantile)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsarange"><a class="header" href="#polarsinternalslazy_functionsarange"><code>polars.internals.lazy_functions.arange</code></a></h3>
<pre><code class="language-python">arange(
    low: Union[int, pli.Expr, pli.Series], 
    high: Union[int, pli.Expr, pli.Series], 
    step: int, 
    eager: bool,
) -&gt; Union[pli.Expr, pli.Series]:
</code></pre>
<p>Create a range expression. This can be used in a <code>select</code>, <code>with_column</code> etc.
Be sure that the range size is equal to the DataFrame you are collecting.</p>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>(df.lazy()
.filter(pl.col(&quot;foo&quot;) &lt; pl.arange(0, 100))
.collect())</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>low</code>]: Lower bound of range.</li>
<li>[<code>high</code>]: Upper bound of range.</li>
<li>[<code>step</code>]: Step size of the range</li>
<li>[<code>eager</code>]: If eager evaluation is <code>True</code>, a Series is returned instead of an Expr</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def arange(
    low: Union[int, &quot;pli.Expr&quot;, &quot;pli.Series&quot;],
    high: Union[int, &quot;pli.Expr&quot;, &quot;pli.Series&quot;],
    step: int = 1,
    eager: bool = False,
) -&gt; Union[&quot;pli.Expr&quot;, &quot;pli.Series&quot;]:
    &quot;&quot;&quot;
    Create a range expression. This can be used in a `select`, `with_column` etc.
    Be sure that the range size is equal to the DataFrame you are collecting.

     Examples
     --------

    &gt;&gt;&gt; (df.lazy()
        .filter(pl.col(&quot;foo&quot;) &lt; pl.arange(0, 100))
        .collect())

    Parameters
    ----------
    low
        Lower bound of range.
    high
        Upper bound of range.
    step
        Step size of the range
    eager
        If eager evaluation is `True`, a Series is returned instead of an Expr
    &quot;&quot;&quot;
    low = pli.expr_to_lit_or_expr(low, str_to_lit=False)
    high = pli.expr_to_lit_or_expr(high, str_to_lit=False)

    if eager:
        df = pli.DataFrame({&quot;a&quot;: [1]})
        return df.select(arange(low, high, step).alias(&quot;arange&quot;))[&quot;arange&quot;]  # type: ignore

    return pli.wrap_expr(pyarange(low._pyexpr, high._pyexpr, step))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsargsort_by"><a class="header" href="#polarsinternalslazy_functionsargsort_by"><code>polars.internals.lazy_functions.argsort_by</code></a></h3>
<pre><code class="language-python">argsort_by(
    exprs: tp.List[Union[pli.Expr, str]], 
    reverse: Union[tp.List[bool], bool],
) -&gt; pli.Expr:
</code></pre>
<p>Find the indexes that would sort the columns.</p>
<p>Argsort by multiple columns. The first column will be used for the ordering.
If there are duplicates in the first column, the second column will be used to determine the ordering
and so on.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Columns use to determine the ordering.</li>
<li>[<code>reverse</code>]: Default is ascending.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def argsort_by(
    exprs: tp.List[Union[&quot;pli.Expr&quot;, str]], reverse: Union[tp.List[bool], bool] = False
) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Find the indexes that would sort the columns.

    Argsort by multiple columns. The first column will be used for the ordering.
    If there are duplicates in the first column, the second column will be used to determine the ordering
    and so on.

    Parameters
    ----------
    exprs
        Columns use to determine the ordering.
    reverse
        Default is ascending.
    &quot;&quot;&quot;
    if not isinstance(reverse, list):
        reverse = [reverse] * len(exprs)
    exprs = pli._selection_to_pyexpr_list(exprs)
    return pli.wrap_expr(pyargsort_by(exprs, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsconcat_str"><a class="header" href="#polarsinternalslazy_functionsconcat_str"><code>polars.internals.lazy_functions.concat_str</code></a></h3>
<pre><code class="language-python">concat_str(
    exprs: tp.SequenceUnion[pli.Expr, str], 
    sep: str,
) -&gt; pli.Expr:
</code></pre>
<p>Concat Utf8 Series in linear time. Non utf8 columns are cast to utf8.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Columns to concat into a Utf8 Series</li>
<li>[<code>sep</code>]: String value that will be used to separate the values.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def concat_str(exprs: tp.Sequence[Union[&quot;pli.Expr&quot;, str]], sep: str = &quot;&quot;) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Concat Utf8 Series in linear time. Non utf8 columns are cast to utf8.

    Parameters
    ----------
    exprs
        Columns to concat into a Utf8 Series
    sep
        String value that will be used to separate the values.
    &quot;&quot;&quot;
    exprs = pli._selection_to_pyexpr_list(exprs)
    return pli.wrap_expr(_concat_str(exprs, sep))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsformat"><a class="header" href="#polarsinternalslazy_functionsformat"><code>polars.internals.lazy_functions.format</code></a></h3>
<pre><code class="language-python">format(fstring: str, *args) -&gt; pli.Expr:
</code></pre>
<p>String format utility for expressions</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>fstring</code>]: A string that with placeholders.
For example: &quot;hello_{}&quot; or &quot;{}_world</li>
<li>[<code>args</code>]: Expression(s) that fill the placeholders</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;b&quot;: [1, 2, 3]})
df.select([
pl.format(&quot;foo_{}<em>bar</em>{}&quot;, pl.col(&quot;a&quot;), &quot;b&quot;).alias(&quot;fmt&quot;)
])
shape: (3, 1)
┌─────────────┐
│ fmt         │
│ ---         │
│ str         │
╞═════════════╡
│ foo_a_bar_1 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ foo_b_bar_2 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ foo_c_bar_3 │
└─────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def format(fstring: str, *args: Union[&quot;pli.Expr&quot;, str]) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    String format utility for expressions

    Parameters
    ----------
    fstring
        A string that with placeholders.
        For example: &quot;hello_{}&quot; or &quot;{}_world
    args
        Expression(s) that fill the placeholders

    Examples
    --------

    &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;b&quot;: [1, 2, 3]})
    &gt;&gt;&gt; df.select([
    &gt;&gt;&gt;     pl.format(&quot;foo_{}_bar_{}&quot;, pl.col(&quot;a&quot;), &quot;b&quot;).alias(&quot;fmt&quot;)
    &gt;&gt;&gt; ])
    shape: (3, 1)
    ┌─────────────┐
    │ fmt         │
    │ ---         │
    │ str         │
    ╞═════════════╡
    │ foo_a_bar_1 │
    ├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
    │ foo_b_bar_2 │
    ├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
    │ foo_c_bar_3 │
    └─────────────┘

    &quot;&quot;&quot;
    if fstring.count(&quot;{}&quot;) != len(args):
        raise ValueError(&quot;number of placeholders should equal the number of arguments&quot;)

    exprs = []

    arguments = iter(args)
    for i, s in enumerate(fstring.split(&quot;{}&quot;)):
        if i &gt; 0:
            e = pli.expr_to_lit_or_expr(next(arguments), str_to_lit=False)
            exprs.append(e)

        if len(s) &gt; 0:
            exprs.append(lit(s))

    return concat_str(exprs, sep=&quot;&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsconcat_list"><a class="header" href="#polarsinternalslazy_functionsconcat_list"><code>polars.internals.lazy_functions.concat_list</code></a></h3>
<pre><code class="language-python">concat_list(
    exprs: tp.List[Union[str, pli.Expr]],
) -&gt; pli.Expr:
</code></pre>
<p>Concat the arrays in a Series dtype List in linear time.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Columns to concat into a List Series</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def concat_list(exprs: tp.List[Union[str, &quot;pli.Expr&quot;]]) -&gt; &quot;pli.Expr&quot;:
    &quot;&quot;&quot;
    Concat the arrays in a Series dtype List in linear time.

    Parameters
    ----------
    exprs
        Columns to concat into a List Series
    &quot;&quot;&quot;
    exprs = pli._selection_to_pyexpr_list(exprs)
    return pli.wrap_expr(_concat_lst(exprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionscollect_all"><a class="header" href="#polarsinternalslazy_functionscollect_all"><code>polars.internals.lazy_functions.collect_all</code></a></h3>
<pre><code class="language-python">collect_all(
    lazy_frames: tp.List[pli.LazyFrame], 
    type_coercion: bool, 
    predicate_pushdown: bool, 
    projection_pushdown: bool, 
    simplify_expression: bool, 
    string_cache: bool, 
    no_optimization: bool,
) -&gt; tp.List[pli.DataFrame]:
</code></pre>
<p>Collect multiple LazyFrames at the same time. This runs all the computation graphs in parallel on
Polars threadpool.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>type_coercion</code>]: Do type coercion optimization.</p>
</li>
<li>
<p>[<code>predicate_pushdown</code>]: Do predicate pushdown optimization.</p>
</li>
<li>
<p>[<code>projection_pushdown</code>]: Do projection pushdown optimization.</p>
</li>
<li>
<p>[<code>simplify_expression</code>]: Run simplify expressions optimization.</p>
</li>
<li>
<p>[<code>string_cache</code>]: Use a global string cache in this query.
This is needed if you want to join on categorical columns.</p>
<p>Caution!
If you already have set a global string cache, set this to <code>False</code> as this will reset the
global cache when the query is finished.</p>
</li>
<li>
<p>[<code>no_optimization</code>]: Turn off optimizations.</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>List[DataFrame]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def collect_all(
    lazy_frames: &quot;tp.List[pli.LazyFrame]&quot;,
    type_coercion: bool = True,
    predicate_pushdown: bool = True,
    projection_pushdown: bool = True,
    simplify_expression: bool = True,
    string_cache: bool = False,
    no_optimization: bool = False,
) -&gt; &quot;tp.List[pli.DataFrame]&quot;:
    &quot;&quot;&quot;
    Collect multiple LazyFrames at the same time. This runs all the computation graphs in parallel on
    Polars threadpool.

    Parameters
    ----------
    type_coercion
        Do type coercion optimization.
    predicate_pushdown
        Do predicate pushdown optimization.
    projection_pushdown
        Do projection pushdown optimization.
    simplify_expression
        Run simplify expressions optimization.
    string_cache
        Use a global string cache in this query.
        This is needed if you want to join on categorical columns.

        Caution!
            If you already have set a global string cache, set this to `False` as this will reset the
            global cache when the query is finished.
    no_optimization
        Turn off optimizations.

    Returns
    -------
    List[DataFrame]
    &quot;&quot;&quot;
    if no_optimization:
        predicate_pushdown = False
        projection_pushdown = False

    prepared = []

    for lf in lazy_frames:
        ldf = lf._ldf.optimization_toggle(
            type_coercion,
            predicate_pushdown,
            projection_pushdown,
            simplify_expression,
            string_cache,
        )
        prepared.append(ldf)

    out = _collect_all(prepared)

    # wrap the pydataframes into dataframe

    result = []
    for pydf in out:
        result.append(pli.wrap_df(pydf))

    return result
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalslazy_functionsselect"><a class="header" href="#polarsinternalslazy_functionsselect"><code>polars.internals.lazy_functions.select</code></a></h3>
<pre><code class="language-python">select(
    exprs: Union[str, pli.Expr, Sequencestr, Sequencepli.Expr],
) -&gt; pli.DataFrame:
</code></pre>
<p>Run polars expressions without a context.</p>
<p>This is syntactic sugar for running <code>df.select</code> on an empty DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Expressions to run
<strong>Returns:</strong></li>
</ul>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>foo = pl.Series(&quot;foo&quot;, [1, 2, 3])
bar = pl.Series(&quot;bar&quot;, [3, 2, 1])
pl.select([
pl.min([foo, bar])
])
shape: (3, 1)
┌─────┐
│ min │
│ --- │
│ i64 │
╞═════╡
│ 1   │
├╌╌╌╌╌┤
│ 2   │
├╌╌╌╌╌┤
│ 1   │
└─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def select(
    exprs: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]]
) -&gt; &quot;pli.DataFrame&quot;:
    &quot;&quot;&quot;
    Run polars expressions without a context.

    This is syntactic sugar for running `df.select` on an empty DataFrame.

    Parameters
    ----------
    exprs
        Expressions to run
    Returns
    -------
    DataFrame

    Examples
    --------

    &gt;&gt;&gt; foo = pl.Series(&quot;foo&quot;, [1, 2, 3])
    &gt;&gt;&gt; bar = pl.Series(&quot;bar&quot;, [3, 2, 1])
    &gt;&gt;&gt; pl.select([
    &gt;&gt;&gt;     pl.min([foo, bar])
    &gt;&gt;&gt; ])
    shape: (3, 1)
    ┌─────┐
    │ min │
    │ --- │
    │ i64 │
    ╞═════╡
    │ 1   │
    ├╌╌╌╌╌┤
    │ 2   │
    ├╌╌╌╌╌┤
    │ 1   │
    └─────┘
    &quot;&quot;&quot;
    return pli.DataFrame([]).select(exprs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalsseries"><a class="header" href="#module-polarsinternalsseries">Module <code>polars.internals.series</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/internals/series.html#polarsinternalsseriesmatch_dtype"><code>match_dtype()</code></a>: In right hand side operation, make sure that the operand is coerced to the Series dtype</li>
<li><a href="polars/internals/series.html#polarsinternalsseriesget_ffi_func"><code>get_ffi_func()</code></a>: Dynamically obtain the proper ffi function/ method.</li>
<li><a href="polars/internals/series.html#polarsinternalsserieswrap_s"><code>wrap_s()</code></a>: </li>
</ul>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesmatch_dtype"><a class="header" href="#polarsinternalsseriesmatch_dtype"><code>polars.internals.series.match_dtype</code></a></h3>
<pre><code class="language-python">match_dtype(value: Any, dtype: Type[DataType]) -&gt; Any:
</code></pre>
<p>In right hand side operation, make sure that the operand is coerced to the Series dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def match_dtype(value: Any, dtype: &quot;Type[DataType]&quot;) -&gt; Any:
    &quot;&quot;&quot;
    In right hand side operation, make sure that the operand is coerced to the Series dtype
    &quot;&quot;&quot;
    if dtype == Float32 or dtype == Float64:
        return float(value)
    else:
        return int(value)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesget_ffi_func"><a class="header" href="#polarsinternalsseriesget_ffi_func"><code>polars.internals.series.get_ffi_func</code></a></h3>
<pre><code class="language-python">get_ffi_func(
    name: str, 
    dtype: TypeDataType, 
    obj: PySeries,
) -&gt; OptionalCallable[, Any]:
</code></pre>
<p>Dynamically obtain the proper ffi function/ method.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: function or method name where dtype is replaced by &lt;&gt;</li>
<li></li>
<li>[<code>dtype</code>]: polars dtype.</li>
<li>[<code>obj</code>]: Object to find the method for.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>ffi function, or None if not found</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def get_ffi_func(
    name: str,
    dtype: Type[&quot;DataType&quot;],
    obj: &quot;PySeries&quot;,
) -&gt; Optional[Callable[..., Any]]:
    &quot;&quot;&quot;
    Dynamically obtain the proper ffi function/ method.

    Parameters
    ----------
    name
        function or method name where dtype is replaced by &lt;&gt;
        for example
            &quot;call_foo_&lt;&gt;&quot;
    dtype
        polars dtype.
    obj
        Object to find the method for.

    Returns
    -------
    ffi function, or None if not found
    &quot;&quot;&quot;
    ffi_name = dtype_to_ffiname(dtype)
    fname = name.replace(&quot;&lt;&gt;&quot;, ffi_name)
    return getattr(obj, fname, None)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieswrap_s"><a class="header" href="#polarsinternalsserieswrap_s"><code>polars.internals.series.wrap_s</code></a></h3>
<pre><code class="language-python">wrap_s(s: PySeries) -&gt; Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def wrap_s(s: &quot;PySeries&quot;) -&gt; &quot;Series&quot;:
    return Series._from_pyseries(s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsseriesseries"><a class="header" href="#polarsinternalsseriesseries"><code>polars.internals.series.Series</code></a></h1>
<p>A Series represents a single column in a polars DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>name</code> [<code>str, default None</code>]: Name of the series. Will be used as a column name when used in a DataFrame.
When not specified, name is set to an empty string.</li>
<li><code>values</code> [<code>ArrayLike, default None</code>]: One-dimensional data in various forms. Supported are: Sequence, Series,
pyarrow Array, and numpy ndarray.</li>
<li><code>dtype</code> [<code>DataType, default None</code>]: Polars dtype of the Series data. If not specified, the dtype is inferred.</li>
<li>[<code>strict</code>]: Throw error on numeric overflow</li>
<li>[<code>nan_to_null</code>]: In case a numpy arrow is used to create this Series, indicate how to deal with np.nan</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Constructing a Series by specifying name and values positionally:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series('a', [1, 2, 3])
s
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>Notice that the dtype is automatically inferred as a polars Int64:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s.dtype
&lt;class 'polars.datatypes.Int64'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a Series with a specific dtype:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s2 = pl.Series('a', [1, 2, 3], dtype=pl.Float32)
s2
shape: (3,)
Series: 'a' [f32]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>It is possible to construct a Series with values as the first positional argument.
This syntax considered an anti-pattern, but it can be useful in certain
scenarios. You must specify any other arguments through keywords.</p>
<blockquote>
<blockquote>
<blockquote>
<p>s3 = pl.Series([1, 2, 3])
s3
shape: (3,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesinner"><code>inner()</code></a>: </li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriessqrt"><code>sqrt()</code></a>: Compute the square root of the elements</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesdrop_nulls"><code>drop_nulls()</code></a>: Create a new Series that copies data from this Series without null values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesto_frame"><code>to_frame()</code></a>: Cast this Series to a DataFrame.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesdtype"><code>dtype()</code></a>: Get the data type of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesdescribe"><code>describe()</code></a>: Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriessum"><code>sum()</code></a>: Reduce this Series to the sum value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesmean"><code>mean()</code></a>: Reduce this Series to the mean value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesmin"><code>min()</code></a>: Get the minimal value in this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesmax"><code>max()</code></a>: Get the maximum value in this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesstd"><code>std()</code></a>: Get the standard deviation of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesvar"><code>var()</code></a>: Get variance of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesmedian"><code>median()</code></a>: Get the median of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesquantile"><code>quantile()</code></a>: Get the quantile value of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesto_dummies"><code>to_dummies()</code></a>: Get dummy variables.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesvalue_counts"><code>value_counts()</code></a>: Count the unique values in a Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesname"><code>name()</code></a>: Get the name of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesalias"><code>alias()</code></a>: Rename the Series</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrename"><code>rename()</code></a>: Rename this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieschunk_lengths"><code>chunk_lengths()</code></a>: Get the length of each individual chunk.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesn_chunks"><code>n_chunks()</code></a>: Get the number of chunks that this Series contains.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriescumsum"><code>cumsum()</code></a>: Get an array with the cumulative sum computed at every element.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriescummin"><code>cummin()</code></a>: Get an array with the cumulative min computed at every element.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriescummax"><code>cummax()</code></a>: Get an array with the cumulative max computed at every element.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriescumprod"><code>cumprod()</code></a>: Get an array with the cumulative product computed at every element.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieslimit"><code>limit()</code></a>: Take n elements from this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesslice"><code>slice()</code></a>: Get a slice of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesappend"><code>append()</code></a>: Append a Series to this one.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesfilter"><code>filter()</code></a>: Filter elements by a boolean mask.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieshead"><code>head()</code></a>: Get first N elements as Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriestail"><code>tail()</code></a>: Get last N elements as Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriestake_every"><code>take_every()</code></a>: Take every nth value in the Series and return as new Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriessort"><code>sort()</code></a>: Sort this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesargsort"><code>argsort()</code></a>: Index location of the sorted variant of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarg_sort"><code>arg_sort()</code></a>: ..deprecate::</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarg_unique"><code>arg_unique()</code></a>: Get unique index as Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarg_min"><code>arg_min()</code></a>: Get the index of the minimal value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarg_max"><code>arg_max()</code></a>: Get the index of the maximal value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesunique"><code>unique()</code></a>: Get unique elements in series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriestake"><code>take()</code></a>: Take values by index.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesnull_count"><code>null_count()</code></a>: Count the null values in this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieshas_validity"><code>has_validity()</code></a>: Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_null"><code>is_null()</code></a>: Get mask of null values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_not_null"><code>is_not_null()</code></a>: Get mask of non null values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_finite"><code>is_finite()</code></a>: Get mask of finite values if Series dtype is Float.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_infinite"><code>is_infinite()</code></a>: Get mask of infinite values if Series dtype is Float.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_nan"><code>is_nan()</code></a>: Get mask of NaN values if Series dtype is Float.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_not_nan"><code>is_not_nan()</code></a>: Get negated mask of NaN values if Series dtype is_not Float.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_in"><code>is_in()</code></a>: Check if elements of this Series are in the right Series, or List values of the right Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarg_true"><code>arg_true()</code></a>: Get index values where Boolean Series evaluate True.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_unique"><code>is_unique()</code></a>: Get mask of all unique values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_first"><code>is_first()</code></a>: Get a mask of the first unique value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_duplicated"><code>is_duplicated()</code></a>: Get mask of all duplicated values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesexplode"><code>explode()</code></a>: Explode a list or utf8 Series. This means that every item is expanded to a new row.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesseries_equal"><code>series_equal()</code></a>: Check if series is equal with another Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieslen"><code>len()</code></a>: Length of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesshape"><code>shape()</code></a>: Shape of this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriescast"><code>cast()</code></a>: Cast between data types.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesto_list"><code>to_list()</code></a>: Convert this Series to a Python List. This operation clones data.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrechunk"><code>rechunk()</code></a>: Create a single chunk of memory for this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_numeric"><code>is_numeric()</code></a>: Check if this Series datatype is numeric.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_datetime"><code>is_datetime()</code></a>: Check if this Series datatype is a datetime.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_float"><code>is_float()</code></a>: Check if this Series has floating point numbers.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_boolean"><code>is_boolean()</code></a>: Check if this Series is a Boolean.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesis_utf8"><code>is_utf8()</code></a>: Checks if this Series datatype is a Utf8.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesview"><code>view()</code></a>: Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesto_numpy"><code>to_numpy()</code></a>: Convert this Series to numpy. This operation clones data but is completely safe.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesto_arrow"><code>to_arrow()</code></a>: Get the underlying Arrow Array. If the Series contains only a single chunk</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesset"><code>set()</code></a>: Set masked values.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesset_at_idx"><code>set_at_idx()</code></a>: Set values at the index locations.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesclone"><code>clone()</code></a>: Cheap deep clones.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesfill_null"><code>fill_null()</code></a>: Fill null values with a filling strategy.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesfloor"><code>floor()</code></a>: Floor underlying floating point array to the lowest integers smaller or equal to the float value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesround"><code>round()</code></a>: Round underlying floating point data by <code>decimals</code> digits.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesdot"><code>dot()</code></a>: Compute the dot/inner product between two Series</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesmode"><code>mode()</code></a>: Compute the most occurring value(s). Can return multiple Values</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriessin"><code>sin()</code></a>: Compute the element-wise value for Trigonometric sine.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriescos"><code>cos()</code></a>: Compute the element-wise value for Trigonometric cosine.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriestan"><code>tan()</code></a>: Compute the element-wise value for Trigonometric tangent.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarcsin"><code>arcsin()</code></a>: Compute the element-wise value for Trigonometric Inverse sine.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarccos"><code>arccos()</code></a>: Compute the element-wise value for Trigonometric Inverse cosine.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarctan"><code>arctan()</code></a>: Compute the element-wise value for Trigonometric Inverse tangent.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesapply"><code>apply()</code></a>: Apply a function over elements in this Series and return a new Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieszip_with"><code>zip_with()</code></a>: Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_min"><code>rolling_min()</code></a>: apply a rolling min (moving min) over the values in this array.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_max"><code>rolling_max()</code></a>: Apply a rolling max (moving max) over the values in this array.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_mean"><code>rolling_mean()</code></a>: Apply a rolling mean (moving mean) over the values in this array.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_sum"><code>rolling_sum()</code></a>: Apply a rolling sum (moving sum) over the values in this array.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_std"><code>rolling_std()</code></a>: Compute a rolling std dev</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_var"><code>rolling_var()</code></a>: Compute a rolling variance.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_apply"><code>rolling_apply()</code></a>: Allows a custom rolling window function.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_median"><code>rolling_median()</code></a>: Compute a rolling median</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_quantile"><code>rolling_quantile()</code></a>: Compute a rolling quantile</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrolling_skew"><code>rolling_skew()</code></a>: Compute a rolling skew</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriessample"><code>sample()</code></a>: Sample from this Series by setting either <code>n</code> or <code>frac</code>.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriespeak_max"><code>peak_max()</code></a>: Get a boolean mask of the local maximum peaks.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriespeak_min"><code>peak_min()</code></a>: Get a boolean mask of the local minimum peaks.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesn_unique"><code>n_unique()</code></a>: Count the number of unique values in this Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesshrink_to_fit"><code>shrink_to_fit()</code></a>: Shrink memory usage of this Series to fit the exact capacity needed to hold the data.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesdt"><code>dt()</code></a>: Create an object namespace of all datetime related methods.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesarr"><code>arr()</code></a>: Create an object namespace of all list related methods.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesstr"><code>str()</code></a>: Create an object namespace of all string related methods.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieshash"><code>hash()</code></a>: Hash the Series.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesreinterpret"><code>reinterpret()</code></a>: Reinterpret the underlying bits as a signed/unsigned integer.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesabs"><code>abs()</code></a>: Take absolute values</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesrank"><code>rank()</code></a>: Assign ranks to data, dealing with ties appropriately.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesdiff"><code>diff()</code></a>: Calculate the n-th discrete difference.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesskew"><code>skew()</code></a>: Compute the sample skewness of a data set.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesserieskurtosis"><code>kurtosis()</code></a>: Compute the kurtosis (Fisher or Pearson) of a dataset.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesclip"><code>clip()</code></a>: Clip (limit) the values in an array.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesstr_concat"><code>str_concat()</code></a>: Vertically concat the values in the Series to a single string value.</li>
<li><a href="polars/internals/series/Series.html#polarsinternalsseriesseriesreshape"><code>reshape()</code></a>: Reshape this Series to a flat series, shape: (len,)</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Series:
    &quot;&quot;&quot;
    A Series represents a single column in a polars DataFrame.

    Parameters
    ----------
    name : str, default None
        Name of the series. Will be used as a column name when used in a DataFrame.
        When not specified, name is set to an empty string.
    values : ArrayLike, default None
        One-dimensional data in various forms. Supported are: Sequence, Series,
        pyarrow Array, and numpy ndarray.
    dtype : DataType, default None
        Polars dtype of the Series data. If not specified, the dtype is inferred.
    strict
        Throw error on numeric overflow
    nan_to_null
        In case a numpy arrow is used to create this Series, indicate how to deal with np.nan

    Examples
    --------
    Constructing a Series by specifying name and values positionally:

    &gt;&gt;&gt; s = pl.Series('a', [1, 2, 3])
    &gt;&gt;&gt; s
    shape: (3,)
    Series: 'a' [i64]
    [
            1
            2
            3
    ]

    Notice that the dtype is automatically inferred as a polars Int64:

    &gt;&gt;&gt; s.dtype
    &lt;class 'polars.datatypes.Int64'&gt;

    Constructing a Series with a specific dtype:

    &gt;&gt;&gt; s2 = pl.Series('a', [1, 2, 3], dtype=pl.Float32)
    &gt;&gt;&gt; s2
    shape: (3,)
    Series: 'a' [f32]
    [
            1
            2
            3
    ]

    It is possible to construct a Series with values as the first positional argument.
    This syntax considered an anti-pattern, but it can be useful in certain
    scenarios. You must specify any other arguments through keywords.

    &gt;&gt;&gt; s3 = pl.Series([1, 2, 3])
    &gt;&gt;&gt; s3
    shape: (3,)
    Series: '' [i64]
    [
            1
            2
            3
    ]

    &quot;&quot;&quot;

    def __init__(
        self,
        name: Optional[Union[str, ArrayLike]] = None,
        values: Optional[ArrayLike] = None,
        dtype: Optional[Type[DataType]] = None,
        strict: bool = True,
        nan_to_null: bool = False,
    ):

        # Handle case where values are passed as the first argument
        if name is not None and not isinstance(name, str):
            if values is None:
                values = name
                name = None
            else:
                raise ValueError(&quot;Series name must be a string.&quot;)

        # TODO: Remove if-statement below once Series name is allowed to be None
        if name is None:
            name = &quot;&quot;

        if values is None:
            self._s = sequence_to_pyseries(name, [], dtype=dtype)
        elif isinstance(values, Series):
            self._s = series_to_pyseries(name, values)
        elif _PYARROW_AVAILABLE and isinstance(values, pa.Array):
            self._s = arrow_to_pyseries(name, values)
        elif isinstance(values, np.ndarray):
            self._s = numpy_to_pyseries(name, values, strict, nan_to_null)
        elif isinstance(values, Sequence):
            self._s = sequence_to_pyseries(name, values, dtype=dtype, strict=strict)
        elif _PANDAS_AVAILABLE and isinstance(values, (pd.Series, pd.DatetimeIndex)):
            self._s = pandas_to_pyseries(name, values)
        else:
            raise ValueError(&quot;Series constructor not called properly.&quot;)

    @classmethod
    def _from_pyseries(cls, pyseries: &quot;PySeries&quot;) -&gt; &quot;Series&quot;:
        series = cls.__new__(cls)
        series._s = pyseries
        return series

    @classmethod
    def _repeat(
        cls, name: str, val: Union[int, float, str, bool], n: int, dtype: Type[DataType]
    ) -&gt; &quot;Series&quot;:
        return cls._from_pyseries(PySeries.repeat(name, val, n, dtype))

    @classmethod
    def _from_arrow(cls, name: str, values: &quot;pa.Array&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Construct a Series from an Arrow Array.
        &quot;&quot;&quot;
        return cls._from_pyseries(arrow_to_pyseries(name, values))

    @classmethod
    def _from_pandas(
        cls,
        name: str,
        values: Union[&quot;pd.Series&quot;, &quot;pd.DatetimeIndex&quot;],
        nan_to_none: bool = True,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Construct a Series from a pandas Series or DatetimeIndex.
        &quot;&quot;&quot;
        return cls._from_pyseries(
            pandas_to_pyseries(name, values, nan_to_none=nan_to_none)
        )

    def inner(self) -&gt; &quot;PySeries&quot;:
        return self._s

    def __getstate__(self):  # type: ignore
        return self._s.__getstate__()

    def __setstate__(self, state):  # type: ignore
        self._s = sequence_to_pyseries(&quot;&quot;, [], Float32)
        self._s.__setstate__(state)

    def __str__(self) -&gt; str:
        return self._s.as_str()

    def __repr__(self) -&gt; str:
        return self.__str__()

    def __and__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        if not isinstance(other, Series):
            other = Series([other])
        return wrap_s(self._s.bitand(other._s))

    def __rand__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return self.__and__(other)

    def __or__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        if not isinstance(other, Series):
            other = Series([other])
        return wrap_s(self._s.bitor(other._s))

    def __ror__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return self.__or__(other)

    def __xor__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        if not isinstance(other, Series):
            other = Series([other])
        return wrap_s(self._s.bitxor(other._s))

    def __rxor__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return self.__xor__(other)

    def __eq__(self, other: Any) -&gt; &quot;Series&quot;:  # type: ignore[override]
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.eq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __ne__(self, other: Any) -&gt; &quot;Series&quot;:  # type: ignore[override]
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.neq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;neq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __gt__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.gt(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;gt_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __lt__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.lt(other._s))
        # cast other if it doesn't match
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;lt_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __ge__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.gt_eq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;gt_eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __le__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.lt_eq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;lt_eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __add__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, str):
            other = Series(&quot;&quot;, [other])
        if isinstance(other, Series):
            return wrap_s(self._s.add(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;add_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __sub__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.sub(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;sub_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __truediv__(self, other: Any) -&gt; &quot;Series&quot;:
        # this branch is exactly the floordiv function without rounding the floats
        if self.is_float():
            if isinstance(other, Series):
                return Series._from_pyseries(self._s.div(other._s))

            other = maybe_cast(other, self.dtype)
            f = get_ffi_func(&quot;div_&lt;&gt;&quot;, self.dtype, self._s)
            if f is None:
                return NotImplemented
            return wrap_s(f(other))

        return self.cast(Float64) / other

    def __floordiv__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            if self.is_float():
                return Series._from_pyseries(self._s.div(other._s)).floor()
            return Series._from_pyseries(self._s.div(other._s))

        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;div_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        if self.is_float():
            return wrap_s(f(other)).floor()
        return wrap_s(f(other))

    def __mul__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.mul(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;mul_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __mod__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.rem(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;rem_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rmod__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.rem(self._s))
        other = maybe_cast(other, self.dtype)
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;rem_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __radd__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.add(other._s))
        other = maybe_cast(other, self.dtype)
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;add_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rsub__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.sub(self._s))
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;sub_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __invert__(self) -&gt; &quot;Series&quot;:
        if self.dtype == Boolean:
            return wrap_s(self._s._not())
        return NotImplemented

    def __rtruediv__(self, other: Any) -&gt; np.ndarray:
        if self.is_float():
            self.__rfloordiv__(other)

        if isinstance(other, int):
            other = float(other)

        return self.cast(Float64).__rfloordiv__(other)  # type: ignore

    def __rfloordiv__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.div(self._s))
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;div_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rmul__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.mul(other._s))
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;mul_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __pow__(self, power: float, modulo: None = None) -&gt; &quot;Series&quot;:
        return np.power(self, power)  # type: ignore

    def __neg__(self) -&gt; &quot;Series&quot;:
        return 0 - self

    def __getitem__(self, item: Any) -&gt; Any:
        if isinstance(item, int):
            if item &lt; 0:
                item = self.len() + item
            if self.dtype in (List, Date, Datetime, Object):
                f = get_ffi_func(&quot;get_&lt;&gt;&quot;, self.dtype, self._s)
                if f is None:
                    return NotImplemented
                out = f(item)
                if self.dtype == List:
                    if out is None:
                        return None
                    return wrap_s(out)
                return out

            return self._s.get_idx(item)
        # assume it is boolean mask
        if isinstance(item, Series):
            return Series._from_pyseries(self._s.filter(item._s))

        if isinstance(item, range):
            step: Optional[int]
            # maybe we can slice instead of take by indices
            if item.step != 1:
                step = item.step
            else:
                step = None
            slc = slice(item.start, item.stop, step)
            return self[slc]

        # slice
        if type(item) == slice:
            start, stop, stride = item.indices(self.len())
            out = self.slice(start, stop - start)
            if stride != 1:
                return out.take_every(stride)
            else:
                return out
        f = get_ffi_func(&quot;get_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        out = f(item)
        if self.dtype == List:
            return wrap_s(out)
        return out

    def __setitem__(self, key: Any, value: Any) -&gt; None:
        if isinstance(value, list):
            raise ValueError(&quot;cannot set with a list as value, use a primitive value&quot;)
        if isinstance(key, Series):
            if key.dtype == Boolean:
                self._s = self.set(key, value)._s
            elif key.dtype == UInt64:
                self._s = self.set_at_idx(key.cast(UInt32), value)._s
            elif key.dtype == UInt32:
                self._s = self.set_at_idx(key, value)._s
        # TODO: implement for these types without casting to series
        elif isinstance(key, (np.ndarray, list, tuple)):
            s = wrap_s(PySeries.new_u32(&quot;&quot;, np.array(key, np.uint32), True))
            self.__setitem__(s, value)
        elif isinstance(key, int):
            self.__setitem__([key], value)
        else:
            raise ValueError(f'cannot use &quot;{key}&quot; for indexing')

    def sqrt(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements

        Syntactic sugar for

        &gt;&gt;&gt; pl.Series([1, 2]) ** 0.5
        &quot;&quot;&quot;
        return self ** 0.5

    def drop_nulls(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a new Series that copies data from this Series without null values.
        &quot;&quot;&quot;
        return wrap_s(self._s.drop_nulls())

    def to_frame(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Cast this Series to a DataFrame.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; df = s.to_frame()
        &gt;&gt;&gt; df
        shape: (3, 1)
        ╭─────╮
        │ a   │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        ╰─────╯

        &gt;&gt;&gt; type(df)
        &lt;class 'polars.eager.frame.DataFrame'&gt;

        &quot;&quot;&quot;
        return pli.wrap_df(PyDataFrame([self._s]))

    @property
    def dtype(self) -&gt; Type[DataType]:
        &quot;&quot;&quot;
        Get the data type of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.dtype
        &lt;class 'polars.datatypes.Int64'&gt;

        &quot;&quot;&quot;
        return DTYPES[self._s.dtype()]

    def describe(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.

        Returns
        -------
        Dictionary with summary statistics of a Series.

        Examples
        --------
        &gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; series_num.describe()
        shape: (6, 2)
        ┌──────────────┬────────────────────┐
        │ statistic    ┆ value              │
        │ ---          ┆ ---                │
        │ str          ┆ f64                │
        ╞══════════════╪════════════════════╡
        │ &quot;min&quot;        ┆ 1                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;max&quot;        ┆ 5                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 0.0                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;mean&quot;       ┆ 3                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;std&quot;        ┆ 1.5811388300841898 │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5                  │
        └──────────────┴────────────────────┘

        &gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, None, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; series_str.describe()
        shape: (3, 2)
        ┌──────────────┬───────┐
        │ statistic    ┆ value │
        │ ---          ┆ ---   │
        │ str          ┆ i64   │
        ╞══════════════╪═══════╡
        │ &quot;unique&quot;     ┆ 4     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 1     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5     │
        └──────────────┴───────┘

        &quot;&quot;&quot;
        stats: Dict[str, Union[Optional[float], int, str]]

        if self.len() == 0:
            raise ValueError(&quot;Series must contain at least one value&quot;)
        elif self.is_numeric():
            s = self.cast(Float64)
            stats = {
                &quot;min&quot;: s.min(),
                &quot;max&quot;: s.max(),
                &quot;null_count&quot;: s.null_count(),
                &quot;mean&quot;: s.mean(),
                &quot;std&quot;: s.std(),
                &quot;count&quot;: s.len(),
            }
        elif self.is_boolean():
            stats = {
                &quot;sum&quot;: self.sum(),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_utf8():
            stats = {
                &quot;unique&quot;: len(self.unique()),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_datetime():
            # we coerce all to string, because a polars column
            # only has a single dtype and dates: datetime and count: int don't match
            stats = {
                &quot;min&quot;: str(self.dt.min()),
                &quot;max&quot;: str(self.dt.max()),
                &quot;null_count&quot;: str(self.null_count()),
                &quot;count&quot;: str(self.len()),
            }
        else:
            raise TypeError(&quot;This type is not supported&quot;)

        return pli.DataFrame(
            {&quot;statistic&quot;: list(stats.keys()), &quot;value&quot;: list(stats.values())}
        )

    def sum(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the sum value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.sum()
        6

        &quot;&quot;&quot;
        return self._s.sum()

    def mean(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the mean value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.mean()
        2.0

        &quot;&quot;&quot;
        return self._s.mean()

    def min(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the minimal value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        1

        &quot;&quot;&quot;
        return self._s.min()

    def max(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the maximum value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        3

        &quot;&quot;&quot;
        return self._s.max()

    def std(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get the standard deviation of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.std()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.std(self.drop_nulls().view(), ddof=ddof)

    def var(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get variance of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.var()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.var(self.drop_nulls().view(), ddof=ddof)

    def median(self) -&gt; float:
        &quot;&quot;&quot;
        Get the median of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.median()
        2.0

        &quot;&quot;&quot;
        return self._s.median()

    def quantile(self, quantile: float) -&gt; float:
        &quot;&quot;&quot;
        Get the quantile value of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.quantile(0.5)
        2

        &quot;&quot;&quot;
        return self._s.quantile(quantile)

    def to_dummies(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Get dummy variables.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_dummies()
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a_1 ┆ a_2 ┆ a_3 │
        │ --- ┆ --- ┆ --- │
        │ u8  ┆ u8  ┆ u8  │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 0   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 1   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 0   ┆ 1   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.to_dummies())

    def value_counts(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Count the unique values in a Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.value_counts()
        shape: (3, 2)
        ╭─────┬────────╮
        │ a   ┆ counts │
        │ --- ┆ ---    │
        │ i64 ┆ u32    │
        ╞═════╪════════╡
        │ 2   ┆ 2      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 1   ┆ 1      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 3   ┆ 1      │
        ╰─────┴────────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.value_counts())

    @property
    def name(self) -&gt; str:
        &quot;&quot;&quot;
        Get the name of this Series.
        &quot;&quot;&quot;
        return self._s.name()

    def alias(self, name: str) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Rename the Series

        Parameters
        ----------
        name
            New name

        Returns
        -------

        &quot;&quot;&quot;
        s = self.clone()
        s._s.rename(name)
        return s

    def rename(self, name: str, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Rename this Series.

        Parameters
        ----------
        name
            New name.
        in_place
            Modify the Series in-place.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.rename('b')
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.rename(name)
            return None
        else:
            return self.alias(name)

    def chunk_lengths(self) -&gt; tp.List[int]:
        &quot;&quot;&quot;
        Get the length of each individual chunk.
        &quot;&quot;&quot;
        return self._s.chunk_lengths()

    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get the number of chunks that this Series contains.
        &quot;&quot;&quot;
        return self._s.n_chunks()

    def cumsum(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumsum()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                3
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumsum(reverse))

    def cummin(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummin()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                1
                1
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummin(reverse))

    def cummax(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummax()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummax(reverse))

    def cumprod(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumprod()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumprod(reverse))

    def limit(self, num_elements: int = 10) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take n elements from this Series.

        Parameters
        ----------
        num_elements
            Amount of elements to take.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.limit(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.limit(num_elements))

    def slice(self, offset: int, length: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a slice of this Series.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.slice(1, 2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.slice(offset, length))

    def append(self, other: &quot;Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Append a Series to this one.

        Parameters
        ----------
        other
            Series to append.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.append(s2)
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
                6
        ]

        &quot;&quot;&quot;
        self._s.append(other._s)

    def filter(self, predicate: Union[&quot;Series&quot;, list]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Filter elements by a boolean mask.

        Parameters
        ----------
        predicate
            Boolean mask.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; mask = pl.Series(&quot;&quot;, [True, False, True])
        &gt;&gt;&gt; s.filter(mask)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        if isinstance(predicate, list):
            predicate = Series(&quot;&quot;, predicate)
        return wrap_s(self._s.filter(predicate._s))

    def head(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get first N elements as Series.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.head(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.head(length))

    def tail(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get last N elements as Series.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.tail(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.tail(length))

    def take_every(self, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as new Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take_every(2)
        shape: (2,)
        Series: '' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.take_every(n))

    def sort(self, in_place: bool = False, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sort this Series.

        Parameters
        ----------
        in_place
            Sort in place.
        reverse
            Reverse sort.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 3, 4, 2])
        &gt;&gt;&gt; s.sort()
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
        ]
        &gt;&gt;&gt; s.sort(reverse=True)
        shape: (4,)
        Series: 'a' [i64]
        [
                4
                3
                2
                1
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.sort_in_place(reverse)
            return self
        else:
            return wrap_s(self._s.sort(reverse))

    def argsort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [5, 3, 4, 1, 2])
        &gt;&gt;&gt; s.argsort()
        shape: (4,)
        Series: 'a' [i64]
        [
            3
            4
            1
            2
            0
        ]
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))

    def arg_sort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        ..deprecate::

        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))

    def arg_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique index as Series.
        &quot;&quot;&quot;
        return wrap_s(self._s.arg_unique())

    def arg_min(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return self._s.arg_min()

    def arg_max(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return self._s.arg_max()

    def unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique elements in series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.unique()
        shape: (3,)
        Series: 'a' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.unique())

    def take(self, indices: Union[np.ndarray, tp.List[int]]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        indices
            Index location used for selection.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take([1, 3])
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                4
        ]

        &quot;&quot;&quot;
        if isinstance(indices, list):
            indices = np.array(indices)
        return Series._from_pyseries(self._s.take(indices))

    def null_count(self) -&gt; int:
        &quot;&quot;&quot;
        Count the null values in this Series.
        &quot;&quot;&quot;
        return self._s.null_count()

    def has_validity(self) -&gt; bool:
        &quot;&quot;&quot;
        Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.
        Use this to swiftly assert a Series does not have null values.
        &quot;&quot;&quot;
        return self._s.has_validity()

    def is_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_null()
        shape: (4,)
        Series: 'is_null' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_null())

    def is_not_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of non null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_not_null()
        shape: (4,)
        Series: 'is_not_null' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_null())

    def is_finite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of finite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_finite()
        shape: (3,)
        Series: 'a' [bool]
        [
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_finite())

    def is_infinite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of infinite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_infinite()
        shape: (3,)
        Series: 'a' [bool]
        [
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_infinite())

    def is_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of NaN values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_nan())

    def is_not_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get negated mask of NaN values if Series dtype is_not Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_not_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_nan())

    def is_in(self, other: Union[&quot;Series&quot;, tp.List]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [2, 4])
        &gt;&gt;&gt; s2.is_in(s)
        shape: (2,)
        Series: 'b' [bool]
        [
                true
                false
        ]

        &quot;&quot;&quot;
        if type(other) is list:
            other = Series(&quot;&quot;, other)
        return wrap_s(self._s.is_in(other._s))  # type: ignore

    def arg_true(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get index values where Boolean Series evaluate True.

        Returns
        -------
        UInt32 Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.arg_true())

    def is_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all unique values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_unique()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_unique())

    def is_first(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_first())

    def is_duplicated(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all duplicated values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_duplicated()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_duplicated())

    def explode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series('a', [[1, 2], [3, 4], [9, 10]])
        &gt;&gt;&gt; s.explode()
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                9
                10
        ]

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_s(self._s.explode())

    def series_equal(
        self, other: &quot;Series&quot;, null_equal: bool = False, strict: bool = False
    ) -&gt; bool:
        &quot;&quot;&quot;
        Check if series is equal with another Series.

        Parameters
        ----------
        other
            Series to compare with.
        null_equal
            Consider null values as equal.
        strict
            Don't allow different numerical dtypes, e.g. comparing `pl.UInt32` with a `pl.Int64` will return `False`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.series_equal(s))
        True
        &gt;&gt;&gt; s.series_equal(s2))
        False

        &quot;&quot;&quot;
        return self._s.series_equal(other._s, null_equal, strict)

    def len(self) -&gt; int:
        &quot;&quot;&quot;
        Length of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.len()
        3

        &quot;&quot;&quot;
        return self._s.len()

    @property
    def shape(self) -&gt; Tuple[int]:
        &quot;&quot;&quot;
        Shape of this Series.
        &quot;&quot;&quot;
        return (self._s.len(),)

    def __len__(self) -&gt; int:
        return self.len()

    def cast(
        self,
        dtype: Union[Type[DataType], Type[int], Type[float], Type[str], Type[bool]],
        strict: bool = True,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        shape: (3,)
        Series: 'a' [bool]
        [
            true
            false
            true
        ]
        &gt;&gt;&gt; s.cast(pl.UInt32)
        shape: (3,)
        Series: 'a' [u32]
        [
            1
            0
            1
        ]

        &quot;&quot;&quot;
        pl_dtype = py_type_to_dtype(dtype)
        return wrap_s(self._s.cast(str(pl_dtype), strict))

    def to_list(self, use_pyarrow: bool = False) -&gt; tp.List[Optional[Any]]:
        &quot;&quot;&quot;
        Convert this Series to a Python List. This operation clones data.

        Parameters
        ----------
        use_pyarrow
            Use pyarrow for the conversion.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_list()
        [1, 2, 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'list'&gt;

        &quot;&quot;&quot;
        if use_pyarrow:
            return self.to_arrow().to_pylist()
        return self._s.to_list()

    def __iter__(self) -&gt; &quot;SeriesIter&quot;:
        return SeriesIter(self.len(), self)

    def rechunk(self, in_place: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a single chunk of memory for this Series.

        Parameters
        ----------
        in_place
            In place or not.
        &quot;&quot;&quot;
        opt_s = self._s.rechunk(in_place)
        if in_place:
            return self
        else:
            return wrap_s(opt_s)

    def is_numeric(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is numeric.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.is_numeric()
        True

        &quot;&quot;&quot;
        return self.dtype in (
            Int8,
            Int16,
            Int32,
            Int64,
            UInt8,
            UInt16,
            UInt32,
            UInt64,
            Float32,
            Float64,
        )

    def is_datetime(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is a datetime.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series([date(2021, 1, 1), date(2021, 1, 2), date(2021, 1, 3)])
        &gt;&gt;&gt; s.is_datetime()
        True

        &quot;&quot;&quot;
        return self.dtype in (Date, Datetime)

    def is_float(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series has floating point numbers.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0])
        &gt;&gt;&gt; s.is_float()
        True

        &quot;&quot;&quot;
        return self.dtype in (Float32, Float64)

    def is_boolean(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series is a Boolean.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        &gt;&gt;&gt; s.is_boolean()
        True

        &quot;&quot;&quot;
        return self.dtype is Boolean

    def is_utf8(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks if this Series datatype is a Utf8.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; s.is_utf8()
        True
        &quot;&quot;&quot;
        return self.dtype is Utf8

    def view(self, ignore_nulls: bool = False) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
        missing values. Don't use this unless you know what you are doing.

        .. warning::

            This function can lead to undefined behavior in the following cases:

            &gt;&gt;&gt; # returns a view to a piece of memory that is already dropped.
            &gt;&gt;&gt; pl.Series([1, 3, 5]).sort().view()

            &gt;&gt;&gt; # Sums invalid data that is missing.
            &gt;&gt;&gt; pl.Series([1, 2, None]).view().sum()

        &quot;&quot;&quot;
        if not ignore_nulls:
            assert not self.has_validity()

        ptr_type = dtype_to_ctype(self.dtype)
        ptr = self._s.as_single_ptr()
        array = _ptr_to_numpy(ptr, self.len(), ptr_type)
        array.setflags(write=False)
        return array

    def __array__(self, dtype=None) -&gt; np.ndarray:  # type: ignore
        return self.to_numpy().__array__(dtype)

    def __array_ufunc__(
        self, ufunc: Callable[..., Any], method: str, *inputs: Any, **kwargs: Any
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Numpy universal functions.
        &quot;&quot;&quot;
        if self._s.n_chunks() &gt; 0:
            self._s.rechunk(in_place=True)

        if method == &quot;__call__&quot;:
            args: tp.List[Union[Number, np.ndarray]] = []
            for arg in inputs:
                if isinstance(arg, Number):
                    args.append(arg)
                elif isinstance(arg, Series):
                    args.append(arg.view(ignore_nulls=True))
                else:
                    return NotImplemented

            if &quot;dtype&quot; in kwargs:
                dtype = kwargs.pop(&quot;dtype&quot;)
            else:
                dtype = self.dtype

            try:
                f = get_ffi_func(&quot;apply_ufunc_&lt;&gt;&quot;, dtype, self._s)
                if f is None:
                    return NotImplemented
                series = f(lambda out: ufunc(*args, out=out, **kwargs))
                return wrap_s(series)
            except TypeError:
                # some integer to float ufuncs do not work, try on f64
                s = self.cast(Float64)
                args[0] = s.view(ignore_nulls=True)
                f = get_ffi_func(&quot;apply_ufunc_&lt;&gt;&quot;, Float64, self._s)
                if f is None:
                    return NotImplemented
                series = f(lambda out: ufunc(*args, out=out, **kwargs))
                return wrap_s(series)

        else:
            return NotImplemented

    def to_numpy(
        self, *args: Any, zero_copy_only: bool = False, **kwargs: Any
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert this Series to numpy. This operation clones data but is completely safe.

        If you want a zero-copy view and know what you are doing, use `.view()`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_numpy()
        &gt;&gt;&gt; s
        [1 2 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'numpy.ndarray'&gt;

        Parameters
        ----------
        args
            args will be sent to pyarrow.Array.to_numpy.
        zero_copy_only
            If True, an exception will be raised if the conversion to a numpy
            array would require copying the underlying data (e.g. in presence
            of nulls, or for non-primitive types).
        kwargs
            kwargs will be sent to pyarrow.Array.to_numpy
        &quot;&quot;&quot;
        if _PYARROW_AVAILABLE:
            return self.to_arrow().to_numpy(
                *args, zero_copy_only=zero_copy_only, **kwargs
            )
        else:
            if not self.has_validity():
                return self.view(ignore_nulls=True)
            return self._s.to_numpy()

    def to_arrow(self) -&gt; &quot;pa.Array&quot;:
        &quot;&quot;&quot;
        Get the underlying Arrow Array. If the Series contains only a single chunk
        this operation is zero copy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_arrow()
        &gt;&gt;&gt; s
        [
        1,
        2,
        3
        ]
        &gt;&gt;&gt; type(s)
        &lt;class 'pyarrow.lib.Int64Array'&gt;

        &quot;&quot;&quot;
        return self._s.to_arrow()

    def set(self, filter: &quot;Series&quot;, value: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set masked values.

        Parameters
        ----------
        filter
            Boolean mask.
        value
            Value to replace the the masked values with.
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_with_mask_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(filter._s, value))

    def set_at_idx(
        self, idx: Union[&quot;Series&quot;, np.ndarray], value: Union[int, float]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set values at the index locations.

        Parameters
        ----------
        idx
            Integers representing the index locations.
        value
            replacement values.

        Returns
        -------
        New allocated Series
        &quot;&quot;&quot;

        # the set_at_idx function expects a np.array of dtype u32
        f = get_ffi_func(&quot;set_at_idx_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            raise ValueError(
                f&quot;could not find the FFI function needed to set at idx for series {self._s}&quot;
            )
        if isinstance(idx, Series):
            # make sure the dtype matches
            idx = idx.cast(UInt32)
            idx_array = idx.view()
        elif isinstance(idx, np.ndarray):
            if not idx.data.c_contiguous:
                idx_array = np.ascontiguousarray(idx, dtype=np.uint32)
            else:
                idx_array = idx
                if idx_array.dtype != np.uint32:
                    idx_array = np.array(idx_array, np.uint32)

        else:
            idx_array = np.array(idx, dtype=np.uint32)

        return wrap_s(f(idx_array, value))

    def clone(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cheap deep clones.
        &quot;&quot;&quot;
        return wrap_s(self._s.clone())

    def __copy__(self) -&gt; &quot;Series&quot;:  # type: ignore
        return self.clone()

    def __deepcopy__(self, memodict={}) -&gt; &quot;Series&quot;:  # type: ignore
        return self.clone()

    def fill_null(self, strategy: Union[str, int, &quot;pli.Expr&quot;]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Fill null values with a filling strategy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, None])
        &gt;&gt;&gt; s.fill_null('forward'))
        shape: (4,)
        Series: '' [i64]
        [
                1
                2
                3
                3
        ]
        &gt;&gt;&gt; s.fill_null('min'))
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                1
        ]

        Parameters
        ----------
        strategy

        Fill null strategy or a value
               * &quot;backward&quot;
               * &quot;forward&quot;
               * &quot;min&quot;
               * &quot;max&quot;
               * &quot;mean&quot;
               * &quot;one&quot;
               * &quot;zero&quot;
        &quot;&quot;&quot;
        if not isinstance(strategy, str):
            return self.to_frame().select(pli.col(self.name).fill_null(strategy))[
                self.name
            ]
        return wrap_s(self._s.fill_null(strategy))

    def floor(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_s(self._s.floor())

    def round(self, decimals: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.12345, 2.56789, 3.901234])
        &gt;&gt;&gt; s.round(2)
        shape: (3,)
        Series: 'a' [f64]
        [
                1.12
                2.57
                3.9
        ]

        Parameters
        ----------
        decimals
            number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_s(self._s.round(decimals))

    def dot(self, other: &quot;Series&quot;) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4.0, 5.0, 6.0])
        &gt;&gt;&gt; s.dot(s2)
        32.0

        Parameters
        ----------
        other
            Series to compute dot product with
        &quot;&quot;&quot;
        return self._s.dot(other._s)

    def mode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.mode()
        shape: (1,)
        Series: 'a' [i64]
        [
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.mode())

    def sin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.sin()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1
                1.2246467991473532e-16
        ]
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore

    def cos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.cos()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore

    def tan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.tan()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore

    def arcsin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arcsin()
        shape: (3,)
        Series: 'a' [f64]
        [
                1.5707963267948966
                0.0
                -1.5707963267948966e0
        ]
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore

    def arccos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arccos()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1.5707963267948966
                3.141592653589793
        ]
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore

    def arctan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arctan()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.7853981633974483
                0.0
                -7.853981633974483e-1
        ]
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore

    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a function over elements in this Series and return a new Series.

        If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.apply(lambda x: x + 10)
        shape: (3,)
        Series: 'a' [i64]
        [
                11
                12
                13
        ]

        Parameters
        ----------
        func
            function or lambda.
        return_dtype
            Output datatype. If none is given, the same datatype as this Series will be used.

        Returns
        -------
        Series
        &quot;&quot;&quot;
        if return_dtype is None:
            pl_return_dtype = None
        else:
            pl_return_dtype = py_type_to_dtype(return_dtype)
        return wrap_s(self._s.apply_lambda(func, pl_return_dtype))

    def shift(self, periods: int = 1) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.shift(periods=1)
        shape: (3,)
        Series: 'a' [i64]
        [
                null
                1
                2
        ]
        &gt;&gt;&gt; s.shift(periods=-1)
        shape: (3,)
        Series: 'a' [i64]
        [
                2
                3
                null
        ]

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_s(self._s.shift(periods))

    def shift_and_fill(
        self, periods: int, fill_value: Union[int, &quot;pli.Expr&quot;]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).shift_and_fill(periods, fill_value)  # type: ignore
        )[self.name]

    def zip_with(self, mask: &quot;Series&quot;, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.

        Parameters
        ----------
        mask
            Boolean Series.
        other
            Series of same type.

        Returns
        -------
        New Series
        &quot;&quot;&quot;
        return wrap_s(self._s.zip_with(mask._s, other._s))

    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_min(window_size=3)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                100
                200
                300
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_min(window_size, weights, min_periods, center))

    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_max(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                300
                400
                500
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_max(window_size, weights, min_periods, center))

    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_mean(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                150
                250
                350
                450
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_mean(window_size, weights, min_periods, center))

    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.rolling_sum(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                3
                5
                7
                9
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_sum(window_size, weights, min_periods, center))

    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_std(window_size, weights, min_periods, center))

    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_var(window_size, weights, min_periods, center))

    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.
        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum
        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function
        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;A&quot;, [1.0, 2.0, 9.0, 2.0, 13.0])
        &gt;&gt;&gt; s.rolling_apply(window_size=3, function=lambda s: s.std())
        shape: (5,)
        Series: 'A' [f64]
        [
            null
            null
            4.358898943540674
            4.041451884327381
            5.5677643628300215
        ]
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_apply(window_size, function)  # type: ignore
        )[self.name]

    def rolling_median(self, window_size: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_median(window_size)  # type: ignore
        )[self.name]

    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_quantile(window_size, quantile)  # type: ignore
        )[self.name]

    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_skew(window_size, bias)  # type: ignore
        )[self.name]

    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sample from this Series by setting either `n` or `frac`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.sample(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                5
        ]

        Parameters
        ----------
        n
            Number of samples &lt; self.len().
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            sample with replacement.
        &quot;&quot;&quot;
        if n is not None:
            return wrap_s(self._s.sample_n(n, with_replacement))
        return wrap_s(self._s.sample_frac(frac, with_replacement))

    def peak_max(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local maximum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.peak_max()
        shape: (5,)
        Series: '' [bool]
        [
                false
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_max())

    def peak_min(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local minimum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [4, 1, 3, 2, 5])
        &gt;&gt;&gt; s.peak_min()
        shape: (5,)
        Series: '' [bool]
        [
                false
                true
                false
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_min())

    def n_unique(self) -&gt; int:
        &quot;&quot;&quot;
        Count the number of unique values in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.n_unique()
        3

        &quot;&quot;&quot;
        return self._s.n_unique()

    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this Series to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._s.shrink_to_fit()
            return None
        else:
            series = self.clone()
            series._s.shrink_to_fit()
            return series

    @property
    def dt(self) -&gt; &quot;DateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return DateTimeNameSpace(self)

    @property
    def arr(self) -&gt; &quot;ListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all list related methods.
        &quot;&quot;&quot;
        return ListNameSpace(self)

    @property
    def str(self) -&gt; &quot;StringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return StringNameSpace(self)

    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `UInt64`

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.hash(k0=42)
        shape: (3,)
        Series: 'a' [u64]
        [
                18040498172617206516
                5352755651785478209
                3939059409923356085
        ]

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_s(self._s.hash(k0, k1, k2, k3))

    def reinterpret(self, signed: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_s(self._s.reinterpret(signed))

    def interpolate(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, None, None, 5])
        &gt;&gt;&gt; s.interpolate()
        shape: (5,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.interpolate())

    def abs(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_s(self._s.abs())

    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_s(self._s.rank(method))

    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_s(self._s.diff(n, null_behavior))

    def skew(self, bias: bool = True) -&gt; Optional[float]:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return self._s.skew(bias)

    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; Optional[float]:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self._s.kurtosis(fisher, bias)

    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).clip(min_val, max_val)  # type: ignore
        )[self.name]

    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; pl.Series([1, None, 2]).str_concat(&quot;-&quot;)[0]
        &quot;1-null-2&quot;

        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).str_concat(delimiter)  # type: ignore
        )[self.name]

    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reshape this Series to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Series
        &quot;&quot;&quot;
        return wrap_s(self._s.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-11"><a class="header" href="#constructor-11">Constructor</a></h2>
<pre><code class="language-python">Series(name: OptionalUnion[str, ArrayLike], 
    values: OptionalArrayLike, 
    dtype: OptionalTypeDataType, 
    strict: bool, 
    nan_to_null: bool,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        name: Optional[Union[str, ArrayLike]] = None,
        values: Optional[ArrayLike] = None,
        dtype: Optional[Type[DataType]] = None,
        strict: bool = True,
        nan_to_null: bool = False,
    ):

        # Handle case where values are passed as the first argument
        if name is not None and not isinstance(name, str):
            if values is None:
                values = name
                name = None
            else:
                raise ValueError(&quot;Series name must be a string.&quot;)

        # TODO: Remove if-statement below once Series name is allowed to be None
        if name is None:
            name = &quot;&quot;

        if values is None:
            self._s = sequence_to_pyseries(name, [], dtype=dtype)
        elif isinstance(values, Series):
            self._s = series_to_pyseries(name, values)
        elif _PYARROW_AVAILABLE and isinstance(values, pa.Array):
            self._s = arrow_to_pyseries(name, values)
        elif isinstance(values, np.ndarray):
            self._s = numpy_to_pyseries(name, values, strict, nan_to_null)
        elif isinstance(values, Sequence):
            self._s = sequence_to_pyseries(name, values, dtype=dtype, strict=strict)
        elif _PANDAS_AVAILABLE and isinstance(values, (pd.Series, pd.DatetimeIndex)):
            self._s = pandas_to_pyseries(name, values)
        else:
            raise ValueError(&quot;Series constructor not called properly.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-11"><a class="header" href="#methods-11">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesinner"><a class="header" href="#polarsinternalsseriesseriesinner"><code>polars.internals.series.Series.inner</code></a></h3>
<pre><code class="language-python">inner() -&gt; PySeries:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def inner(self) -&gt; &quot;PySeries&quot;:
        return self._s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessqrt"><a class="header" href="#polarsinternalsseriesseriessqrt"><code>polars.internals.series.Series.sqrt</code></a></h3>
<pre><code class="language-python">sqrt() -&gt; Series:
</code></pre>
<p>Compute the square root of the elements</p>
<p>Syntactic sugar for</p>
<blockquote>
<blockquote>
<blockquote>
<p>pl.Series([1, 2]) ** 0.5</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sqrt(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements

        Syntactic sugar for

        &gt;&gt;&gt; pl.Series([1, 2]) ** 0.5
        &quot;&quot;&quot;
        return self ** 0.5
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdrop_nulls"><a class="header" href="#polarsinternalsseriesseriesdrop_nulls"><code>polars.internals.series.Series.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls() -&gt; Series:
</code></pre>
<p>Create a new Series that copies data from this Series without null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a new Series that copies data from this Series without null values.
        &quot;&quot;&quot;
        return wrap_s(self._s.drop_nulls())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_frame"><a class="header" href="#polarsinternalsseriesseriesto_frame"><code>polars.internals.series.Series.to_frame</code></a></h3>
<pre><code class="language-python">to_frame() -&gt; pli.DataFrame:
</code></pre>
<p>Cast this Series to a DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
df = s.to_frame()
df
shape: (3, 1)
╭─────╮
│ a   │
│ --- │
│ i64 │
╞═════╡
│ 1   │
├╌╌╌╌╌┤
│ 2   │
├╌╌╌╌╌┤
│ 3   │
╰─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>type(df)
&lt;class 'polars.eager.frame.DataFrame'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_frame(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Cast this Series to a DataFrame.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; df = s.to_frame()
        &gt;&gt;&gt; df
        shape: (3, 1)
        ╭─────╮
        │ a   │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        ╰─────╯

        &gt;&gt;&gt; type(df)
        &lt;class 'polars.eager.frame.DataFrame'&gt;

        &quot;&quot;&quot;
        return pli.wrap_df(PyDataFrame([self._s]))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdtype"><a class="header" href="#polarsinternalsseriesseriesdtype"><code>polars.internals.series.Series.dtype</code></a></h3>
<pre><code class="language-python">dtype() -&gt; TypeDataType:
</code></pre>
<p>Get the data type of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.dtype
&lt;class 'polars.datatypes.Int64'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dtype(self) -&gt; Type[DataType]:
        &quot;&quot;&quot;
        Get the data type of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.dtype
        &lt;class 'polars.datatypes.Int64'&gt;

        &quot;&quot;&quot;
        return DTYPES[self._s.dtype()]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdescribe"><a class="header" href="#polarsinternalsseriesseriesdescribe"><code>polars.internals.series.Series.describe</code></a></h3>
<pre><code class="language-python">describe() -&gt; pli.DataFrame:
</code></pre>
<p>Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.</p>
<p><strong>Returns:</strong></p>
<p>Dictionary with summary statistics of a Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>series_num = pl.Series([1, 2, 3, 4, 5])
series_num.describe()
shape: (6, 2)
┌──────────────┬────────────────────┐
│ statistic    ┆ value              │
│ ---          ┆ ---                │
│ str          ┆ f64                │
╞══════════════╪════════════════════╡
│ &quot;min&quot;        ┆ 1                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;max&quot;        ┆ 5                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;null_count&quot; ┆ 0.0                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;mean&quot;       ┆ 3                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;std&quot;        ┆ 1.5811388300841898 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;count&quot;      ┆ 5                  │
└──────────────┴────────────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, None, &quot;b&quot;, &quot;c&quot;])
series_str.describe()
shape: (3, 2)
┌──────────────┬───────┐
│ statistic    ┆ value │
│ ---          ┆ ---   │
│ str          ┆ i64   │
╞══════════════╪═══════╡
│ &quot;unique&quot;     ┆ 4     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;null_count&quot; ┆ 1     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;count&quot;      ┆ 5     │
└──────────────┴───────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.

        Returns
        -------
        Dictionary with summary statistics of a Series.

        Examples
        --------
        &gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; series_num.describe()
        shape: (6, 2)
        ┌──────────────┬────────────────────┐
        │ statistic    ┆ value              │
        │ ---          ┆ ---                │
        │ str          ┆ f64                │
        ╞══════════════╪════════════════════╡
        │ &quot;min&quot;        ┆ 1                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;max&quot;        ┆ 5                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 0.0                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;mean&quot;       ┆ 3                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;std&quot;        ┆ 1.5811388300841898 │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5                  │
        └──────────────┴────────────────────┘

        &gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, None, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; series_str.describe()
        shape: (3, 2)
        ┌──────────────┬───────┐
        │ statistic    ┆ value │
        │ ---          ┆ ---   │
        │ str          ┆ i64   │
        ╞══════════════╪═══════╡
        │ &quot;unique&quot;     ┆ 4     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 1     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5     │
        └──────────────┴───────┘

        &quot;&quot;&quot;
        stats: Dict[str, Union[Optional[float], int, str]]

        if self.len() == 0:
            raise ValueError(&quot;Series must contain at least one value&quot;)
        elif self.is_numeric():
            s = self.cast(Float64)
            stats = {
                &quot;min&quot;: s.min(),
                &quot;max&quot;: s.max(),
                &quot;null_count&quot;: s.null_count(),
                &quot;mean&quot;: s.mean(),
                &quot;std&quot;: s.std(),
                &quot;count&quot;: s.len(),
            }
        elif self.is_boolean():
            stats = {
                &quot;sum&quot;: self.sum(),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_utf8():
            stats = {
                &quot;unique&quot;: len(self.unique()),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_datetime():
            # we coerce all to string, because a polars column
            # only has a single dtype and dates: datetime and count: int don't match
            stats = {
                &quot;min&quot;: str(self.dt.min()),
                &quot;max&quot;: str(self.dt.max()),
                &quot;null_count&quot;: str(self.null_count()),
                &quot;count&quot;: str(self.len()),
            }
        else:
            raise TypeError(&quot;This type is not supported&quot;)

        return pli.DataFrame(
            {&quot;statistic&quot;: list(stats.keys()), &quot;value&quot;: list(stats.values())}
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessum"><a class="header" href="#polarsinternalsseriesseriessum"><code>polars.internals.series.Series.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Union[int, float]:
</code></pre>
<p>Reduce this Series to the sum value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.sum()
6</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the sum value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.sum()
        6

        &quot;&quot;&quot;
        return self._s.sum()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmean"><a class="header" href="#polarsinternalsseriesseriesmean"><code>polars.internals.series.Series.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Union[int, float]:
</code></pre>
<p>Reduce this Series to the mean value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.mean()
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the mean value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.mean()
        2.0

        &quot;&quot;&quot;
        return self._s.mean()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmin"><a class="header" href="#polarsinternalsseriesseriesmin"><code>polars.internals.series.Series.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Union[int, float]:
</code></pre>
<p>Get the minimal value in this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.min()
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the minimal value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        1

        &quot;&quot;&quot;
        return self._s.min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmax"><a class="header" href="#polarsinternalsseriesseriesmax"><code>polars.internals.series.Series.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Union[int, float]:
</code></pre>
<p>Get the maximum value in this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.min()
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the maximum value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        3

        &quot;&quot;&quot;
        return self._s.max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesstd"><a class="header" href="#polarsinternalsseriesseriesstd"><code>polars.internals.series.Series.std</code></a></h3>
<pre><code class="language-python">std(ddof: int) -&gt; Optionalfloat:
</code></pre>
<p>Get the standard deviation of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ddof</code>]: “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
where N represents the number of elements.
By default ddof is 1.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.std()
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get the standard deviation of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.std()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.std(self.drop_nulls().view(), ddof=ddof)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesvar"><a class="header" href="#polarsinternalsseriesseriesvar"><code>polars.internals.series.Series.var</code></a></h3>
<pre><code class="language-python">var(ddof: int) -&gt; Optionalfloat:
</code></pre>
<p>Get variance of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ddof</code>]: “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
where N represents the number of elements.
By default ddof is 1.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.var()
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get variance of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.var()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.var(self.drop_nulls().view(), ddof=ddof)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmedian"><a class="header" href="#polarsinternalsseriesseriesmedian"><code>polars.internals.series.Series.median</code></a></h3>
<pre><code class="language-python">median() -&gt; float:
</code></pre>
<p>Get the median of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.median()
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; float:
        &quot;&quot;&quot;
        Get the median of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.median()
        2.0

        &quot;&quot;&quot;
        return self._s.median()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesquantile"><a class="header" href="#polarsinternalsseriesseriesquantile"><code>polars.internals.series.Series.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; float:
</code></pre>
<p>Get the quantile value of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.quantile(0.5)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; float:
        &quot;&quot;&quot;
        Get the quantile value of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.quantile(0.5)
        2

        &quot;&quot;&quot;
        return self._s.quantile(quantile)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_dummies"><a class="header" href="#polarsinternalsseriesseriesto_dummies"><code>polars.internals.series.Series.to_dummies</code></a></h3>
<pre><code class="language-python">to_dummies() -&gt; pli.DataFrame:
</code></pre>
<p>Get dummy variables.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_dummies()
shape: (3, 3)
╭─────┬─────┬─────╮
│ a_1 ┆ a_2 ┆ a_3 │
│ --- ┆ --- ┆ --- │
│ u8  ┆ u8  ┆ u8  │
╞═════╪═════╪═════╡
│ 1   ┆ 0   ┆ 0   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 0   ┆ 1   ┆ 0   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 0   ┆ 0   ┆ 1   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dummies(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Get dummy variables.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_dummies()
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a_1 ┆ a_2 ┆ a_3 │
        │ --- ┆ --- ┆ --- │
        │ u8  ┆ u8  ┆ u8  │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 0   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 1   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 0   ┆ 1   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.to_dummies())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesvalue_counts"><a class="header" href="#polarsinternalsseriesseriesvalue_counts"><code>polars.internals.series.Series.value_counts</code></a></h3>
<pre><code class="language-python">value_counts() -&gt; pli.DataFrame:
</code></pre>
<p>Count the unique values in a Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.value_counts()
shape: (3, 2)
╭─────┬────────╮
│ a   ┆ counts │
│ --- ┆ ---    │
│ i64 ┆ u32    │
╞═════╪════════╡
│ 2   ┆ 2      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1   ┆ 1      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3   ┆ 1      │
╰─────┴────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def value_counts(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Count the unique values in a Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.value_counts()
        shape: (3, 2)
        ╭─────┬────────╮
        │ a   ┆ counts │
        │ --- ┆ ---    │
        │ i64 ┆ u32    │
        ╞═════╪════════╡
        │ 2   ┆ 2      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 1   ┆ 1      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 3   ┆ 1      │
        ╰─────┴────────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.value_counts())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesname"><a class="header" href="#polarsinternalsseriesseriesname"><code>polars.internals.series.Series.name</code></a></h3>
<pre><code class="language-python">name() -&gt; str:
</code></pre>
<p>Get the name of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def name(self) -&gt; str:
        &quot;&quot;&quot;
        Get the name of this Series.
        &quot;&quot;&quot;
        return self._s.name()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesalias"><a class="header" href="#polarsinternalsseriesseriesalias"><code>polars.internals.series.Series.alias</code></a></h3>
<pre><code class="language-python">alias(name: str) -&gt; Series:
</code></pre>
<p>Rename the Series</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name</li>
</ul>
<p><strong>Returns:</strong></p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def alias(self, name: str) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Rename the Series

        Parameters
        ----------
        name
            New name

        Returns
        -------

        &quot;&quot;&quot;
        s = self.clone()
        s._s.rename(name)
        return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrename"><a class="header" href="#polarsinternalsseriesseriesrename"><code>polars.internals.series.Series.rename</code></a></h3>
<pre><code class="language-python">rename(name: str, in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Rename this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name.</li>
<li>[<code>in_place</code>]: Modify the Series in-place.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.rename('b')
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rename(self, name: str, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Rename this Series.

        Parameters
        ----------
        name
            New name.
        in_place
            Modify the Series in-place.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.rename('b')
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.rename(name)
            return None
        else:
            return self.alias(name)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieschunk_lengths"><a class="header" href="#polarsinternalsseriesserieschunk_lengths"><code>polars.internals.series.Series.chunk_lengths</code></a></h3>
<pre><code class="language-python">chunk_lengths() -&gt; tp.List[int]:
</code></pre>
<p>Get the length of each individual chunk.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def chunk_lengths(self) -&gt; tp.List[int]:
        &quot;&quot;&quot;
        Get the length of each individual chunk.
        &quot;&quot;&quot;
        return self._s.chunk_lengths()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesn_chunks"><a class="header" href="#polarsinternalsseriesseriesn_chunks"><code>polars.internals.series.Series.n_chunks</code></a></h3>
<pre><code class="language-python">n_chunks() -&gt; int:
</code></pre>
<p>Get the number of chunks that this Series contains.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get the number of chunks that this Series contains.
        &quot;&quot;&quot;
        return self._s.n_chunks()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescumsum"><a class="header" href="#polarsinternalsseriesseriescumsum"><code>polars.internals.series.Series.cumsum</code></a></h3>
<pre><code class="language-python">cumsum(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative sum computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cumsum()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  6
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumsum(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumsum()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                3
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumsum(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescummin"><a class="header" href="#polarsinternalsseriesseriescummin"><code>polars.internals.series.Series.cummin</code></a></h3>
<pre><code class="language-python">cummin(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative min computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cummin()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  1
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummin(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummin()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                1
                1
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummin(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescummax"><a class="header" href="#polarsinternalsseriesseriescummax"><code>polars.internals.series.Series.cummax</code></a></h3>
<pre><code class="language-python">cummax(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative max computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cummax()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummax(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummax()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummax(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescumprod"><a class="header" href="#polarsinternalsseriesseriescumprod"><code>polars.internals.series.Series.cumprod</code></a></h3>
<pre><code class="language-python">cumprod(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative product computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cumprod()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  6
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumprod(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumprod()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumprod(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieslimit"><a class="header" href="#polarsinternalsseriesserieslimit"><code>polars.internals.series.Series.limit</code></a></h3>
<pre><code class="language-python">limit(num_elements: int) -&gt; Series:
</code></pre>
<p>Take n elements from this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>num_elements</code>]: Amount of elements to take.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.limit(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def limit(self, num_elements: int = 10) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take n elements from this Series.

        Parameters
        ----------
        num_elements
            Amount of elements to take.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.limit(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.limit(num_elements))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesslice"><a class="header" href="#polarsinternalsseriesseriesslice"><code>polars.internals.series.Series.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; Series:
</code></pre>
<p>Get a slice of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Offset index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.slice(1, 2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a slice of this Series.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.slice(1, 2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesappend"><a class="header" href="#polarsinternalsseriesseriesappend"><code>polars.internals.series.Series.append</code></a></h3>
<pre><code class="language-python">append(other: Series) -&gt; None:
</code></pre>
<p>Append a Series to this one.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to append.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
s.append(s2)
shape: (6,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def append(self, other: &quot;Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Append a Series to this one.

        Parameters
        ----------
        other
            Series to append.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.append(s2)
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
                6
        ]

        &quot;&quot;&quot;
        self._s.append(other._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesfilter"><a class="header" href="#polarsinternalsseriesseriesfilter"><code>polars.internals.series.Series.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Union[Series, list]) -&gt; Series:
</code></pre>
<p>Filter elements by a boolean mask.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean mask.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
mask = pl.Series(&quot;&quot;, [True, False, True])
s.filter(mask)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: Union[&quot;Series&quot;, list]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Filter elements by a boolean mask.

        Parameters
        ----------
        predicate
            Boolean mask.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; mask = pl.Series(&quot;&quot;, [True, False, True])
        &gt;&gt;&gt; s.filter(mask)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        if isinstance(predicate, list):
            predicate = Series(&quot;&quot;, predicate)
        return wrap_s(self._s.filter(predicate._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieshead"><a class="header" href="#polarsinternalsseriesserieshead"><code>polars.internals.series.Series.head</code></a></h3>
<pre><code class="language-python">head(length: Optionalint) -&gt; Series:
</code></pre>
<p>Get first N elements as Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the head.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.head(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get first N elements as Series.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.head(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.head(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestail"><a class="header" href="#polarsinternalsseriesseriestail"><code>polars.internals.series.Series.tail</code></a></h3>
<pre><code class="language-python">tail(length: Optionalint) -&gt; Series:
</code></pre>
<p>Get last N elements as Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the tail.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.tail(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get last N elements as Series.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.tail(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.tail(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestake_every"><a class="header" href="#polarsinternalsseriesseriestake_every"><code>polars.internals.series.Series.take_every</code></a></h3>
<pre><code class="language-python">take_every(n: int) -&gt; Series:
</code></pre>
<p>Take every nth value in the Series and return as new Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
s.take_every(2)
shape: (2,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take_every(self, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as new Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take_every(2)
        shape: (2,)
        Series: '' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.take_every(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessort"><a class="header" href="#polarsinternalsseriesseriessort"><code>polars.internals.series.Series.sort</code></a></h3>
<pre><code class="language-python">sort(in_place: bool, reverse: bool) -&gt; Series:
</code></pre>
<p>Sort this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>in_place</code>]: Sort in place.</li>
<li>[<code>reverse</code>]: Reverse sort.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 3, 4, 2])
s.sort()
shape: (4,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]
&gt;&gt;&gt; s.sort(reverse=True)
shape: (4,)
Series: 'a' [i64]
[</p>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, in_place: bool = False, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sort this Series.

        Parameters
        ----------
        in_place
            Sort in place.
        reverse
            Reverse sort.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 3, 4, 2])
        &gt;&gt;&gt; s.sort()
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
        ]
        &gt;&gt;&gt; s.sort(reverse=True)
        shape: (4,)
        Series: 'a' [i64]
        [
                4
                3
                2
                1
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.sort_in_place(reverse)
            return self
        else:
            return wrap_s(self._s.sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesargsort"><a class="header" href="#polarsinternalsseriesseriesargsort"><code>polars.internals.series.Series.argsort</code></a></h3>
<pre><code class="language-python">argsort(reverse: bool) -&gt; Series:
</code></pre>
<p>Index location of the sorted variant of this Series.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>indexes</code>]: Indexes that can be used to sort this array.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [5, 3, 4, 1, 2])
s.argsort()
shape: (4,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>0
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def argsort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [5, 3, 4, 1, 2])
        &gt;&gt;&gt; s.argsort()
        shape: (4,)
        Series: 'a' [i64]
        [
            3
            4
            1
            2
            0
        ]
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_sort"><a class="header" href="#polarsinternalsseriesseriesarg_sort"><code>polars.internals.series.Series.arg_sort</code></a></h3>
<pre><code class="language-python">arg_sort(reverse: bool) -&gt; Series:
</code></pre>
<p>..deprecate::</p>
<p>Index location of the sorted variant of this Series.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>indexes</code>]: Indexes that can be used to sort this array.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_sort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        ..deprecate::

        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_unique"><a class="header" href="#polarsinternalsseriesseriesarg_unique"><code>polars.internals.series.Series.arg_unique</code></a></h3>
<pre><code class="language-python">arg_unique() -&gt; Series:
</code></pre>
<p>Get unique index as Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique index as Series.
        &quot;&quot;&quot;
        return wrap_s(self._s.arg_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_min"><a class="header" href="#polarsinternalsseriesseriesarg_min"><code>polars.internals.series.Series.arg_min</code></a></h3>
<pre><code class="language-python">arg_min() -&gt; Optionalint:
</code></pre>
<p>Get the index of the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_min(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return self._s.arg_min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_max"><a class="header" href="#polarsinternalsseriesseriesarg_max"><code>polars.internals.series.Series.arg_max</code></a></h3>
<pre><code class="language-python">arg_max() -&gt; Optionalint:
</code></pre>
<p>Get the index of the maximal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_max(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return self._s.arg_max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesunique"><a class="header" href="#polarsinternalsseriesseriesunique"><code>polars.internals.series.Series.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Series:
</code></pre>
<p>Get unique elements in series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.unique()
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique elements in series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.unique()
        shape: (3,)
        Series: 'a' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestake"><a class="header" href="#polarsinternalsseriesseriestake"><code>polars.internals.series.Series.take</code></a></h3>
<pre><code class="language-python">take(indices: Union[np.ndarray, tp.List[int]],) -&gt; Series:
</code></pre>
<p>Take values by index.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>indices</code>]: Index location used for selection.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
s.take([1, 3])
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take(self, indices: Union[np.ndarray, tp.List[int]]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        indices
            Index location used for selection.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take([1, 3])
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                4
        ]

        &quot;&quot;&quot;
        if isinstance(indices, list):
            indices = np.array(indices)
        return Series._from_pyseries(self._s.take(indices))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesnull_count"><a class="header" href="#polarsinternalsseriesseriesnull_count"><code>polars.internals.series.Series.null_count</code></a></h3>
<pre><code class="language-python">null_count() -&gt; int:
</code></pre>
<p>Count the null values in this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def null_count(self) -&gt; int:
        &quot;&quot;&quot;
        Count the null values in this Series.
        &quot;&quot;&quot;
        return self._s.null_count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieshas_validity"><a class="header" href="#polarsinternalsseriesserieshas_validity"><code>polars.internals.series.Series.has_validity</code></a></h3>
<pre><code class="language-python">has_validity() -&gt; bool:
</code></pre>
<p>Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.
Use this to swiftly assert a Series does not have null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def has_validity(self) -&gt; bool:
        &quot;&quot;&quot;
        Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.
        Use this to swiftly assert a Series does not have null values.
        &quot;&quot;&quot;
        return self._s.has_validity()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_null"><a class="header" href="#polarsinternalsseriesseriesis_null"><code>polars.internals.series.Series.is_null</code></a></h3>
<pre><code class="language-python">is_null() -&gt; Series:
</code></pre>
<p>Get mask of null values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
s.is_null()
shape: (4,)
Series: 'is_null' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_null()
        shape: (4,)
        Series: 'is_null' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_not_null"><a class="header" href="#polarsinternalsseriesseriesis_not_null"><code>polars.internals.series.Series.is_not_null</code></a></h3>
<pre><code class="language-python">is_not_null() -&gt; Series:
</code></pre>
<p>Get mask of non null values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
s.is_not_null()
shape: (4,)
Series: 'is_not_null' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of non null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_not_null()
        shape: (4,)
        Series: 'is_not_null' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_finite"><a class="header" href="#polarsinternalsseriesseriesis_finite"><code>polars.internals.series.Series.is_finite</code></a></h3>
<pre><code class="language-python">is_finite() -&gt; Series:
</code></pre>
<p>Get mask of finite values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
s.is_finite()
shape: (3,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  false
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_finite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of finite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_finite()
        shape: (3,)
        Series: 'a' [bool]
        [
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_finite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_infinite"><a class="header" href="#polarsinternalsseriesseriesis_infinite"><code>polars.internals.series.Series.is_infinite</code></a></h3>
<pre><code class="language-python">is_infinite() -&gt; Series:
</code></pre>
<p>Get mask of infinite values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
s.is_infinite()
shape: (3,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  true
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_infinite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of infinite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_infinite()
        shape: (3,)
        Series: 'a' [bool]
        [
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_infinite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_nan"><a class="header" href="#polarsinternalsseriesseriesis_nan"><code>polars.internals.series.Series.is_nan</code></a></h3>
<pre><code class="language-python">is_nan() -&gt; Series:
</code></pre>
<p>Get mask of NaN values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
s.is_nan()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of NaN values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_not_nan"><a class="header" href="#polarsinternalsseriesseriesis_not_nan"><code>polars.internals.series.Series.is_not_nan</code></a></h3>
<pre><code class="language-python">is_not_nan() -&gt; Series:
</code></pre>
<p>Get negated mask of NaN values if Series dtype is_not Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
s.is_not_nan()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get negated mask of NaN values if Series dtype is_not Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_not_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_in"><a class="header" href="#polarsinternalsseriesseriesis_in"><code>polars.internals.series.Series.is_in</code></a></h3>
<pre><code class="language-python">is_in(other: Union[Series, tp.List]) -&gt; Series:
</code></pre>
<p>Check if elements of this Series are in the right Series, or List values of the right Series.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [2, 4])
s2.is_in(s)
shape: (2,)
Series: 'b' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_in(self, other: Union[&quot;Series&quot;, tp.List]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [2, 4])
        &gt;&gt;&gt; s2.is_in(s)
        shape: (2,)
        Series: 'b' [bool]
        [
                true
                false
        ]

        &quot;&quot;&quot;
        if type(other) is list:
            other = Series(&quot;&quot;, other)
        return wrap_s(self._s.is_in(other._s))  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_true"><a class="header" href="#polarsinternalsseriesseriesarg_true"><code>polars.internals.series.Series.arg_true</code></a></h3>
<pre><code class="language-python">arg_true() -&gt; Series:
</code></pre>
<p>Get index values where Boolean Series evaluate True.</p>
<p><strong>Returns:</strong></p>
<p>UInt32 Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_true(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get index values where Boolean Series evaluate True.

        Returns
        -------
        UInt32 Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.arg_true())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_unique"><a class="header" href="#polarsinternalsseriesseriesis_unique"><code>polars.internals.series.Series.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; Series:
</code></pre>
<p>Get mask of all unique values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.is_unique()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all unique values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_unique()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_first"><a class="header" href="#polarsinternalsseriesseriesis_first"><code>polars.internals.series.Series.is_first</code></a></h3>
<pre><code class="language-python">is_first() -&gt; Series:
</code></pre>
<p>Get a mask of the first unique value.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_first(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_duplicated"><a class="header" href="#polarsinternalsseriesseriesis_duplicated"><code>polars.internals.series.Series.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; Series:
</code></pre>
<p>Get mask of all duplicated values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.is_duplicated()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all duplicated values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_duplicated()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesexplode"><a class="header" href="#polarsinternalsseriesseriesexplode"><code>polars.internals.series.Series.explode</code></a></h3>
<pre><code class="language-python">explode() -&gt; Series:
</code></pre>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series('a', [[1, 2], [3, 4], [9, 10]])
s.explode()
shape: (6,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>]</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series('a', [[1, 2], [3, 4], [9, 10]])
        &gt;&gt;&gt; s.explode()
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                9
                10
        ]

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_s(self._s.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesseries_equal"><a class="header" href="#polarsinternalsseriesseriesseries_equal"><code>polars.internals.series.Series.series_equal</code></a></h3>
<pre><code class="language-python">series_equal(other: Series, 
    null_equal: bool, 
    strict: bool,) -&gt; bool:
</code></pre>
<p>Check if series is equal with another Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to compare with.</li>
<li>[<code>null_equal</code>]: Consider null values as equal.</li>
<li>[<code>strict</code>]: Don't allow different numerical dtypes, e.g. comparing <code>pl.UInt32</code> with a <code>pl.Int64</code> will return <code>False</code>.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
s.series_equal(s))
True
s.series_equal(s2))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def series_equal(
        self, other: &quot;Series&quot;, null_equal: bool = False, strict: bool = False
    ) -&gt; bool:
        &quot;&quot;&quot;
        Check if series is equal with another Series.

        Parameters
        ----------
        other
            Series to compare with.
        null_equal
            Consider null values as equal.
        strict
            Don't allow different numerical dtypes, e.g. comparing `pl.UInt32` with a `pl.Int64` will return `False`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.series_equal(s))
        True
        &gt;&gt;&gt; s.series_equal(s2))
        False

        &quot;&quot;&quot;
        return self._s.series_equal(other._s, null_equal, strict)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieslen"><a class="header" href="#polarsinternalsseriesserieslen"><code>polars.internals.series.Series.len</code></a></h3>
<pre><code class="language-python">len() -&gt; int:
</code></pre>
<p>Length of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.len()
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def len(self) -&gt; int:
        &quot;&quot;&quot;
        Length of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.len()
        3

        &quot;&quot;&quot;
        return self._s.len()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshape"><a class="header" href="#polarsinternalsseriesseriesshape"><code>polars.internals.series.Series.shape</code></a></h3>
<pre><code class="language-python">shape() -&gt; Tupleint:
</code></pre>
<p>Shape of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shape(self) -&gt; Tuple[int]:
        &quot;&quot;&quot;
        Shape of this Series.
        &quot;&quot;&quot;
        return (self._s.len(),)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescast"><a class="header" href="#polarsinternalsseriesseriescast"><code>polars.internals.series.Series.cast</code></a></h3>
<pre><code class="language-python">cast(dtype: Union[TypeDataType, Typeint, Typefloat, Typestr, Typebool], 
    strict: bool,) -&gt; Series:
</code></pre>
<p>Cast between data types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dtype</code>]: DataType to cast to</li>
<li>[<code>strict</code>]: Throw an error if a cast could not be done for instance due to an overflow</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [True, False, True])
shape: (3,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>true
]
&gt;&gt;&gt; s.cast(pl.UInt32)
shape: (3,)
Series: 'a' [u32]
[</li>
<li>1
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cast(
        self,
        dtype: Union[Type[DataType], Type[int], Type[float], Type[str], Type[bool]],
        strict: bool = True,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        shape: (3,)
        Series: 'a' [bool]
        [
            true
            false
            true
        ]
        &gt;&gt;&gt; s.cast(pl.UInt32)
        shape: (3,)
        Series: 'a' [u32]
        [
            1
            0
            1
        ]

        &quot;&quot;&quot;
        pl_dtype = py_type_to_dtype(dtype)
        return wrap_s(self._s.cast(str(pl_dtype), strict))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_list"><a class="header" href="#polarsinternalsseriesseriesto_list"><code>polars.internals.series.Series.to_list</code></a></h3>
<pre><code class="language-python">to_list(use_pyarrow: bool) -&gt; tp.List[OptionalAny]:
</code></pre>
<p>Convert this Series to a Python List. This operation clones data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>use_pyarrow</code>]: Use pyarrow for the conversion.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_list()
[1, 2, 3]
type(s)
&lt;class 'list'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_list(self, use_pyarrow: bool = False) -&gt; tp.List[Optional[Any]]:
        &quot;&quot;&quot;
        Convert this Series to a Python List. This operation clones data.

        Parameters
        ----------
        use_pyarrow
            Use pyarrow for the conversion.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_list()
        [1, 2, 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'list'&gt;

        &quot;&quot;&quot;
        if use_pyarrow:
            return self.to_arrow().to_pylist()
        return self._s.to_list()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrechunk"><a class="header" href="#polarsinternalsseriesseriesrechunk"><code>polars.internals.series.Series.rechunk</code></a></h3>
<pre><code class="language-python">rechunk(in_place: bool) -&gt; Series:
</code></pre>
<p>Create a single chunk of memory for this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>in_place</code>]: In place or not.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rechunk(self, in_place: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a single chunk of memory for this Series.

        Parameters
        ----------
        in_place
            In place or not.
        &quot;&quot;&quot;
        opt_s = self._s.rechunk(in_place)
        if in_place:
            return self
        else:
            return wrap_s(opt_s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_numeric"><a class="header" href="#polarsinternalsseriesseriesis_numeric"><code>polars.internals.series.Series.is_numeric</code></a></h3>
<pre><code class="language-python">is_numeric() -&gt; bool:
</code></pre>
<p>Check if this Series datatype is numeric.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.is_numeric()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_numeric(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is numeric.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.is_numeric()
        True

        &quot;&quot;&quot;
        return self.dtype in (
            Int8,
            Int16,
            Int32,
            Int64,
            UInt8,
            UInt16,
            UInt32,
            UInt64,
            Float32,
            Float64,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_datetime"><a class="header" href="#polarsinternalsseriesseriesis_datetime"><code>polars.internals.series.Series.is_datetime</code></a></h3>
<pre><code class="language-python">is_datetime() -&gt; bool:
</code></pre>
<p>Check if this Series datatype is a datetime.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series([date(2021, 1, 1), date(2021, 1, 2), date(2021, 1, 3)])
s.is_datetime()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_datetime(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is a datetime.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series([date(2021, 1, 1), date(2021, 1, 2), date(2021, 1, 3)])
        &gt;&gt;&gt; s.is_datetime()
        True

        &quot;&quot;&quot;
        return self.dtype in (Date, Datetime)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_float"><a class="header" href="#polarsinternalsseriesseriesis_float"><code>polars.internals.series.Series.is_float</code></a></h3>
<pre><code class="language-python">is_float() -&gt; bool:
</code></pre>
<p>Check if this Series has floating point numbers.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0])
s.is_float()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_float(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series has floating point numbers.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0])
        &gt;&gt;&gt; s.is_float()
        True

        &quot;&quot;&quot;
        return self.dtype in (Float32, Float64)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_boolean"><a class="header" href="#polarsinternalsseriesseriesis_boolean"><code>polars.internals.series.Series.is_boolean</code></a></h3>
<pre><code class="language-python">is_boolean() -&gt; bool:
</code></pre>
<p>Check if this Series is a Boolean.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [True, False, True])
s.is_boolean()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_boolean(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series is a Boolean.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        &gt;&gt;&gt; s.is_boolean()
        True

        &quot;&quot;&quot;
        return self.dtype is Boolean
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_utf8"><a class="header" href="#polarsinternalsseriesseriesis_utf8"><code>polars.internals.series.Series.is_utf8</code></a></h3>
<pre><code class="language-python">is_utf8() -&gt; bool:
</code></pre>
<p>Checks if this Series datatype is a Utf8.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
s.is_utf8()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_utf8(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks if this Series datatype is a Utf8.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; s.is_utf8()
        True
        &quot;&quot;&quot;
        return self.dtype is Utf8
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesview"><a class="header" href="#polarsinternalsseriesseriesview"><code>polars.internals.series.Series.view</code></a></h3>
<pre><code class="language-python">view(ignore_nulls: bool) -&gt; np.ndarray:
</code></pre>
<p>Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
missing values. Don't use this unless you know what you are doing.</p>
<p>.. warning::</p>
<pre><code>This function can lead to undefined behavior in the following cases:

&gt;&gt;&gt; # returns a view to a piece of memory that is already dropped.
&gt;&gt;&gt; pl.Series([1, 3, 5]).sort().view()

&gt;&gt;&gt; # Sums invalid data that is missing.
&gt;&gt;&gt; pl.Series([1, 2, None]).view().sum()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def view(self, ignore_nulls: bool = False) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
        missing values. Don't use this unless you know what you are doing.

        .. warning::

            This function can lead to undefined behavior in the following cases:

            &gt;&gt;&gt; # returns a view to a piece of memory that is already dropped.
            &gt;&gt;&gt; pl.Series([1, 3, 5]).sort().view()

            &gt;&gt;&gt; # Sums invalid data that is missing.
            &gt;&gt;&gt; pl.Series([1, 2, None]).view().sum()

        &quot;&quot;&quot;
        if not ignore_nulls:
            assert not self.has_validity()

        ptr_type = dtype_to_ctype(self.dtype)
        ptr = self._s.as_single_ptr()
        array = _ptr_to_numpy(ptr, self.len(), ptr_type)
        array.setflags(write=False)
        return array
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_numpy"><a class="header" href="#polarsinternalsseriesseriesto_numpy"><code>polars.internals.series.Series.to_numpy</code></a></h3>
<pre><code class="language-python">to_numpy(*args, **kwargs) -&gt; np.ndarray:
</code></pre>
<p>Convert this Series to numpy. This operation clones data but is completely safe.</p>
<p>If you want a zero-copy view and know what you are doing, use <code>.view()</code>.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_numpy()
s
[1 2 3]
type(s)
&lt;class 'numpy.ndarray'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>args</code>]: args will be sent to pyarrow.Array.to_numpy.</li>
<li>[<code>zero_copy_only</code>]: If True, an exception will be raised if the conversion to a numpy
array would require copying the underlying data (e.g. in presence
of nulls, or for non-primitive types).</li>
<li>[<code>kwargs</code>]: kwargs will be sent to pyarrow.Array.to_numpy</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_numpy(
        self, *args: Any, zero_copy_only: bool = False, **kwargs: Any
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert this Series to numpy. This operation clones data but is completely safe.

        If you want a zero-copy view and know what you are doing, use `.view()`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_numpy()
        &gt;&gt;&gt; s
        [1 2 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'numpy.ndarray'&gt;

        Parameters
        ----------
        args
            args will be sent to pyarrow.Array.to_numpy.
        zero_copy_only
            If True, an exception will be raised if the conversion to a numpy
            array would require copying the underlying data (e.g. in presence
            of nulls, or for non-primitive types).
        kwargs
            kwargs will be sent to pyarrow.Array.to_numpy
        &quot;&quot;&quot;
        if _PYARROW_AVAILABLE:
            return self.to_arrow().to_numpy(
                *args, zero_copy_only=zero_copy_only, **kwargs
            )
        else:
            if not self.has_validity():
                return self.view(ignore_nulls=True)
            return self._s.to_numpy()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_arrow"><a class="header" href="#polarsinternalsseriesseriesto_arrow"><code>polars.internals.series.Series.to_arrow</code></a></h3>
<pre><code class="language-python">to_arrow() -&gt; pa.Array:
</code></pre>
<p>Get the underlying Arrow Array. If the Series contains only a single chunk
this operation is zero copy.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_arrow()
s
[
1,
2,
3
]
type(s)
&lt;class 'pyarrow.lib.Int64Array'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_arrow(self) -&gt; &quot;pa.Array&quot;:
        &quot;&quot;&quot;
        Get the underlying Arrow Array. If the Series contains only a single chunk
        this operation is zero copy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_arrow()
        &gt;&gt;&gt; s
        [
        1,
        2,
        3
        ]
        &gt;&gt;&gt; type(s)
        &lt;class 'pyarrow.lib.Int64Array'&gt;

        &quot;&quot;&quot;
        return self._s.to_arrow()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesset"><a class="header" href="#polarsinternalsseriesseriesset"><code>polars.internals.series.Series.set</code></a></h3>
<pre><code class="language-python">set(filter: Series, 
    value: Union[int, float],) -&gt; Series:
</code></pre>
<p>Set masked values.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>filter</code>]: Boolean mask.</li>
<li>[<code>value</code>]: Value to replace the the masked values with.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set(self, filter: &quot;Series&quot;, value: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set masked values.

        Parameters
        ----------
        filter
            Boolean mask.
        value
            Value to replace the the masked values with.
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_with_mask_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(filter._s, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesset_at_idx"><a class="header" href="#polarsinternalsseriesseriesset_at_idx"><code>polars.internals.series.Series.set_at_idx</code></a></h3>
<pre><code class="language-python">set_at_idx(idx: Union[Series, np.ndarray], 
    value: Union[int, float],) -&gt; Series:
</code></pre>
<p>Set values at the index locations.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>idx</code>]: Integers representing the index locations.</li>
<li>[<code>value</code>]: replacement values.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>New allocated Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_at_idx(
        self, idx: Union[&quot;Series&quot;, np.ndarray], value: Union[int, float]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set values at the index locations.

        Parameters
        ----------
        idx
            Integers representing the index locations.
        value
            replacement values.

        Returns
        -------
        New allocated Series
        &quot;&quot;&quot;

        # the set_at_idx function expects a np.array of dtype u32
        f = get_ffi_func(&quot;set_at_idx_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            raise ValueError(
                f&quot;could not find the FFI function needed to set at idx for series {self._s}&quot;
            )
        if isinstance(idx, Series):
            # make sure the dtype matches
            idx = idx.cast(UInt32)
            idx_array = idx.view()
        elif isinstance(idx, np.ndarray):
            if not idx.data.c_contiguous:
                idx_array = np.ascontiguousarray(idx, dtype=np.uint32)
            else:
                idx_array = idx
                if idx_array.dtype != np.uint32:
                    idx_array = np.array(idx_array, np.uint32)

        else:
            idx_array = np.array(idx, dtype=np.uint32)

        return wrap_s(f(idx_array, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesclone"><a class="header" href="#polarsinternalsseriesseriesclone"><code>polars.internals.series.Series.clone</code></a></h3>
<pre><code class="language-python">clone() -&gt; Series:
</code></pre>
<p>Cheap deep clones.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clone(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cheap deep clones.
        &quot;&quot;&quot;
        return wrap_s(self._s.clone())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesfill_null"><a class="header" href="#polarsinternalsseriesseriesfill_null"><code>polars.internals.series.Series.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(strategy: Union[str, int, pli.Expr],) -&gt; Series:
</code></pre>
<p>Fill null values with a filling strategy.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, None])
s.fill_null('forward'))
shape: (4,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]
&gt;&gt;&gt; s.fill_null('min'))
shape: (4,)
Series: 'a' [i64]
[</p>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<p>strategy</p>
<ul>
<li>
<pre><code> * &quot;forward&quot;
 * &quot;min&quot;
 * &quot;max&quot;
 * &quot;mean&quot;
 * &quot;one&quot;
 * &quot;zero&quot;
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, strategy: Union[str, int, &quot;pli.Expr&quot;]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Fill null values with a filling strategy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, None])
        &gt;&gt;&gt; s.fill_null('forward'))
        shape: (4,)
        Series: '' [i64]
        [
                1
                2
                3
                3
        ]
        &gt;&gt;&gt; s.fill_null('min'))
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                1
        ]

        Parameters
        ----------
        strategy

        Fill null strategy or a value
               * &quot;backward&quot;
               * &quot;forward&quot;
               * &quot;min&quot;
               * &quot;max&quot;
               * &quot;mean&quot;
               * &quot;one&quot;
               * &quot;zero&quot;
        &quot;&quot;&quot;
        if not isinstance(strategy, str):
            return self.to_frame().select(pli.col(self.name).fill_null(strategy))[
                self.name
            ]
        return wrap_s(self._s.fill_null(strategy))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesfloor"><a class="header" href="#polarsinternalsseriesseriesfloor"><code>polars.internals.series.Series.floor</code></a></h3>
<pre><code class="language-python">floor() -&gt; Series:
</code></pre>
<p>Floor underlying floating point array to the lowest integers smaller or equal to the float value.</p>
<p>Only works on floating point Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def floor(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_s(self._s.floor())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesround"><a class="header" href="#polarsinternalsseriesseriesround"><code>polars.internals.series.Series.round</code></a></h3>
<pre><code class="language-python">round(decimals: int) -&gt; Series:
</code></pre>
<p>Round underlying floating point data by <code>decimals</code> digits.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.12345, 2.56789, 3.901234])
s.round(2)
shape: (3,)
Series: 'a' [f64]
[
1.12
2.57
3.9
]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>decimals</code>]: number of decimals to round by.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, decimals: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.12345, 2.56789, 3.901234])
        &gt;&gt;&gt; s.round(2)
        shape: (3,)
        Series: 'a' [f64]
        [
                1.12
                2.57
                3.9
        ]

        Parameters
        ----------
        decimals
            number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_s(self._s.round(decimals))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdot"><a class="header" href="#polarsinternalsseriesseriesdot"><code>polars.internals.series.Series.dot</code></a></h3>
<pre><code class="language-python">dot(other: Series) -&gt; Optionalfloat:
</code></pre>
<p>Compute the dot/inner product between two Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [4.0, 5.0, 6.0])
s.dot(s2)
32.0</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to compute dot product with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dot(self, other: &quot;Series&quot;) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4.0, 5.0, 6.0])
        &gt;&gt;&gt; s.dot(s2)
        32.0

        Parameters
        ----------
        other
            Series to compute dot product with
        &quot;&quot;&quot;
        return self._s.dot(other._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmode"><a class="header" href="#polarsinternalsseriesseriesmode"><code>polars.internals.series.Series.mode</code></a></h3>
<pre><code class="language-python">mode() -&gt; Series:
</code></pre>
<p>Compute the most occurring value(s). Can return multiple Values</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.mode()
shape: (1,)
Series: 'a' [i64]
[
2
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.mode()
        shape: (1,)
        Series: 'a' [i64]
        [
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.mode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessin"><a class="header" href="#polarsinternalsseriesseriessin"><code>polars.internals.series.Series.sin</code></a></h3>
<pre><code class="language-python">sin() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric sine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
s.sin()
shape: (3,)
Series: 'a' [f64]
[
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.sin()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1
                1.2246467991473532e-16
        ]
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescos"><a class="header" href="#polarsinternalsseriesseriescos"><code>polars.internals.series.Series.cos</code></a></h3>
<pre><code class="language-python">cos() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric cosine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
s.cos()
shape: (3,)
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  -1e0
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.cos()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestan"><a class="header" href="#polarsinternalsseriesseriestan"><code>polars.internals.series.Series.tan</code></a></h3>
<pre><code class="language-python">tan() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric tangent.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
s.tan()
shape: (3,)
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  -1e0
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.tan()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarcsin"><a class="header" href="#polarsinternalsseriesseriesarcsin"><code>polars.internals.series.Series.arcsin</code></a></h3>
<pre><code class="language-python">arcsin() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric Inverse sine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
s.arcsin()
shape: (3,)
Series: 'a' [f64]
[
1.5707963267948966
0.0
-1.5707963267948966e0
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arcsin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arcsin()
        shape: (3,)
        Series: 'a' [f64]
        [
                1.5707963267948966
                0.0
                -1.5707963267948966e0
        ]
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarccos"><a class="header" href="#polarsinternalsseriesseriesarccos"><code>polars.internals.series.Series.arccos</code></a></h3>
<pre><code class="language-python">arccos() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric Inverse cosine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
s.arccos()
shape: (3,)
Series: 'a' [f64]
[
0.0
1.5707963267948966
3.141592653589793
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arccos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arccos()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1.5707963267948966
                3.141592653589793
        ]
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarctan"><a class="header" href="#polarsinternalsseriesseriesarctan"><code>polars.internals.series.Series.arctan</code></a></h3>
<pre><code class="language-python">arctan() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric Inverse tangent.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
s.arctan()
shape: (3,)
Series: 'a' [f64]
[
0.7853981633974483
0.0
-7.853981633974483e-1
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arctan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arctan()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.7853981633974483
                0.0
                -7.853981633974483e-1
        ]
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesapply"><a class="header" href="#polarsinternalsseriesseriesapply"><code>polars.internals.series.Series.apply</code></a></h3>
<pre><code class="language-python">apply(func: Callable[[Any], Any], 
    return_dtype: OptionalTypeDataType,) -&gt; Series:
</code></pre>
<p>Apply a function over elements in this Series and return a new Series.</p>
<p>If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.apply(lambda x: x + 10)
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  13
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>func</code>]: function or lambda.</li>
<li>[<code>return_dtype</code>]: Output datatype. If none is given, the same datatype as this Series will be used.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a function over elements in this Series and return a new Series.

        If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.apply(lambda x: x + 10)
        shape: (3,)
        Series: 'a' [i64]
        [
                11
                12
                13
        ]

        Parameters
        ----------
        func
            function or lambda.
        return_dtype
            Output datatype. If none is given, the same datatype as this Series will be used.

        Returns
        -------
        Series
        &quot;&quot;&quot;
        if return_dtype is None:
            pl_return_dtype = None
        else:
            pl_return_dtype = py_type_to_dtype(return_dtype)
        return wrap_s(self._s.apply_lambda(func, pl_return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshift"><a class="header" href="#polarsinternalsseriesseriesshift"><code>polars.internals.series.Series.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; Series:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.shift(periods=1)
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  2
</code></pre>
</li>
</ul>
<p>]
&gt;&gt;&gt; s.shift(periods=-1)
shape: (3,)
Series: 'a' [i64]
[</p>
<ul>
<li>
<pre><code>  null
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int = 1) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.shift(periods=1)
        shape: (3,)
        Series: 'a' [i64]
        [
                null
                1
                2
        ]
        &gt;&gt;&gt; s.shift(periods=-1)
        shape: (3,)
        Series: 'a' [i64]
        [
                2
                3
                null
        ]

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_s(self._s.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshift_and_fill"><a class="header" href="#polarsinternalsseriesseriesshift_and_fill"><code>polars.internals.series.Series.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, 
    fill_value: Union[int, pli.Expr],) -&gt; Series:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: Fill None values with the result of this expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(
        self, periods: int, fill_value: Union[int, &quot;pli.Expr&quot;]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).shift_and_fill(periods, fill_value)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieszip_with"><a class="header" href="#polarsinternalsseriesserieszip_with"><code>polars.internals.series.Series.zip_with</code></a></h3>
<pre><code class="language-python">zip_with(mask: Series, other: Series) -&gt; Series:
</code></pre>
<p>Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mask</code>]: Boolean Series.</li>
<li>[<code>other</code>]: Series of same type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>New Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def zip_with(self, mask: &quot;Series&quot;, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.

        Parameters
        ----------
        mask
            Boolean Series.
        other
            Series of same type.

        Returns
        -------
        New Series
        &quot;&quot;&quot;
        return wrap_s(self._s.zip_with(mask._s, other._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_min"><a class="header" href="#polarsinternalsseriesseriesrolling_min"><code>polars.internals.series.Series.rolling_min</code></a></h3>
<pre><code class="language-python">rolling_min(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>apply a rolling min (moving min) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
s.rolling_min(window_size=3)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  300
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_min(window_size=3)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                100
                200
                300
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_min(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_max"><a class="header" href="#polarsinternalsseriesseriesrolling_max"><code>polars.internals.series.Series.rolling_max</code></a></h3>
<pre><code class="language-python">rolling_max(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Apply a rolling max (moving max) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
s.rolling_max(window_size=2)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  500
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_max(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                300
                400
                500
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_max(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_mean"><a class="header" href="#polarsinternalsseriesseriesrolling_mean"><code>polars.internals.series.Series.rolling_mean</code></a></h3>
<pre><code class="language-python">rolling_mean(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Apply a rolling mean (moving mean) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
s.rolling_mean(window_size=2)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  450
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_mean(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                150
                250
                350
                450
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_mean(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_sum"><a class="header" href="#polarsinternalsseriesseriesrolling_sum"><code>polars.internals.series.Series.rolling_sum</code></a></h3>
<pre><code class="language-python">rolling_sum(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Apply a rolling sum (moving sum) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s.rolling_sum(window_size=2)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  9
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.rolling_sum(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                3
                5
                7
                9
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_sum(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_std"><a class="header" href="#polarsinternalsseriesseriesrolling_std"><code>polars.internals.series.Series.rolling_std</code></a></h3>
<pre><code class="language-python">rolling_std(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Compute a rolling std dev</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_std(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_var"><a class="header" href="#polarsinternalsseriesseriesrolling_var"><code>polars.internals.series.Series.rolling_var</code></a></h3>
<pre><code class="language-python">rolling_var(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Compute a rolling variance.</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_var(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_apply"><a class="header" href="#polarsinternalsseriesseriesrolling_apply"><code>polars.internals.series.Series.rolling_apply</code></a></h3>
<pre><code class="language-python">rolling_apply(window_size: int, 
    function: Callable[[pli.Series], Any],) -&gt; pli.Series:
</code></pre>
<p>Allows a custom rolling window function.
Prefer the specific rolling window functions over this one, as they are faster.
Prefer:
* rolling_min
* rolling_max
* rolling_mean
* rolling_sum
<strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>function</code>]: Aggregation function
<strong>Examples:</strong></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;A&quot;, [1.0, 2.0, 9.0, 2.0, 13.0])
s.rolling_apply(window_size=3, function=lambda s: s.std())
shape: (5,)
Series: 'A' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>4.358898943540674
4.041451884327381
5.5677643628300215
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.
        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum
        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function
        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;A&quot;, [1.0, 2.0, 9.0, 2.0, 13.0])
        &gt;&gt;&gt; s.rolling_apply(window_size=3, function=lambda s: s.std())
        shape: (5,)
        Series: 'A' [f64]
        [
            null
            null
            4.358898943540674
            4.041451884327381
            5.5677643628300215
        ]
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_apply(window_size, function)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_median"><a class="header" href="#polarsinternalsseriesseriesrolling_median"><code>polars.internals.series.Series.rolling_median</code></a></h3>
<pre><code class="language-python">rolling_median(window_size: int) -&gt; Series:
</code></pre>
<p>Compute a rolling median</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_median(self, window_size: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_median(window_size)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_quantile"><a class="header" href="#polarsinternalsseriesseriesrolling_quantile"><code>polars.internals.series.Series.rolling_quantile</code></a></h3>
<pre><code class="language-python">rolling_quantile(window_size: int, 
    quantile: float,) -&gt; Series:
</code></pre>
<p>Compute a rolling quantile</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>quantile</code>]: quantile to compute</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_quantile(window_size, quantile)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_skew"><a class="header" href="#polarsinternalsseriesseriesrolling_skew"><code>polars.internals.series.Series.rolling_skew</code></a></h3>
<pre><code class="language-python">rolling_skew(window_size: int, bias: bool) -&gt; Series:
</code></pre>
<p>Compute a rolling skew</p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>bias</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_skew(window_size, bias)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessample"><a class="header" href="#polarsinternalsseriesseriessample"><code>polars.internals.series.Series.sample</code></a></h3>
<pre><code class="language-python">sample(n: Optionalint, 
    frac: Optionalfloat, 
    with_replacement: bool,) -&gt; Series:
</code></pre>
<p>Sample from this Series by setting either <code>n</code> or <code>frac</code>.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s.sample(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of samples &lt; self.len().</li>
<li>[<code>frac</code>]: Fraction between 0.0 and 1.0 .</li>
<li>[<code>with_replacement</code>]: sample with replacement.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sample from this Series by setting either `n` or `frac`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.sample(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                5
        ]

        Parameters
        ----------
        n
            Number of samples &lt; self.len().
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            sample with replacement.
        &quot;&quot;&quot;
        if n is not None:
            return wrap_s(self._s.sample_n(n, with_replacement))
        return wrap_s(self._s.sample_frac(frac, with_replacement))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriespeak_max"><a class="header" href="#polarsinternalsseriesseriespeak_max"><code>polars.internals.series.Series.peak_max</code></a></h3>
<pre><code class="language-python">peak_max() -&gt; Series:
</code></pre>
<p>Get a boolean mask of the local maximum peaks.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s.peak_max()
shape: (5,)
Series: '' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  true
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def peak_max(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local maximum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.peak_max()
        shape: (5,)
        Series: '' [bool]
        [
                false
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriespeak_min"><a class="header" href="#polarsinternalsseriesseriespeak_min"><code>polars.internals.series.Series.peak_min</code></a></h3>
<pre><code class="language-python">peak_min() -&gt; Series:
</code></pre>
<p>Get a boolean mask of the local minimum peaks.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [4, 1, 3, 2, 5])
s.peak_min()
shape: (5,)
Series: '' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  false
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def peak_min(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local minimum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [4, 1, 3, 2, 5])
        &gt;&gt;&gt; s.peak_min()
        shape: (5,)
        Series: '' [bool]
        [
                false
                true
                false
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesn_unique"><a class="header" href="#polarsinternalsseriesseriesn_unique"><code>polars.internals.series.Series.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; int:
</code></pre>
<p>Count the number of unique values in this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.n_unique()
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; int:
        &quot;&quot;&quot;
        Count the number of unique values in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.n_unique()
        3

        &quot;&quot;&quot;
        return self._s.n_unique()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshrink_to_fit"><a class="header" href="#polarsinternalsseriesseriesshrink_to_fit"><code>polars.internals.series.Series.shrink_to_fit</code></a></h3>
<pre><code class="language-python">shrink_to_fit(in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Shrink memory usage of this Series to fit the exact capacity needed to hold the data.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this Series to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._s.shrink_to_fit()
            return None
        else:
            series = self.clone()
            series._s.shrink_to_fit()
            return series
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdt"><a class="header" href="#polarsinternalsseriesseriesdt"><code>polars.internals.series.Series.dt</code></a></h3>
<pre><code class="language-python">dt() -&gt; DateTimeNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dt(self) -&gt; &quot;DateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return DateTimeNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarr"><a class="header" href="#polarsinternalsseriesseriesarr"><code>polars.internals.series.Series.arr</code></a></h3>
<pre><code class="language-python">arr() -&gt; ListNameSpace:
</code></pre>
<p>Create an object namespace of all list related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arr(self) -&gt; &quot;ListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all list related methods.
        &quot;&quot;&quot;
        return ListNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesstr"><a class="header" href="#polarsinternalsseriesseriesstr"><code>polars.internals.series.Series.str</code></a></h3>
<pre><code class="language-python">str() -&gt; StringNameSpace:
</code></pre>
<p>Create an object namespace of all string related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str(self) -&gt; &quot;StringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return StringNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieshash"><a class="header" href="#polarsinternalsseriesserieshash"><code>polars.internals.series.Series.hash</code></a></h3>
<pre><code class="language-python">hash(k0: int, k1: int, k2: int, k3: int) -&gt; pli.Series:
</code></pre>
<p>Hash the Series.</p>
<p>The hash value is of type <code>UInt64</code></p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.hash(k0=42)
shape: (3,)
Series: 'a' [u64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3939059409923356085
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `UInt64`

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.hash(k0=42)
        shape: (3,)
        Series: 'a' [u64]
        [
                18040498172617206516
                5352755651785478209
                3939059409923356085
        ]

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_s(self._s.hash(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesreinterpret"><a class="header" href="#polarsinternalsseriesseriesreinterpret"><code>polars.internals.series.Series.reinterpret</code></a></h3>
<pre><code class="language-python">reinterpret(signed: bool) -&gt; Series:
</code></pre>
<p>Reinterpret the underlying bits as a signed/unsigned integer.
This operation is only allowed for 64bit integers. For lower bits integers,
you can safely use that cast operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>signed</code>]: True -&gt; pl.Int64
False -&gt; pl.UInt64</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reinterpret(self, signed: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_s(self._s.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesinterpolate"><a class="header" href="#polarsinternalsseriesseriesinterpolate"><code>polars.internals.series.Series.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; Series:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, None, None, 5])
s.interpolate()
shape: (5,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  5
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, None, None, 5])
        &gt;&gt;&gt; s.interpolate()
        shape: (5,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.interpolate())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesabs"><a class="header" href="#polarsinternalsseriesseriesabs"><code>polars.internals.series.Series.abs</code></a></h3>
<pre><code class="language-python">abs() -&gt; Series:
</code></pre>
<p>Take absolute values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def abs(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_s(self._s.abs())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrank"><a class="header" href="#polarsinternalsseriesseriesrank"><code>polars.internals.series.Series.rank</code></a></h3>
<pre><code class="language-python">rank(method: str) -&gt; Series:
</code></pre>
<p>Assign ranks to data, dealing with ties appropriately.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>method</code>]: {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
The method used to assign ranks to tied elements.
The following methods are available (default is 'average'):
* 'average': The average of the ranks that would have been assigned to
all the tied values is assigned to each value.
* 'min': The minimum of the ranks that would have been assigned to all
the tied values is assigned to each value.  (This is also
referred to as &quot;competition&quot; ranking.)
* 'max': The maximum of the ranks that would have been assigned to all
the tied values is assigned to each value.
* 'dense': Like 'min', but the rank of the next highest element is</li>
<li>
<pre><code>* 'ordinal': All values are given a distinct rank, corresponding to
  the order that the values occur in `a`.
* 'random': Like 'ordinal', but the rank for ties is not dependent
  on the order that the values occur in `a`.
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_s(self._s.rank(method))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdiff"><a class="header" href="#polarsinternalsseriesseriesdiff"><code>polars.internals.series.Series.diff</code></a></h3>
<pre><code class="language-python">diff(n: int, null_behavior: str) -&gt; Series:
</code></pre>
<p>Calculate the n-th discrete difference.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: number of slots to shift</li>
<li>[<code>null_behavior</code>]: {'ignore', 'drop'}</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_s(self._s.diff(n, null_behavior))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesskew"><a class="header" href="#polarsinternalsseriesseriesskew"><code>polars.internals.series.Series.skew</code></a></h3>
<pre><code class="language-python">skew(bias: bool) -&gt; Optionalfloat:
</code></pre>
<p>Compute the sample skewness of a data set.
For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function <code>skewtest</code> can be used to determine if the skewness value
is close enough to zero, statistically speaking.</p>
<p>See scipy.stats for more information.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p><strong>Notes:</strong></p>
<p>The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.
.. math::
g_1=\frac{m_3}{m_2^{3/2}}
where
.. math::
m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
is the biased sample :math:<code>i\texttt{th}</code> central moment, and
:math:<code>\bar{x}</code> is
the sample mean.  If <code>bias</code> is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.
.. math::
G_1=\frac{k_3}{k_2^{3/2}}=
\frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def skew(self, bias: bool = True) -&gt; Optional[float]:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return self._s.skew(bias)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieskurtosis"><a class="header" href="#polarsinternalsseriesserieskurtosis"><code>polars.internals.series.Series.kurtosis</code></a></h3>
<pre><code class="language-python">kurtosis(fisher: bool, bias: bool) -&gt; Optionalfloat:
</code></pre>
<p>Compute the kurtosis (Fisher or Pearson) of a dataset.
Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.
If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators</p>
<p>See scipy.stats for more information</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fisher</code> [<code>bool, optional</code>]: If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
Pearson's definition is used (normal ==&gt; 3.0).</li>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; Optional[float]:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self._s.kurtosis(fisher, bias)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesclip"><a class="header" href="#polarsinternalsseriesseriesclip"><code>polars.internals.series.Series.clip</code></a></h3>
<pre><code class="language-python">clip(min_val: Union[int, float], 
    max_val: Union[int, float],) -&gt; Series:
</code></pre>
<p>Clip (limit) the values in an array.</p>
<p><strong>Parameters:</strong></p>
<p>min_val, max_val
Minimum and maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).clip(min_val, max_val)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesstr_concat"><a class="header" href="#polarsinternalsseriesseriesstr_concat"><code>polars.internals.series.Series.str_concat</code></a></h3>
<pre><code class="language-python">str_concat(delimiter: str) -&gt; Series:
</code></pre>
<p>Vertically concat the values in the Series to a single string value.</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Utf8</p>
<p>Examples
&gt;&gt;&gt; pl.Series([1, None, 2]).str_concat(&quot;-&quot;)[0]
&quot;1-null-2&quot;</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; pl.Series([1, None, 2]).str_concat(&quot;-&quot;)[0]
        &quot;1-null-2&quot;

        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).str_concat(delimiter)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesreshape"><a class="header" href="#polarsinternalsseriesseriesreshape"><code>polars.internals.series.Series.reshape</code></a></h3>
<pre><code class="language-python">reshape(dims: tp.Tuple[int, ]) -&gt; Series:
</code></pre>
<p>Reshape this Series to a flat series, shape: (len,)
or a List series, shape: (rows, cols)</p>
<p>if a -1 is used in any of the dimensions, that dimension is inferred.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dims</code>]: Tuple of the dimension sizes</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reshape this Series to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Series
        &quot;&quot;&quot;
        return wrap_s(self._s.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsseriesstringnamespace"><a class="header" href="#polarsinternalsseriesstringnamespace"><code>polars.internals.series.StringNameSpace</code></a></h1>
<p>Series.str namespace.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacestrptime"><code>strptime()</code></a>: Parse a Series of dtype Utf8 to a Date/Datetime Series.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacelengths"><code>lengths()</code></a>: Get length of the string values in the Series.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacecontains"><code>contains()</code></a>: Check if strings in Series contain regex pattern.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacejson_path_match"><code>json_path_match()</code></a>: Extract the first match of json string with provided JSONPath expression.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespaceextract"><code>extract()</code></a>: Extract the target capture group from provided patterns.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacereplace"><code>replace()</code></a>: Replace first regex match with a string value.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacereplace_all"><code>replace_all()</code></a>: Replace all regex matches with a string value.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespaceto_lowercase"><code>to_lowercase()</code></a>: Modify the strings to their lowercase equivalent.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespaceto_uppercase"><code>to_uppercase()</code></a>: Modify the strings to their uppercase equivalent.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacerstrip"><code>rstrip()</code></a>: Remove trailing whitespace.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespacelstrip"><code>lstrip()</code></a>: Remove leading whitespace.</li>
<li><a href="polars/internals/series/StringNameSpace.html#polarsinternalsseriesstringnamespaceslice"><code>slice()</code></a>: Create subslices of the string values of a Utf8 Series.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class StringNameSpace:
    &quot;&quot;&quot;
    Series.str namespace.
    &quot;&quot;&quot;

    def __init__(self, series: &quot;Series&quot;):
        self._s = series._s

    def strptime(self, datatype: Type[DataType], fmt: Optional[str] = None) -&gt; Series:
        &quot;&quot;&quot;
        Parse a Series of dtype Utf8 to a Date/Datetime Series.

        Parameters
        ----------
        datatype
            Date or Datetime.
        fmt
            formatting syntax. [Read more](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html)

        Returns
        -------
        A Date/ Datetime Series
        &quot;&quot;&quot;
        if datatype == Date:
            return wrap_s(self._s.str_parse_date(fmt))
        if datatype == Datetime:
            return wrap_s(self._s.str_parse_datetime(fmt))
        raise NotImplementedError

    def lengths(self) -&gt; Series:
        &quot;&quot;&quot;
        Get length of the string values in the Series.

        Returns
        -------
        Series[u32]
        &quot;&quot;&quot;
        return wrap_s(self._s.str_lengths())

    def contains(self, pattern: str) -&gt; Series:
        &quot;&quot;&quot;
        Check if strings in Series contain regex pattern.

        Parameters
        ----------
        pattern
            A valid regex pattern.

        Returns
        -------
        Boolean mask
        &quot;&quot;&quot;
        return wrap_s(self._s.str_contains(pattern))

    def json_path_match(self, json_path: str) -&gt; Series:
        &quot;&quot;&quot;
        Extract the first match of json string with provided JSONPath expression.
        Throw errors if encounter invalid json strings.
        All return value will be casted to Utf8 regardless of the original value.
        Documentation on JSONPath standard: https://goessner.net/articles/JsonPath/

        Parameters
        ----------
        json_path
            A valid JSON path query string

        Returns
        -------
        Utf8 array. Contain null if original value is null or the json_path return nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        'json_val':['{&quot;a&quot;:&quot;1&quot;}',None,'{&quot;a&quot;:2}', '{&quot;a&quot;:2.1}', '{&quot;a&quot;:true}'
        })
        &gt;&gt;&gt; df.select(pl.col('json_val').str.json_path_match('$.a')
        shape: (5,)
        Series: 'json_val' [str]
        [
            &quot;1&quot;
            null
            &quot;2&quot;
            &quot;2.1&quot;
            &quot;true&quot;
        ]
        &quot;&quot;&quot;
        return wrap_s(self._s.str_json_path_match(json_path))

    def extract(self, pattern: str, group_index: int = 1) -&gt; Series:
        r&quot;&quot;&quot;
        Extract the target capture group from provided patterns.

        Parameters
        ----------
        pattern
            A valid regex pattern
        group_index
            Index of the targeted capture group.
            Group 0 mean the whole pattern, first group begin at index 1
            Default to the first capture group

        Returns
        -------
        Utf8 array. Contain null if original value is null or regex capture nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        ...         'a': [
        ...             'http://vote.com/ballon_dor?candidate=messi&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidat=jorginho&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars'
        ...         ]})
        &gt;&gt;&gt; df.select([
        ...             pl.col('a').str.extract(r'candidate=(\w+)', 1)
        ...         ])
        shape: (3, 1)
        ┌─────────┐
        │ a       │
        │ ---     │
        │ str     │
        ╞═════════╡
        │ messi   │
        ├╌╌╌╌╌╌╌╌╌┤
        │ null    │
        ├╌╌╌╌╌╌╌╌╌┤
        │ ronaldo │
        └─────────┘
        &quot;&quot;&quot;
        return wrap_s(self._s.str_extract(pattern, group_index))

    def replace(self, pattern: str, value: str) -&gt; Series:
        &quot;&quot;&quot;
        Replace first regex match with a string value.

        Parameters
        ----------
        pattern
            A valid regex pattern.
        value
            Substring to replace.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_replace(pattern, value))

    def replace_all(self, pattern: str, value: str) -&gt; Series:
        &quot;&quot;&quot;
        Replace all regex matches with a string value.

        Parameters
        ----------
        pattern
            A valid regex pattern.
        value
            Substring to replace.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_replace_all(pattern, value))

    def to_lowercase(self) -&gt; Series:
        &quot;&quot;&quot;
        Modify the strings to their lowercase equivalent.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_to_lowercase())

    def to_uppercase(self) -&gt; Series:
        &quot;&quot;&quot;
        Modify the strings to their uppercase equivalent.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_to_uppercase())

    def rstrip(self) -&gt; Series:
        &quot;&quot;&quot;
        Remove trailing whitespace.
        &quot;&quot;&quot;
        return self.replace(r&quot;[ \t]+$&quot;, &quot;&quot;)

    def lstrip(self) -&gt; Series:
        &quot;&quot;&quot;
        Remove leading whitespace.
        &quot;&quot;&quot;
        return self.replace(r&quot;^\s*&quot;, &quot;&quot;)

    def slice(self, start: int, length: Optional[int] = None) -&gt; Series:
        &quot;&quot;&quot;
        Create subslices of the string values of a Utf8 Series.

        Parameters
        ----------
        start
            Start of the slice (negative indexing may be used).
        length
            Optional length of the slice.

        Returns
        -------
        Series of Utf8 type
        &quot;&quot;&quot;
        return wrap_s(self._s.str_slice(start, length))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-12"><a class="header" href="#constructor-12">Constructor</a></h2>
<pre><code class="language-python">StringNameSpace(series: Series)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, series: &quot;Series&quot;):
        self._s = series._s
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-12"><a class="header" href="#methods-12">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacestrptime"><a class="header" href="#polarsinternalsseriesstringnamespacestrptime"><code>polars.internals.series.StringNameSpace.strptime</code></a></h3>
<pre><code class="language-python">strptime(datatype: TypeDataType, 
    fmt: Optionalstr,) -&gt; Series:
</code></pre>
<p>Parse a Series of dtype Utf8 to a Date/Datetime Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>datatype</code>]: Date or Datetime.</li>
<li>[<code>fmt</code>]: formatting syntax. <a href="https:/docs.rs/chrono/0.4.19/chrono/format/strftime/index.html">Read more</a></li>
</ul>
<p><strong>Returns:</strong></p>
<p>A Date/ Datetime Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def strptime(self, datatype: Type[DataType], fmt: Optional[str] = None) -&gt; Series:
        &quot;&quot;&quot;
        Parse a Series of dtype Utf8 to a Date/Datetime Series.

        Parameters
        ----------
        datatype
            Date or Datetime.
        fmt
            formatting syntax. [Read more](https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html)

        Returns
        -------
        A Date/ Datetime Series
        &quot;&quot;&quot;
        if datatype == Date:
            return wrap_s(self._s.str_parse_date(fmt))
        if datatype == Datetime:
            return wrap_s(self._s.str_parse_datetime(fmt))
        raise NotImplementedError
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacelengths"><a class="header" href="#polarsinternalsseriesstringnamespacelengths"><code>polars.internals.series.StringNameSpace.lengths</code></a></h3>
<pre><code class="language-python">lengths() -&gt; Series:
</code></pre>
<p>Get length of the string values in the Series.</p>
<p><strong>Returns:</strong></p>
<p>Series[u32]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lengths(self) -&gt; Series:
        &quot;&quot;&quot;
        Get length of the string values in the Series.

        Returns
        -------
        Series[u32]
        &quot;&quot;&quot;
        return wrap_s(self._s.str_lengths())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacecontains"><a class="header" href="#polarsinternalsseriesstringnamespacecontains"><code>polars.internals.series.StringNameSpace.contains</code></a></h3>
<pre><code class="language-python">contains(pattern: str) -&gt; Series:
</code></pre>
<p>Check if strings in Series contain regex pattern.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: A valid regex pattern.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Boolean mask</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def contains(self, pattern: str) -&gt; Series:
        &quot;&quot;&quot;
        Check if strings in Series contain regex pattern.

        Parameters
        ----------
        pattern
            A valid regex pattern.

        Returns
        -------
        Boolean mask
        &quot;&quot;&quot;
        return wrap_s(self._s.str_contains(pattern))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacejson_path_match"><a class="header" href="#polarsinternalsseriesstringnamespacejson_path_match"><code>polars.internals.series.StringNameSpace.json_path_match</code></a></h3>
<pre><code class="language-python">json_path_match(json_path: str) -&gt; Series:
</code></pre>
<p>Extract the first match of json string with provided JSONPath expression.
Throw errors if encounter invalid json strings.
All return value will be casted to Utf8 regardless of the original value.
Documentation on JSONPath standard: https:/goessner.net/articles/JsonPath/</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>json_path</code>]: A valid JSON path query string</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Utf8 array. Contain null if original value is null or the json_path return nothing.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
'json_val':['{&quot;a&quot;:&quot;1&quot;}',None,'{&quot;a&quot;:2}', '{&quot;a&quot;:2.1}', '{&quot;a&quot;:true}'
})
df.select(pl.col('json_val').str.json_path_match('$.a')
shape: (5,)
Series: 'json_val' [str]
[
&quot;1&quot;</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>&quot;true&quot;
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def json_path_match(self, json_path: str) -&gt; Series:
        &quot;&quot;&quot;
        Extract the first match of json string with provided JSONPath expression.
        Throw errors if encounter invalid json strings.
        All return value will be casted to Utf8 regardless of the original value.
        Documentation on JSONPath standard: https://goessner.net/articles/JsonPath/

        Parameters
        ----------
        json_path
            A valid JSON path query string

        Returns
        -------
        Utf8 array. Contain null if original value is null or the json_path return nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        'json_val':['{&quot;a&quot;:&quot;1&quot;}',None,'{&quot;a&quot;:2}', '{&quot;a&quot;:2.1}', '{&quot;a&quot;:true}'
        })
        &gt;&gt;&gt; df.select(pl.col('json_val').str.json_path_match('$.a')
        shape: (5,)
        Series: 'json_val' [str]
        [
            &quot;1&quot;
            null
            &quot;2&quot;
            &quot;2.1&quot;
            &quot;true&quot;
        ]
        &quot;&quot;&quot;
        return wrap_s(self._s.str_json_path_match(json_path))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespaceextract"><a class="header" href="#polarsinternalsseriesstringnamespaceextract"><code>polars.internals.series.StringNameSpace.extract</code></a></h3>
<pre><code class="language-python">extract(pattern: str, group_index: int) -&gt; Series:
</code></pre>
<p>Extract the target capture group from provided patterns.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: A valid regex pattern</li>
<li>[<code>group_index</code>]: Index of the targeted capture group.
Group 0 mean the whole pattern, first group begin at index 1
Default to the first capture group</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Utf8 array. Contain null if original value is null or regex capture nothing.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
...         'a': [
...             'http:/vote.com/ballon_dor?candidate=messi&amp;ref=polars',
...             'http:/vote.com/ballon_dor?candidat=jorginho&amp;ref=polars',
...             'http:/vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars'
...         ]})
df.select([
...             pl.col('a').str.extract(r'candidate=(\w+)', 1)
...         ])
shape: (3, 1)
┌─────────┐
│ a       │
│ ---     │
│ str     │
╞═════════╡
│ messi   │
├╌╌╌╌╌╌╌╌╌┤
│ null    │
├╌╌╌╌╌╌╌╌╌┤
│ ronaldo │
└─────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def extract(self, pattern: str, group_index: int = 1) -&gt; Series:
        r&quot;&quot;&quot;
        Extract the target capture group from provided patterns.

        Parameters
        ----------
        pattern
            A valid regex pattern
        group_index
            Index of the targeted capture group.
            Group 0 mean the whole pattern, first group begin at index 1
            Default to the first capture group

        Returns
        -------
        Utf8 array. Contain null if original value is null or regex capture nothing.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        ...         'a': [
        ...             'http://vote.com/ballon_dor?candidate=messi&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidat=jorginho&amp;ref=polars',
        ...             'http://vote.com/ballon_dor?candidate=ronaldo&amp;ref=polars'
        ...         ]})
        &gt;&gt;&gt; df.select([
        ...             pl.col('a').str.extract(r'candidate=(\w+)', 1)
        ...         ])
        shape: (3, 1)
        ┌─────────┐
        │ a       │
        │ ---     │
        │ str     │
        ╞═════════╡
        │ messi   │
        ├╌╌╌╌╌╌╌╌╌┤
        │ null    │
        ├╌╌╌╌╌╌╌╌╌┤
        │ ronaldo │
        └─────────┘
        &quot;&quot;&quot;
        return wrap_s(self._s.str_extract(pattern, group_index))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacereplace"><a class="header" href="#polarsinternalsseriesstringnamespacereplace"><code>polars.internals.series.StringNameSpace.replace</code></a></h3>
<pre><code class="language-python">replace(pattern: str, value: str) -&gt; Series:
</code></pre>
<p>Replace first regex match with a string value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: A valid regex pattern.</li>
<li>[<code>value</code>]: Substring to replace.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace(self, pattern: str, value: str) -&gt; Series:
        &quot;&quot;&quot;
        Replace first regex match with a string value.

        Parameters
        ----------
        pattern
            A valid regex pattern.
        value
            Substring to replace.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_replace(pattern, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacereplace_all"><a class="header" href="#polarsinternalsseriesstringnamespacereplace_all"><code>polars.internals.series.StringNameSpace.replace_all</code></a></h3>
<pre><code class="language-python">replace_all(pattern: str, value: str) -&gt; Series:
</code></pre>
<p>Replace all regex matches with a string value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>pattern</code>]: A valid regex pattern.</li>
<li>[<code>value</code>]: Substring to replace.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace_all(self, pattern: str, value: str) -&gt; Series:
        &quot;&quot;&quot;
        Replace all regex matches with a string value.

        Parameters
        ----------
        pattern
            A valid regex pattern.
        value
            Substring to replace.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_replace_all(pattern, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespaceto_lowercase"><a class="header" href="#polarsinternalsseriesstringnamespaceto_lowercase"><code>polars.internals.series.StringNameSpace.to_lowercase</code></a></h3>
<pre><code class="language-python">to_lowercase() -&gt; Series:
</code></pre>
<p>Modify the strings to their lowercase equivalent.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_lowercase(self) -&gt; Series:
        &quot;&quot;&quot;
        Modify the strings to their lowercase equivalent.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_to_lowercase())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespaceto_uppercase"><a class="header" href="#polarsinternalsseriesstringnamespaceto_uppercase"><code>polars.internals.series.StringNameSpace.to_uppercase</code></a></h3>
<pre><code class="language-python">to_uppercase() -&gt; Series:
</code></pre>
<p>Modify the strings to their uppercase equivalent.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_uppercase(self) -&gt; Series:
        &quot;&quot;&quot;
        Modify the strings to their uppercase equivalent.
        &quot;&quot;&quot;
        return wrap_s(self._s.str_to_uppercase())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacerstrip"><a class="header" href="#polarsinternalsseriesstringnamespacerstrip"><code>polars.internals.series.StringNameSpace.rstrip</code></a></h3>
<pre><code class="language-python">rstrip() -&gt; Series:
</code></pre>
<p>Remove trailing whitespace.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rstrip(self) -&gt; Series:
        &quot;&quot;&quot;
        Remove trailing whitespace.
        &quot;&quot;&quot;
        return self.replace(r&quot;[ \t]+$&quot;, &quot;&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespacelstrip"><a class="header" href="#polarsinternalsseriesstringnamespacelstrip"><code>polars.internals.series.StringNameSpace.lstrip</code></a></h3>
<pre><code class="language-python">lstrip() -&gt; Series:
</code></pre>
<p>Remove leading whitespace.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lstrip(self) -&gt; Series:
        &quot;&quot;&quot;
        Remove leading whitespace.
        &quot;&quot;&quot;
        return self.replace(r&quot;^\s*&quot;, &quot;&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesstringnamespaceslice"><a class="header" href="#polarsinternalsseriesstringnamespaceslice"><code>polars.internals.series.StringNameSpace.slice</code></a></h3>
<pre><code class="language-python">slice(start: int, length: Optionalint) -&gt; Series:
</code></pre>
<p>Create subslices of the string values of a Utf8 Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>start</code>]: Start of the slice (negative indexing may be used).</li>
<li>[<code>length</code>]: Optional length of the slice.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series of Utf8 type</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, start: int, length: Optional[int] = None) -&gt; Series:
        &quot;&quot;&quot;
        Create subslices of the string values of a Utf8 Series.

        Parameters
        ----------
        start
            Start of the slice (negative indexing may be used).
        length
            Optional length of the slice.

        Returns
        -------
        Series of Utf8 type
        &quot;&quot;&quot;
        return wrap_s(self._s.str_slice(start, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsserieslistnamespace"><a class="header" href="#polarsinternalsserieslistnamespace"><code>polars.internals.series.ListNameSpace</code></a></h1>
<p>Series.dt namespace.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacelengths"><code>lengths()</code></a>: Get the length of the arrays as UInt32.</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacesum"><code>sum()</code></a>: Sum all the arrays in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacemax"><code>max()</code></a>: Compute the max value of the arrays in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacemin"><code>min()</code></a>: Compute the min value of the arrays in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacemean"><code>mean()</code></a>: Compute the mean value of the arrays in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacesort"><code>sort()</code></a>: Sort the arrays in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespacereverse"><code>reverse()</code></a>: Reverse the arrays in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespaceunique"><code>unique()</code></a>: Get the unique/distinct values in the list</li>
<li><a href="polars/internals/series/ListNameSpace.html#polarsinternalsserieslistnamespaceconcat"><code>concat()</code></a>: Concat the arrays in a Series dtype List in linear time.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class ListNameSpace:
    &quot;&quot;&quot;
    Series.dt namespace.
    &quot;&quot;&quot;

    def __init__(self, series: Series):
        self._s = series._s

    def lengths(self) -&gt; Series:
        &quot;&quot;&quot;
        Get the length of the arrays as UInt32.
        &quot;&quot;&quot;
        return wrap_s(self._s.arr_lengths())

    def sum(self) -&gt; Series:
        &quot;&quot;&quot;
        Sum all the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.sum())  # type: ignore

    def max(self) -&gt; Series:
        &quot;&quot;&quot;
        Compute the max value of the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.max())  # type: ignore

    def min(self) -&gt; Series:
        &quot;&quot;&quot;
        Compute the min value of the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.min())  # type: ignore

    def mean(self) -&gt; Series:
        &quot;&quot;&quot;
        Compute the mean value of the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.min())  # type: ignore

    def sort(self, reverse: bool) -&gt; Series:
        &quot;&quot;&quot;
        Sort the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.sort(reverse))  # type: ignore

    def reverse(self) -&gt; Series:
        &quot;&quot;&quot;
        Reverse the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.reverse())  # type: ignore

    def unique(self) -&gt; Series:
        &quot;&quot;&quot;
        Get the unique/distinct values in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.unique())  # type: ignore

    def concat(self, other: Union[tp.List[Series], Series]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Concat the arrays in a Series dtype List in linear time.

        Parameters
        ----------
        other
            Columns to concat into a List Series
        &quot;&quot;&quot;
        if not isinstance(other, list):
            other = [other]
        s = wrap_s(self._s)
        names = [s.name for s in other]
        names.insert(0, s.name)
        df = pli.DataFrame(other)
        df.insert_at_idx(0, s)
        return df.select(pli.concat_list(names))[s.name]  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-13"><a class="header" href="#constructor-13">Constructor</a></h2>
<pre><code class="language-python">ListNameSpace(series: Series)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, series: Series):
        self._s = series._s
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-13"><a class="header" href="#methods-13">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacelengths"><a class="header" href="#polarsinternalsserieslistnamespacelengths"><code>polars.internals.series.ListNameSpace.lengths</code></a></h3>
<pre><code class="language-python">lengths() -&gt; Series:
</code></pre>
<p>Get the length of the arrays as UInt32.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lengths(self) -&gt; Series:
        &quot;&quot;&quot;
        Get the length of the arrays as UInt32.
        &quot;&quot;&quot;
        return wrap_s(self._s.arr_lengths())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacesum"><a class="header" href="#polarsinternalsserieslistnamespacesum"><code>polars.internals.series.ListNameSpace.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Series:
</code></pre>
<p>Sum all the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; Series:
        &quot;&quot;&quot;
        Sum all the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.sum())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacemax"><a class="header" href="#polarsinternalsserieslistnamespacemax"><code>polars.internals.series.ListNameSpace.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Series:
</code></pre>
<p>Compute the max value of the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; Series:
        &quot;&quot;&quot;
        Compute the max value of the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.max())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacemin"><a class="header" href="#polarsinternalsserieslistnamespacemin"><code>polars.internals.series.ListNameSpace.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Series:
</code></pre>
<p>Compute the min value of the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; Series:
        &quot;&quot;&quot;
        Compute the min value of the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.min())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacemean"><a class="header" href="#polarsinternalsserieslistnamespacemean"><code>polars.internals.series.ListNameSpace.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Series:
</code></pre>
<p>Compute the mean value of the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; Series:
        &quot;&quot;&quot;
        Compute the mean value of the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.min())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacesort"><a class="header" href="#polarsinternalsserieslistnamespacesort"><code>polars.internals.series.ListNameSpace.sort</code></a></h3>
<pre><code class="language-python">sort(reverse: bool) -&gt; Series:
</code></pre>
<p>Sort the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, reverse: bool) -&gt; Series:
        &quot;&quot;&quot;
        Sort the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.sort(reverse))  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespacereverse"><a class="header" href="#polarsinternalsserieslistnamespacereverse"><code>polars.internals.series.ListNameSpace.reverse</code></a></h3>
<pre><code class="language-python">reverse() -&gt; Series:
</code></pre>
<p>Reverse the arrays in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reverse(self) -&gt; Series:
        &quot;&quot;&quot;
        Reverse the arrays in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.reverse())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespaceunique"><a class="header" href="#polarsinternalsserieslistnamespaceunique"><code>polars.internals.series.ListNameSpace.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Series:
</code></pre>
<p>Get the unique/distinct values in the list</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; Series:
        &quot;&quot;&quot;
        Get the unique/distinct values in the list
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        return s.to_frame().select(pli.col(s.name).arr.unique())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsserieslistnamespaceconcat"><a class="header" href="#polarsinternalsserieslistnamespaceconcat"><code>polars.internals.series.ListNameSpace.concat</code></a></h3>
<pre><code class="language-python">concat(other: Union[tp.List[Series], Series],) -&gt; Series:
</code></pre>
<p>Concat the arrays in a Series dtype List in linear time.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Columns to concat into a List Series</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def concat(self, other: Union[tp.List[Series], Series]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Concat the arrays in a Series dtype List in linear time.

        Parameters
        ----------
        other
            Columns to concat into a List Series
        &quot;&quot;&quot;
        if not isinstance(other, list):
            other = [other]
        s = wrap_s(self._s)
        names = [s.name for s in other]
        names.insert(0, s.name)
        df = pli.DataFrame(other)
        df.insert_at_idx(0, s)
        return df.select(pli.concat_list(names))[s.name]  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsseriesdatetimenamespace"><a class="header" href="#polarsinternalsseriesdatetimenamespace"><code>polars.internals.series.DateTimeNameSpace</code></a></h1>
<p>Series.dt namespace.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacebuckets"><code>buckets()</code></a>: Divide the date/ datetime range into buckets.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacestrftime"><code>strftime()</code></a>: Format Date/datetime with a formatting rule: See <code>chrono strftime/strptime &lt;https:/docs.rs/chrono/0.4.19/chrono/format/strftime/index.html&gt;</code>_.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceyear"><code>year()</code></a>: Extract the year from the underlying date representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacemonth"><code>month()</code></a>: Extract the month from the underlying date representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceweek"><code>week()</code></a>: Extract the week from the underlying date representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceweekday"><code>weekday()</code></a>: Extract the week day from the underlying date representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceday"><code>day()</code></a>: Extract the day from the underlying date representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceordinal_day"><code>ordinal_day()</code></a>: Extract ordinal day from underlying date representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacehour"><code>hour()</code></a>: Extract the hour from the underlying DateTime representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceminute"><code>minute()</code></a>: Extract the minutes from the underlying DateTime representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacesecond"><code>second()</code></a>: Extract the seconds the from underlying DateTime representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacenanosecond"><code>nanosecond()</code></a>: Extract the nanoseconds from the underlying DateTime representation.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacetimestamp"><code>timestamp()</code></a>: Return timestamp in ms as Int64 type.</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceto_python_datetime"><code>to_python_datetime()</code></a>: Go from Date/Datetime to python DateTime objects</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacemin"><code>min()</code></a>: Return minimum as python DateTime</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacemax"><code>max()</code></a>: Return maximum as python DateTime</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacemedian"><code>median()</code></a>: Return median as python DateTime</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespacemean"><code>mean()</code></a>: Return mean as python DateTime</li>
<li><a href="polars/internals/series/DateTimeNameSpace.html#polarsinternalsseriesdatetimenamespaceround"><code>round()</code></a>: Round the datetime.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class DateTimeNameSpace:
    &quot;&quot;&quot;
    Series.dt namespace.
    &quot;&quot;&quot;

    def __init__(self, series: Series):
        self._s = series._s

    def buckets(self, interval: timedelta) -&gt; Series:
        &quot;&quot;&quot;
        Divide the date/ datetime range into buckets.
        Data will be sorted by this operation.

        Parameters
        ----------
        interval
            python timedelta to indicate bucket size

        Returns
        -------
        Date/Datetime series

        Examples
        --------
        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; import polars as pl
        &gt;&gt;&gt; date_range = pl.date_range(
        &gt;&gt;&gt; low=datetime(year=2000, month=10, day=1, hour=23, minute=30),
        &gt;&gt;&gt; high=datetime(year=2000, month=10, day=2, hour=0, minute=30),
        &gt;&gt;&gt; interval=timedelta(minutes=8),
        &gt;&gt;&gt; name=&quot;date_range&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; date_range.dt.buckets(timedelta(minutes=8))
        shape: (8,)
        Series: 'date_range' [datetime]
        [
            2000-10-01 23:30:00
            2000-10-01 23:30:00
            2000-10-01 23:38:00
            2000-10-01 23:46:00
            2000-10-01 23:54:00
            2000-10-02 00:02:00
            2000-10-02 00:10:00
            2000-10-02 00:18:00
        ]

        &gt;&gt;&gt; # can be used to perform a downsample operation
        &gt;&gt;&gt; (date_range
        &gt;&gt;&gt;  .to_frame()
        &gt;&gt;&gt;  .groupby(
        &gt;&gt;&gt;      pl.col(&quot;date_range&quot;).dt.buckets(timedelta(minutes=16)),
        &gt;&gt;&gt;      maintain_order=True
        &gt;&gt;&gt;  )
        &gt;&gt;&gt;  .agg(pl.col(&quot;date_range&quot;).count())
        &gt;&gt;&gt; )
        shape: (4, 2)
        ┌─────────────────────┬──────────────────┐
        │ date_range          ┆ date_range_count │
        │ ---                 ┆ ---              │
        │ datetime            ┆ u32              │
        ╞═════════════════════╪══════════════════╡
        │ 2000-10-01 23:30:00 ┆ 3                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-01 23:46:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:02:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:18:00 ┆ 1                │
        └─────────────────────┴──────────────────┘

        &quot;&quot;&quot;
        return pli.select(pli.lit(wrap_s(self._s)).dt.buckets(interval)).to_series()

    def __getitem__(self, item: int) -&gt; Union[date, datetime]:
        s = wrap_s(self._s)
        out = wrap_s(self._s)[item]
        return _to_python_datetime(out, s.dtype)

    def strftime(self, fmt: str) -&gt; Series:
        &quot;&quot;&quot;
        Format Date/datetime with a formatting rule: See `chrono strftime/strptime &lt;https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html&gt;`_.

        Returns
        -------
        Utf8 Series
        &quot;&quot;&quot;
        return wrap_s(self._s.strftime(fmt))

    def year(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the year from the underlying date representation.
        Can be performed on Date and Datetime.

        Returns the year number in the calendar date.

        Returns
        -------
        Year as Int32
        &quot;&quot;&quot;
        return wrap_s(self._s.year())

    def month(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the month from the underlying date representation.
        Can be performed on Date and Datetime

        Returns the month number starting from 1.
        The return value ranges from 1 to 12.

        Returns
        -------
        Month as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.month())

    def week(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the week from the underlying date representation.
        Can be performed on Date and Datetime

        Returns the ISO week number starting from 1.
        The return value ranges from 1 to 53. (The last week of year differs by years.)

        Returns
        -------
        Week number as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.week())

    def weekday(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the week day from the underlying date representation.
        Can be performed on Date and Datetime.

        Returns the weekday number where monday = 0 and sunday = 6

        Returns
        -------
        Week day as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.weekday())

    def day(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the day from the underlying date representation.
        Can be performed on Date and Datetime.

        Returns the day of month starting from 1.
        The return value ranges from 1 to 31. (The last day of month differs by months.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.day())

    def ordinal_day(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract ordinal day from underlying date representation.
        Can be performed on Date and Datetime.

        Returns the day of year starting from 1.
        The return value ranges from 1 to 366. (The last day of year differs by years.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.ordinal_day())

    def hour(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the hour from the underlying DateTime representation.
        Can be performed on Datetime.

        Returns the hour number from 0 to 23.

        Returns
        -------
        Hour as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.hour())

    def minute(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the minutes from the underlying DateTime representation.
        Can be performed on Datetime.

        Returns the minute number from 0 to 59.

        Returns
        -------
        Minute as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.minute())

    def second(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the seconds the from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the second number from 0 to 59.

        Returns
        -------
        Second as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.second())

    def nanosecond(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the nanoseconds from the underlying DateTime representation.
        Can be performed on Datetime.

        Returns the number of nanoseconds since the whole non-leap second.
        The range from 1,000,000,000 to 1,999,999,999 represents the leap second.

        Returns
        -------
        Nanosecond as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.nanosecond())

    def timestamp(self) -&gt; Series:
        &quot;&quot;&quot;
        Return timestamp in ms as Int64 type.
        &quot;&quot;&quot;
        return wrap_s(self._s.timestamp())

    def to_python_datetime(self) -&gt; Series:
        &quot;&quot;&quot;
        Go from Date/Datetime to python DateTime objects
        &quot;&quot;&quot;
        return (self.timestamp() / 1000).apply(
            lambda ts: datetime.utcfromtimestamp(ts), Object
        )

    def min(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return minimum as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = s.min()
        return _to_python_datetime(out, s.dtype)

    def max(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return maximum as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = s.max()
        return _to_python_datetime(out, s.dtype)

    def median(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return median as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = int(s.median())
        return _to_python_datetime(out, s.dtype)

    def mean(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return mean as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = int(s.mean())
        return _to_python_datetime(out, s.dtype)

    def round(self, rule: str, n: int) -&gt; Series:
        &quot;&quot;&quot;
        Round the datetime.

        Parameters
        ----------
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.
        &quot;&quot;&quot;
        return wrap_s(self._s.round_datetime(rule, n))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-14"><a class="header" href="#constructor-14">Constructor</a></h2>
<pre><code class="language-python">DateTimeNameSpace(series: Series)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, series: Series):
        self._s = series._s
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-14"><a class="header" href="#methods-14">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacebuckets"><a class="header" href="#polarsinternalsseriesdatetimenamespacebuckets"><code>polars.internals.series.DateTimeNameSpace.buckets</code></a></h3>
<pre><code class="language-python">buckets(interval: timedelta) -&gt; Series:
</code></pre>
<p>Divide the date/ datetime range into buckets.
Data will be sorted by this operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>interval</code>]: python timedelta to indicate bucket size</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Date/Datetime series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>from datetime import datetime, timedelta
import polars as pl
date_range = pl.date_range(
low=datetime(year=2000, month=10, day=1, hour=23, minute=30),
high=datetime(year=2000, month=10, day=2, hour=0, minute=30),
interval=timedelta(minutes=8),
name=&quot;date_range&quot;)</p>
<p>date_range.dt.buckets(timedelta(minutes=8))
shape: (8,)
Series: 'date_range' [datetime]
[
2000-10-01 23:30:00
2000-10-01 23:30:00
2000-10-01 23:38:00
2000-10-01 23:46:00
2000-10-01 23:54:00
2000-10-02 00:02:00
2000-10-02 00:10:00
2000-10-02 00:18:00
]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="can-be-used-to-perform-a-downsample-operation-1"><a class="header" href="#can-be-used-to-perform-a-downsample-operation-1">can be used to perform a downsample operation</a></h1>
<p>(date_range
.to_frame()
.groupby(
pl.col(&quot;date_range&quot;).dt.buckets(timedelta(minutes=16)),
maintain_order=True
)
.agg(pl.col(&quot;date_range&quot;).count())
)
shape: (4, 2)
┌─────────────────────┬──────────────────┐
│ date_range          ┆ date_range_count │
│ ---                 ┆ ---              │
│ datetime            ┆ u32              │
╞═════════════════════╪══════════════════╡
│ 2000-10-01 23:30:00 ┆ 3                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2000-10-01 23:46:00 ┆ 2                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2000-10-02 00:02:00 ┆ 2                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2000-10-02 00:18:00 ┆ 1                │
└─────────────────────┴──────────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def buckets(self, interval: timedelta) -&gt; Series:
        &quot;&quot;&quot;
        Divide the date/ datetime range into buckets.
        Data will be sorted by this operation.

        Parameters
        ----------
        interval
            python timedelta to indicate bucket size

        Returns
        -------
        Date/Datetime series

        Examples
        --------
        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; import polars as pl
        &gt;&gt;&gt; date_range = pl.date_range(
        &gt;&gt;&gt; low=datetime(year=2000, month=10, day=1, hour=23, minute=30),
        &gt;&gt;&gt; high=datetime(year=2000, month=10, day=2, hour=0, minute=30),
        &gt;&gt;&gt; interval=timedelta(minutes=8),
        &gt;&gt;&gt; name=&quot;date_range&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; date_range.dt.buckets(timedelta(minutes=8))
        shape: (8,)
        Series: 'date_range' [datetime]
        [
            2000-10-01 23:30:00
            2000-10-01 23:30:00
            2000-10-01 23:38:00
            2000-10-01 23:46:00
            2000-10-01 23:54:00
            2000-10-02 00:02:00
            2000-10-02 00:10:00
            2000-10-02 00:18:00
        ]

        &gt;&gt;&gt; # can be used to perform a downsample operation
        &gt;&gt;&gt; (date_range
        &gt;&gt;&gt;  .to_frame()
        &gt;&gt;&gt;  .groupby(
        &gt;&gt;&gt;      pl.col(&quot;date_range&quot;).dt.buckets(timedelta(minutes=16)),
        &gt;&gt;&gt;      maintain_order=True
        &gt;&gt;&gt;  )
        &gt;&gt;&gt;  .agg(pl.col(&quot;date_range&quot;).count())
        &gt;&gt;&gt; )
        shape: (4, 2)
        ┌─────────────────────┬──────────────────┐
        │ date_range          ┆ date_range_count │
        │ ---                 ┆ ---              │
        │ datetime            ┆ u32              │
        ╞═════════════════════╪══════════════════╡
        │ 2000-10-01 23:30:00 ┆ 3                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-01 23:46:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:02:00 ┆ 2                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2000-10-02 00:18:00 ┆ 1                │
        └─────────────────────┴──────────────────┘

        &quot;&quot;&quot;
        return pli.select(pli.lit(wrap_s(self._s)).dt.buckets(interval)).to_series()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacestrftime"><a class="header" href="#polarsinternalsseriesdatetimenamespacestrftime"><code>polars.internals.series.DateTimeNameSpace.strftime</code></a></h3>
<pre><code class="language-python">strftime(fmt: str) -&gt; Series:
</code></pre>
<p>Format Date/datetime with a formatting rule: See <code>chrono strftime/strptime &lt;https:/docs.rs/chrono/0.4.19/chrono/format/strftime/index.html&gt;</code>_.</p>
<p><strong>Returns:</strong></p>
<p>Utf8 Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def strftime(self, fmt: str) -&gt; Series:
        &quot;&quot;&quot;
        Format Date/datetime with a formatting rule: See `chrono strftime/strptime &lt;https://docs.rs/chrono/0.4.19/chrono/format/strftime/index.html&gt;`_.

        Returns
        -------
        Utf8 Series
        &quot;&quot;&quot;
        return wrap_s(self._s.strftime(fmt))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceyear"><a class="header" href="#polarsinternalsseriesdatetimenamespaceyear"><code>polars.internals.series.DateTimeNameSpace.year</code></a></h3>
<pre><code class="language-python">year() -&gt; Series:
</code></pre>
<p>Extract the year from the underlying date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the year number in the calendar date.</p>
<p><strong>Returns:</strong></p>
<p>Year as Int32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def year(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the year from the underlying date representation.
        Can be performed on Date and Datetime.

        Returns the year number in the calendar date.

        Returns
        -------
        Year as Int32
        &quot;&quot;&quot;
        return wrap_s(self._s.year())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacemonth"><a class="header" href="#polarsinternalsseriesdatetimenamespacemonth"><code>polars.internals.series.DateTimeNameSpace.month</code></a></h3>
<pre><code class="language-python">month() -&gt; Series:
</code></pre>
<p>Extract the month from the underlying date representation.
Can be performed on Date and Datetime</p>
<p>Returns the month number starting from 1.
The return value ranges from 1 to 12.</p>
<p><strong>Returns:</strong></p>
<p>Month as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def month(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the month from the underlying date representation.
        Can be performed on Date and Datetime

        Returns the month number starting from 1.
        The return value ranges from 1 to 12.

        Returns
        -------
        Month as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.month())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceweek"><a class="header" href="#polarsinternalsseriesdatetimenamespaceweek"><code>polars.internals.series.DateTimeNameSpace.week</code></a></h3>
<pre><code class="language-python">week() -&gt; Series:
</code></pre>
<p>Extract the week from the underlying date representation.
Can be performed on Date and Datetime</p>
<p>Returns the ISO week number starting from 1.
The return value ranges from 1 to 53. (The last week of year differs by years.)</p>
<p><strong>Returns:</strong></p>
<p>Week number as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def week(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the week from the underlying date representation.
        Can be performed on Date and Datetime

        Returns the ISO week number starting from 1.
        The return value ranges from 1 to 53. (The last week of year differs by years.)

        Returns
        -------
        Week number as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.week())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceweekday"><a class="header" href="#polarsinternalsseriesdatetimenamespaceweekday"><code>polars.internals.series.DateTimeNameSpace.weekday</code></a></h3>
<pre><code class="language-python">weekday() -&gt; Series:
</code></pre>
<p>Extract the week day from the underlying date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the weekday number where monday = 0 and sunday = 6</p>
<p><strong>Returns:</strong></p>
<p>Week day as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def weekday(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the week day from the underlying date representation.
        Can be performed on Date and Datetime.

        Returns the weekday number where monday = 0 and sunday = 6

        Returns
        -------
        Week day as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.weekday())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceday"><a class="header" href="#polarsinternalsseriesdatetimenamespaceday"><code>polars.internals.series.DateTimeNameSpace.day</code></a></h3>
<pre><code class="language-python">day() -&gt; Series:
</code></pre>
<p>Extract the day from the underlying date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the day of month starting from 1.
The return value ranges from 1 to 31. (The last day of month differs by months.)</p>
<p><strong>Returns:</strong></p>
<p>Day as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def day(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the day from the underlying date representation.
        Can be performed on Date and Datetime.

        Returns the day of month starting from 1.
        The return value ranges from 1 to 31. (The last day of month differs by months.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.day())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceordinal_day"><a class="header" href="#polarsinternalsseriesdatetimenamespaceordinal_day"><code>polars.internals.series.DateTimeNameSpace.ordinal_day</code></a></h3>
<pre><code class="language-python">ordinal_day() -&gt; Series:
</code></pre>
<p>Extract ordinal day from underlying date representation.
Can be performed on Date and Datetime.</p>
<p>Returns the day of year starting from 1.
The return value ranges from 1 to 366. (The last day of year differs by years.)</p>
<p><strong>Returns:</strong></p>
<p>Day as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def ordinal_day(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract ordinal day from underlying date representation.
        Can be performed on Date and Datetime.

        Returns the day of year starting from 1.
        The return value ranges from 1 to 366. (The last day of year differs by years.)

        Returns
        -------
        Day as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.ordinal_day())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacehour"><a class="header" href="#polarsinternalsseriesdatetimenamespacehour"><code>polars.internals.series.DateTimeNameSpace.hour</code></a></h3>
<pre><code class="language-python">hour() -&gt; Series:
</code></pre>
<p>Extract the hour from the underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the hour number from 0 to 23.</p>
<p><strong>Returns:</strong></p>
<p>Hour as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hour(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the hour from the underlying DateTime representation.
        Can be performed on Datetime.

        Returns the hour number from 0 to 23.

        Returns
        -------
        Hour as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.hour())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceminute"><a class="header" href="#polarsinternalsseriesdatetimenamespaceminute"><code>polars.internals.series.DateTimeNameSpace.minute</code></a></h3>
<pre><code class="language-python">minute() -&gt; Series:
</code></pre>
<p>Extract the minutes from the underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the minute number from 0 to 59.</p>
<p><strong>Returns:</strong></p>
<p>Minute as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def minute(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the minutes from the underlying DateTime representation.
        Can be performed on Datetime.

        Returns the minute number from 0 to 59.

        Returns
        -------
        Minute as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.minute())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacesecond"><a class="header" href="#polarsinternalsseriesdatetimenamespacesecond"><code>polars.internals.series.DateTimeNameSpace.second</code></a></h3>
<pre><code class="language-python">second() -&gt; Series:
</code></pre>
<p>Extract the seconds the from underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the second number from 0 to 59.</p>
<p><strong>Returns:</strong></p>
<p>Second as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def second(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the seconds the from underlying DateTime representation.
        Can be performed on Datetime.

        Returns the second number from 0 to 59.

        Returns
        -------
        Second as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.second())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacenanosecond"><a class="header" href="#polarsinternalsseriesdatetimenamespacenanosecond"><code>polars.internals.series.DateTimeNameSpace.nanosecond</code></a></h3>
<pre><code class="language-python">nanosecond() -&gt; Series:
</code></pre>
<p>Extract the nanoseconds from the underlying DateTime representation.
Can be performed on Datetime.</p>
<p>Returns the number of nanoseconds since the whole non-leap second.
The range from 1,000,000,000 to 1,999,999,999 represents the leap second.</p>
<p><strong>Returns:</strong></p>
<p>Nanosecond as UInt32</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def nanosecond(self) -&gt; Series:
        &quot;&quot;&quot;
        Extract the nanoseconds from the underlying DateTime representation.
        Can be performed on Datetime.

        Returns the number of nanoseconds since the whole non-leap second.
        The range from 1,000,000,000 to 1,999,999,999 represents the leap second.

        Returns
        -------
        Nanosecond as UInt32
        &quot;&quot;&quot;
        return wrap_s(self._s.nanosecond())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacetimestamp"><a class="header" href="#polarsinternalsseriesdatetimenamespacetimestamp"><code>polars.internals.series.DateTimeNameSpace.timestamp</code></a></h3>
<pre><code class="language-python">timestamp() -&gt; Series:
</code></pre>
<p>Return timestamp in ms as Int64 type.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def timestamp(self) -&gt; Series:
        &quot;&quot;&quot;
        Return timestamp in ms as Int64 type.
        &quot;&quot;&quot;
        return wrap_s(self._s.timestamp())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceto_python_datetime"><a class="header" href="#polarsinternalsseriesdatetimenamespaceto_python_datetime"><code>polars.internals.series.DateTimeNameSpace.to_python_datetime</code></a></h3>
<pre><code class="language-python">to_python_datetime() -&gt; Series:
</code></pre>
<p>Go from Date/Datetime to python DateTime objects</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_python_datetime(self) -&gt; Series:
        &quot;&quot;&quot;
        Go from Date/Datetime to python DateTime objects
        &quot;&quot;&quot;
        return (self.timestamp() / 1000).apply(
            lambda ts: datetime.utcfromtimestamp(ts), Object
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacemin"><a class="header" href="#polarsinternalsseriesdatetimenamespacemin"><code>polars.internals.series.DateTimeNameSpace.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Union[date, datetime]:
</code></pre>
<p>Return minimum as python DateTime</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return minimum as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = s.min()
        return _to_python_datetime(out, s.dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacemax"><a class="header" href="#polarsinternalsseriesdatetimenamespacemax"><code>polars.internals.series.DateTimeNameSpace.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Union[date, datetime]:
</code></pre>
<p>Return maximum as python DateTime</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return maximum as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = s.max()
        return _to_python_datetime(out, s.dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacemedian"><a class="header" href="#polarsinternalsseriesdatetimenamespacemedian"><code>polars.internals.series.DateTimeNameSpace.median</code></a></h3>
<pre><code class="language-python">median() -&gt; Union[date, datetime]:
</code></pre>
<p>Return median as python DateTime</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return median as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = int(s.median())
        return _to_python_datetime(out, s.dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespacemean"><a class="header" href="#polarsinternalsseriesdatetimenamespacemean"><code>polars.internals.series.DateTimeNameSpace.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Union[date, datetime]:
</code></pre>
<p>Return mean as python DateTime</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; Union[date, datetime]:
        &quot;&quot;&quot;
        Return mean as python DateTime
        &quot;&quot;&quot;
        s = wrap_s(self._s)
        out = int(s.mean())
        return _to_python_datetime(out, s.dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesdatetimenamespaceround"><a class="header" href="#polarsinternalsseriesdatetimenamespaceround"><code>polars.internals.series.DateTimeNameSpace.round</code></a></h3>
<pre><code class="language-python">round(rule: str, n: int) -&gt; Series:
</code></pre>
<p>Round the datetime.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>rule</code>]: Units of the downscaling operation.</p>
<p>Any of:
- &quot;month&quot;
- &quot;week&quot;
- &quot;day&quot;
- &quot;hour&quot;
- &quot;minute&quot;
- &quot;second&quot;</p>
</li>
<li>
<p>[<code>n</code>]: Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.</p>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, rule: str, n: int) -&gt; Series:
        &quot;&quot;&quot;
        Round the datetime.

        Parameters
        ----------
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.
        &quot;&quot;&quot;
        return wrap_s(self._s.round_datetime(rule, n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalsseriesseriesiter"><a class="header" href="#polarsinternalsseriesseriesiter"><code>polars.internals.series.SeriesIter</code></a></h1>
<p>Utility class that allows slow iteration over a <code>Series</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class SeriesIter:
    &quot;&quot;&quot;
    Utility class that allows slow iteration over a `Series`.
    &quot;&quot;&quot;

    def __init__(self, length: int, s: Series):
        self.len = length
        self.i = 0
        self.s = s

    def __iter__(self) -&gt; &quot;SeriesIter&quot;:
        return self

    def __next__(self) -&gt; Any:
        if self.i &lt; self.len:
            i = self.i
            self.i += 1
            return self.s[i]
        else:
            raise StopIteration
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-15"><a class="header" href="#constructor-15">Constructor</a></h2>
<pre><code class="language-python">SeriesIter(length: int, s: Series)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, length: int, s: Series):
        self.len = length
        self.i = 0
        self.s = s
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsinternalswhenthen"><a class="header" href="#module-polarsinternalswhenthen">Module <code>polars.internals.whenthen</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/internals/whenthen.html#polarsinternalswhenthenwhen"><code>when()</code></a>: Start a when, then, otherwise expression.</li>
</ul>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhen"><a class="header" href="#polarsinternalswhenthenwhen"><code>polars.internals.whenthen.when</code></a></h3>
<pre><code class="language-python">when(expr: pli.Expr) -&gt; When:
</code></pre>
<p>Start a when, then, otherwise expression.</p>
<p><strong>Examples:</strong></p>
<p>Below we add a column with the value 1, where column &quot;foo&quot; &gt; 2 and the value -1 where it isn't.</p>
<blockquote>
<blockquote>
<blockquote>
<p>lf.with_column(
when(col(&quot;foo&quot;) &gt; 2)
.then(lit(1))
.otherwise(lit(-1))
)</p>
</blockquote>
</blockquote>
</blockquote>
<p>Or with multiple <code>when, thens</code> chained:</p>
<blockquote>
<blockquote>
<blockquote>
<p>lf.with_column(
when(col(&quot;foo&quot;) &gt; 2).then(1)
when(col(&quot;bar&quot;) &gt; 2).then(4)
.otherwise(-1)
)</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def when(expr: pli.Expr) -&gt; When:
    &quot;&quot;&quot;
    Start a when, then, otherwise expression.

    Examples
    --------

    Below we add a column with the value 1, where column &quot;foo&quot; &gt; 2 and the value -1 where it isn't.

    &gt;&gt;&gt; lf.with_column(
        when(col(&quot;foo&quot;) &gt; 2)
        .then(lit(1))
        .otherwise(lit(-1))
    )

    Or with multiple `when, thens` chained:

    &gt;&gt;&gt; lf.with_column(
        when(col(&quot;foo&quot;) &gt; 2).then(1)
        when(col(&quot;bar&quot;) &gt; 2).then(4)
        .otherwise(-1)
    )
    &quot;&quot;&quot;
    expr = pli.expr_to_lit_or_expr(expr)
    pw = pywhen(expr._pyexpr)
    return When(pw)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalswhenthenwhenthenthen"><a class="header" href="#polarsinternalswhenthenwhenthenthen"><code>polars.internals.whenthen.WhenThenThen</code></a></h1>
<p>Utility class. See the <code>when</code> function.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/whenthen/WhenThenThen.html#polarsinternalswhenthenwhenthenthenwhen"><code>when()</code></a>: Start another when, then, otherwise layer.</li>
<li><a href="polars/internals/whenthen/WhenThenThen.html#polarsinternalswhenthenwhenthenthenthen"><code>then()</code></a>: Values to return in case of the predicate being <code>True</code>.</li>
<li><a href="polars/internals/whenthen/WhenThenThen.html#polarsinternalswhenthenwhenthenthenotherwise"><code>otherwise()</code></a>: Values to return in case of the predicate being <code>False</code>.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class WhenThenThen:
    &quot;&quot;&quot;
    Utility class. See the `when` function.
    &quot;&quot;&quot;

    def __init__(self, pywhenthenthen: Any):
        self.pywenthenthen = pywhenthenthen

    def when(self, predicate: pli.Expr) -&gt; &quot;WhenThenThen&quot;:
        &quot;&quot;&quot;
        Start another when, then, otherwise layer.
        &quot;&quot;&quot;
        return WhenThenThen(self.pywenthenthen.when(predicate._pyexpr))

    def then(self, expr: Union[pli.Expr, int, float, str]) -&gt; &quot;WhenThenThen&quot;:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `True`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr_ = pli.expr_to_lit_or_expr(expr)
        return WhenThenThen(self.pywenthenthen.then(expr_._pyexpr))

    def otherwise(self, expr: Union[pli.Expr, int, float, str]) -&gt; pli.Expr:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `False`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr = pli.expr_to_lit_or_expr(expr)
        return pli.wrap_expr(self.pywenthenthen.otherwise(expr._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-16"><a class="header" href="#constructor-16">Constructor</a></h2>
<pre><code class="language-python">WhenThenThen(pywhenthenthen: Any)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, pywhenthenthen: Any):
        self.pywenthenthen = pywhenthenthen
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-15"><a class="header" href="#methods-15">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhenthenthenwhen"><a class="header" href="#polarsinternalswhenthenwhenthenthenwhen"><code>polars.internals.whenthen.WhenThenThen.when</code></a></h3>
<pre><code class="language-python">when(predicate: pli.Expr) -&gt; WhenThenThen:
</code></pre>
<p>Start another when, then, otherwise layer.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def when(self, predicate: pli.Expr) -&gt; &quot;WhenThenThen&quot;:
        &quot;&quot;&quot;
        Start another when, then, otherwise layer.
        &quot;&quot;&quot;
        return WhenThenThen(self.pywenthenthen.when(predicate._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhenthenthenthen"><a class="header" href="#polarsinternalswhenthenwhenthenthenthen"><code>polars.internals.whenthen.WhenThenThen.then</code></a></h3>
<pre><code class="language-python">then(expr: Union[pli.Expr, int, float, str],) -&gt; WhenThenThen:
</code></pre>
<p>Values to return in case of the predicate being <code>True</code>.</p>
<p>See Also: the <code>when</code> function.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def then(self, expr: Union[pli.Expr, int, float, str]) -&gt; &quot;WhenThenThen&quot;:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `True`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr_ = pli.expr_to_lit_or_expr(expr)
        return WhenThenThen(self.pywenthenthen.then(expr_._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhenthenthenotherwise"><a class="header" href="#polarsinternalswhenthenwhenthenthenotherwise"><code>polars.internals.whenthen.WhenThenThen.otherwise</code></a></h3>
<pre><code class="language-python">otherwise(expr: Union[pli.Expr, int, float, str],) -&gt; pli.Expr:
</code></pre>
<p>Values to return in case of the predicate being <code>False</code>.</p>
<p>See Also: the <code>when</code> function.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def otherwise(self, expr: Union[pli.Expr, int, float, str]) -&gt; pli.Expr:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `False`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr = pli.expr_to_lit_or_expr(expr)
        return pli.wrap_expr(self.pywenthenthen.otherwise(expr._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalswhenthenwhenthen"><a class="header" href="#polarsinternalswhenthenwhenthen"><code>polars.internals.whenthen.WhenThen</code></a></h1>
<p>Utility class. See the <code>when</code> function.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/whenthen/WhenThen.html#polarsinternalswhenthenwhenthenwhen"><code>when()</code></a>: Start another when, then, otherwise layer.</li>
<li><a href="polars/internals/whenthen/WhenThen.html#polarsinternalswhenthenwhenthenotherwise"><code>otherwise()</code></a>: Values to return in case of the predicate being <code>False</code>.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class WhenThen:
    &quot;&quot;&quot;
    Utility class. See the `when` function.
    &quot;&quot;&quot;

    def __init__(self, pywhenthen: Any):
        self._pywhenthen = pywhenthen

    def when(self, predicate: pli.Expr) -&gt; WhenThenThen:
        &quot;&quot;&quot;
        Start another when, then, otherwise layer.
        &quot;&quot;&quot;
        return WhenThenThen(self._pywhenthen.when(predicate._pyexpr))

    def otherwise(self, expr: Union[pli.Expr, int, float, str]) -&gt; pli.Expr:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `False`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr = pli.expr_to_lit_or_expr(expr)
        return pli.wrap_expr(self._pywhenthen.otherwise(expr._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-17"><a class="header" href="#constructor-17">Constructor</a></h2>
<pre><code class="language-python">WhenThen(pywhenthen: Any)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, pywhenthen: Any):
        self._pywhenthen = pywhenthen
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-16"><a class="header" href="#methods-16">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhenthenwhen"><a class="header" href="#polarsinternalswhenthenwhenthenwhen"><code>polars.internals.whenthen.WhenThen.when</code></a></h3>
<pre><code class="language-python">when(predicate: pli.Expr) -&gt; WhenThenThen:
</code></pre>
<p>Start another when, then, otherwise layer.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def when(self, predicate: pli.Expr) -&gt; WhenThenThen:
        &quot;&quot;&quot;
        Start another when, then, otherwise layer.
        &quot;&quot;&quot;
        return WhenThenThen(self._pywhenthen.when(predicate._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhenthenotherwise"><a class="header" href="#polarsinternalswhenthenwhenthenotherwise"><code>polars.internals.whenthen.WhenThen.otherwise</code></a></h3>
<pre><code class="language-python">otherwise(expr: Union[pli.Expr, int, float, str],) -&gt; pli.Expr:
</code></pre>
<p>Values to return in case of the predicate being <code>False</code>.</p>
<p>See Also: the <code>when</code> function.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def otherwise(self, expr: Union[pli.Expr, int, float, str]) -&gt; pli.Expr:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `False`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr = pli.expr_to_lit_or_expr(expr)
        return pli.wrap_expr(self._pywhenthen.otherwise(expr._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsinternalswhenthenwhen-1"><a class="header" href="#polarsinternalswhenthenwhen-1"><code>polars.internals.whenthen.When</code></a></h1>
<p>Utility class. See the <code>when</code> function.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="polars/internals/whenthen/When.html#polarsinternalswhenthenwhenthen"><code>then()</code></a>: Values to return in case of the predicate being <code>True</code>.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class When:
    &quot;&quot;&quot;
    Utility class. See the `when` function.
    &quot;&quot;&quot;

    def __init__(self, pywhen: &quot;pywhen&quot;):
        self._pywhen = pywhen

    def then(self, expr: Union[pli.Expr, int, float, str]) -&gt; WhenThen:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `True`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr = pli.expr_to_lit_or_expr(expr)
        pywhenthen = self._pywhen.then(expr._pyexpr)
        return WhenThen(pywhenthen)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-18"><a class="header" href="#constructor-18">Constructor</a></h2>
<pre><code class="language-python">When(pywhen: pywhen)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self, pywhen: &quot;pywhen&quot;):
        self._pywhen = pywhen
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods-17"><a class="header" href="#methods-17">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalswhenthenwhenthen-1"><a class="header" href="#polarsinternalswhenthenwhenthen-1"><code>polars.internals.whenthen.When.then</code></a></h3>
<pre><code class="language-python">then(expr: Union[pli.Expr, int, float, str],) -&gt; WhenThen:
</code></pre>
<p>Values to return in case of the predicate being <code>True</code>.</p>
<p>See Also: the <code>when</code> function.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def then(self, expr: Union[pli.Expr, int, float, str]) -&gt; WhenThen:
        &quot;&quot;&quot;
        Values to return in case of the predicate being `True`.

        See Also: the `when` function.
        &quot;&quot;&quot;
        expr = pli.expr_to_lit_or_expr(expr)
        pywhenthen = self._pywhen.then(expr._pyexpr)
        return WhenThen(pywhenthen)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsio"><a class="header" href="#module-polarsio">Module <code>polars.io</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/io.html#polarsioupdate_columns"><code>update_columns()</code></a>: </li>
<li><a href="polars/io.html#polarsioread_csv"><code>read_csv()</code></a>: Read into a DataFrame from a csv file.</li>
<li><a href="polars/io.html#polarsioscan_csv"><code>scan_csv()</code></a>: Lazily read from a csv file.</li>
<li><a href="polars/io.html#polarsioscan_ipc"><code>scan_ipc()</code></a>: Lazily read from an IPC file.</li>
<li><a href="polars/io.html#polarsioscan_parquet"><code>scan_parquet()</code></a>: Lazily read from a parquet file.</li>
<li><a href="polars/io.html#polarsioread_ipc_schema"><code>read_ipc_schema()</code></a>: Get a schema of the IPC file without reading data.</li>
<li><a href="polars/io.html#polarsioread_ipc"><code>read_ipc()</code></a>: Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.</li>
<li><a href="polars/io.html#polarsioread_parquet"><code>read_parquet()</code></a>: Read into a DataFrame from a parquet file.</li>
<li><a href="polars/io.html#polarsioread_json"><code>read_json()</code></a>: Read into a DataFrame from JSON format.</li>
<li><a href="polars/io.html#polarsioread_sql"><code>read_sql()</code></a>: Read a SQL query into a DataFrame</li>
</ul>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsioupdate_columns"><a class="header" href="#polarsioupdate_columns"><code>polars.io.update_columns</code></a></h3>
<pre><code class="language-python">update_columns(
    df: DataFrame, 
    new_columns: List[str],
) -&gt; DataFrame:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def update_columns(df: DataFrame, new_columns: List[str]) -&gt; DataFrame:
    if df.width &gt; len(new_columns):
        cols = df.columns
        for i, name in enumerate(new_columns):
            cols[i] = name
        new_columns = cols
    df.columns = new_columns
    return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioread_csv"><a class="header" href="#polarsioread_csv"><code>polars.io.read_csv</code></a></h3>
<pre><code class="language-python">read_csv(
    file: Union[str, TextIO, BytesIO, Path, BinaryIO, bytes], 
    infer_schema_length: Optionalint, 
    batch_size: int, 
    has_headers: bool, 
    ignore_errors: bool, 
    stop_after_n_rows: Optionalint, 
    skip_rows: int, 
    projection: OptionalList[int], 
    sep: str, 
    columns: OptionalList[str], 
    rechunk: bool, 
    encoding: str, 
    n_threads: Optionalint, 
    dtype: OptionalUnion[Dict[str, TypeDataType], List[TypeDataType]], 
    new_columns: OptionalList[str], 
    use_pyarrow: bool, 
    low_memory: bool, 
    comment_char: Optionalstr, 
    quote_char: Optionalstr, 
    storage_options: OptionalDict, 
    null_values: OptionalUnion[str, List[str], Dict[str, str]], 
    parse_dates: bool,
) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from a csv file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>file</code>]: Path to a file or a file like object.
By file-like object, we refer to objects with a <code>read()</code> method,
such as a file handler (e.g. via builtin <code>open</code> function)
or <code>StringIO</code> or <code>BytesIO</code>.
If <code>fsspec</code> is installed, it will be used to open remote files</p>
</li>
<li>
<p>[<code>infer_schema_length</code>]: Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
If set to <code>None</code>, a full table scan will be done (slow).</p>
</li>
<li>
<p>[<code>batch_size</code>]: Number of lines to read into the buffer at once. Modify this to change performance.</p>
</li>
<li>
<p>[<code>has_headers</code>]: Indicate if first row of dataset is header or not. If set to False first row will be set to <code>column_x</code>,
<code>x</code> being an enumeration over every column in the dataset starting at 1.</p>
</li>
<li>
<p>[<code>ignore_errors</code>]: Try to keep reading lines if some lines yield errors.</p>
</li>
<li>
<p>[<code>stop_after_n_rows</code>]: After n rows are read from the CSV, it stops reading.
During multi-threaded parsing, an upper bound of <code>n</code> rows
cannot be guaranteed.</p>
</li>
<li>
<p>[<code>skip_rows</code>]: Start reading after <code>skip_rows</code>.</p>
</li>
<li>
<p>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</p>
</li>
<li>
<p>[<code>sep</code>]: Delimiter/ value separator.</p>
</li>
<li>
<p>[<code>columns</code>]: Columns to select.</p>
</li>
<li>
<p>[<code>rechunk</code>]: Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.</p>
</li>
<li>
<ul>
<li>&quot;utf8-lossy&quot;</li>
</ul>
</li>
<li>
<p>[<code>n_threads</code>]: Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.</p>
</li>
<li>
<p>[<code>dtype</code>]: Overwrite the dtypes during inference.</p>
</li>
<li>
<p>[<code>new_columns</code>]: Rename columns to these right after parsing. If the given list is shorted than the width of the DataFrame the
remaining columns will have their original name.</p>
</li>
<li>
<p>[<code>use_pyarrow</code>]: Try to use pyarrow's native CSV parser. This is not always possible. The set of arguments given to this function
determine if it is possible to use pyarrows native parser. Note that pyarrow and polars may have a different
strategy regarding type inference.</p>
</li>
<li>
<p>[<code>low_memory</code>]: Reduce memory usage in expense of performance.</p>
</li>
<li>
<p>[<code>comment_char</code>]: character that indicates the start of a comment line, for instance '#'.</p>
</li>
<li>
<p>[<code>quote_char</code>]: single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
of quotes off.</p>
</li>
<li>
<p>[<code>storage_options</code>]: Extra options that make sense for <code>fsspec.open()</code> or a particular storage connection, e.g. host, port, username, password, etc.</p>
</li>
<li>
<p>[<code>null_values</code>]: Values to interpret as null values. You can provide a:</p>
<ul>
<li>str -&gt; all values encountered equal to this string will be null</li>
<li>List[str] -&gt; A null value per column.</li>
<li>Dict[str, str] -&gt; A dictionary that maps column name to a null value string.</li>
</ul>
</li>
<li>
<p>[<code>parse_dates</code>]: Try to automatically parse dates. If this not succeeds, the column remains
of data type Utf8.</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def read_csv(
    file: Union[str, TextIO, BytesIO, Path, BinaryIO, bytes],
    infer_schema_length: Optional[int] = 100,
    batch_size: int = 8192,
    has_headers: bool = True,
    ignore_errors: bool = False,
    stop_after_n_rows: Optional[int] = None,
    skip_rows: int = 0,
    projection: Optional[List[int]] = None,
    sep: str = &quot;,&quot;,
    columns: Optional[List[str]] = None,
    rechunk: bool = True,
    encoding: str = &quot;utf8&quot;,
    n_threads: Optional[int] = None,
    dtype: Optional[Union[Dict[str, Type[DataType]], List[Type[DataType]]]] = None,
    new_columns: Optional[List[str]] = None,
    use_pyarrow: bool = False,
    low_memory: bool = False,
    comment_char: Optional[str] = None,
    quote_char: Optional[str] = r'&quot;',
    storage_options: Optional[Dict] = None,
    null_values: Optional[Union[str, List[str], Dict[str, str]]] = None,
    parse_dates: bool = True,
) -&gt; DataFrame:
    &quot;&quot;&quot;
    Read into a DataFrame from a csv file.

    Parameters
    ----------
    file
        Path to a file or a file like object.
        By file-like object, we refer to objects with a ``read()`` method,
        such as a file handler (e.g. via builtin ``open`` function)
        or ``StringIO`` or ``BytesIO``.
        If ``fsspec`` is installed, it will be used to open remote files
    infer_schema_length
        Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
        If set to `None`, a full table scan will be done (slow).
    batch_size
        Number of lines to read into the buffer at once. Modify this to change performance.
    has_headers
        Indicate if first row of dataset is header or not. If set to False first row will be set to `column_x`,
        `x` being an enumeration over every column in the dataset starting at 1.
    ignore_errors
        Try to keep reading lines if some lines yield errors.
    stop_after_n_rows
        After n rows are read from the CSV, it stops reading.
        During multi-threaded parsing, an upper bound of `n` rows
        cannot be guaranteed.
    skip_rows
        Start reading after `skip_rows`.
    projection
        Indices of columns to select. Note that column indices start at zero.
    sep
        Delimiter/ value separator.
    columns
        Columns to select.
    rechunk
        Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.
    encoding
        - &quot;utf8&quot;
        - &quot;utf8-lossy&quot;
    n_threads
        Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.
    dtype
        Overwrite the dtypes during inference.
    new_columns
        Rename columns to these right after parsing. If the given list is shorted than the width of the DataFrame the
        remaining columns will have their original name.
    use_pyarrow
        Try to use pyarrow's native CSV parser. This is not always possible. The set of arguments given to this function
        determine if it is possible to use pyarrows native parser. Note that pyarrow and polars may have a different
        strategy regarding type inference.
    low_memory
        Reduce memory usage in expense of performance.
    comment_char
        character that indicates the start of a comment line, for instance '#'.
    quote_char
        single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
        of quotes off.
    storage_options
        Extra options that make sense for ``fsspec.open()`` or a particular storage connection, e.g. host, port, username, password, etc.
    null_values
        Values to interpret as null values. You can provide a:

        - str -&gt; all values encountered equal to this string will be null
        - List[str] -&gt; A null value per column.
        - Dict[str, str] -&gt; A dictionary that maps column name to a null value string.
    parse_dates
        Try to automatically parse dates. If this not succeeds, the column remains
        of data type Utf8.

    Returns
    -------
    DataFrame
    &quot;&quot;&quot;
    if isinstance(file, bytes) and len(file) == 0:
        raise ValueError(&quot;no date in bytes&quot;)

    storage_options = storage_options or {}

    if columns and not has_headers:
        for column in columns:
            if not column.startswith(&quot;column_&quot;):
                raise ValueError(
                    'Specified column names do not start with &quot;column_&quot;, '
                    &quot;but autogenerated header names were requested.&quot;
                )

    if use_pyarrow and not _PYARROW_AVAILABLE:
        raise ImportError(
            &quot;'pyarrow' is required when using 'read_csv(..., use_pyarrow=True)'.&quot;
        )

    if (
        use_pyarrow
        and dtype is None
        and stop_after_n_rows is None
        and n_threads is None
        and encoding == &quot;utf8&quot;
        and not low_memory
        and null_values is None
        and parse_dates
    ):
        include_columns = None

        if columns:
            if not has_headers:
                # Convert 'column_1', 'column_2', ... column names to 'f0', 'f1', ... column names for pyarrow,
                # if CSV file does not contain a header.
                include_columns = [f&quot;f{int(column[7:]) - 1}&quot; for column in columns]
            else:
                include_columns = columns

        if not columns and projection:
            # Convert column indices from projection to 'f0', 'f1', ... column names for pyarrow.
            include_columns = [f&quot;f{column_idx}&quot; for column_idx in projection]

        with _prepare_file_arg(file, **storage_options) as data:
            tbl = pa.csv.read_csv(
                data,
                pa.csv.ReadOptions(
                    skip_rows=skip_rows, autogenerate_column_names=not has_headers
                ),
                pa.csv.ParseOptions(delimiter=sep),
                pa.csv.ConvertOptions(
                    column_types=None,
                    include_columns=include_columns,
                    include_missing_columns=ignore_errors,
                ),
            )

        if not has_headers:
            # Rename 'f0', 'f1', ... columns names autogenated by pyarrow to 'column_1', 'column_2', ...
            tbl = tbl.rename_columns(
                [f&quot;column_{int(column[1:]) + 1}&quot; for column in tbl.column_names]
            )

        df = from_arrow(tbl, rechunk)
        if new_columns:
            return update_columns(df, new_columns)  # type: ignore
        return df  # type: ignore

    if new_columns and dtype and isinstance(dtype, dict):
        current_columns = None

        # As new column names are not available yet while parsing the CSV file, rename column names in
        # dtype to old names (if possible) so they can be used during CSV parsing.
        if columns:
            if len(columns) &lt; len(new_columns):
                raise ValueError(
                    &quot;More new colum names are specified than there are selected columns.&quot;
                )

            # Get column names of requested columns.
            current_columns = columns[0 : len(new_columns)]
        elif not has_headers:
            # When there are no header, column names are autogenerated (and known).

            if projection:
                if columns and len(columns) &lt; len(new_columns):
                    raise ValueError(
                        &quot;More new colum names are specified than there are projected columns.&quot;
                    )
                # Convert column indices from projection to 'column_1', 'column_2', ... column names.
                current_columns = [
                    f&quot;column_{column_idx + 1}&quot; for column_idx in projection
                ]
            else:
                # Generate autogenerated 'column_1', 'column_2', ... column names for new column names.
                current_columns = [
                    f&quot;column_{column_idx}&quot;
                    for column_idx in range(1, len(new_columns) + 1)
                ]
        else:
            # When a header is present, column names are not known yet.

            if len(dtype) &lt;= len(new_columns):
                # If dtype dictionary contains less or same amount of values than new column names
                # a list of dtypes can be created if all listed column names in dtype dictionary
                # appear in the first consecutive new column names.
                dtype_list = [
                    dtype[new_column_name]
                    for new_column_name in new_columns[0 : len(dtype)]
                    if new_column_name in dtype
                ]

                if len(dtype_list) == len(dtype):
                    dtype = dtype_list

        if current_columns and isinstance(dtype, dict):
            new_to_current = {
                new_column: current_column
                for new_column, current_column in zip(new_columns, current_columns)
            }
            # Change new column names to current column names in dtype.
            dtype = {
                new_to_current.get(column_name, column_name): column_dtype
                for column_name, column_dtype in dtype.items()
            }

    with _prepare_file_arg(file, **storage_options) as data:
        df = DataFrame.read_csv(
            file=data,
            infer_schema_length=infer_schema_length,
            batch_size=batch_size,
            has_headers=has_headers,
            ignore_errors=ignore_errors,
            stop_after_n_rows=stop_after_n_rows,
            skip_rows=skip_rows,
            projection=projection,
            sep=sep,
            columns=columns,
            rechunk=rechunk,
            encoding=encoding,
            n_threads=n_threads,
            dtype=dtype,
            low_memory=low_memory,
            comment_char=comment_char,
            quote_char=quote_char,
            null_values=null_values,
            parse_dates=parse_dates,
        )

    if new_columns:
        return update_columns(df, new_columns)
    return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioscan_csv"><a class="header" href="#polarsioscan_csv"><code>polars.io.scan_csv</code></a></h3>
<pre><code class="language-python">scan_csv(
    file: Union[str, Path], 
    infer_schema_length: Optionalint, 
    has_headers: bool, 
    ignore_errors: bool, 
    sep: str, 
    skip_rows: int, 
    stop_after_n_rows: Optionalint, 
    cache: bool, 
    dtype: OptionalDict[str, TypeDataType], 
    low_memory: bool, 
    comment_char: Optionalstr, 
    quote_char: Optionalstr, 
    null_values: OptionalUnion[str, List[str], Dict[str, str]], 
    with_column_names: OptionalCallable[[List[str]], List[str]],
) -&gt; LazyFrame:
</code></pre>
<p>Lazily read from a csv file.</p>
<p>This allows the query optimizer to push down predicates and projections to the scan level,
thereby potentially reducing memory overhead.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>file</code>]: Path to a file.</p>
</li>
<li>
<p>[<code>infer_schema_length</code>]: The number of rows Polars will read to try to determine the schema.</p>
</li>
<li>
<p>[<code>has_headers</code>]: If the CSV file has headers or not.</p>
</li>
<li>
<p>[<code>ignore_errors</code>]: Try to keep reading lines if some lines yield errors.</p>
</li>
<li>
<p>[<code>sep</code>]: Delimiter/ value separator.</p>
</li>
<li>
<p>[<code>skip_rows</code>]: Start reading after <code>skip_rows</code>.</p>
</li>
<li>
<p>[<code>stop_after_n_rows</code>]: After n rows are read from the CSV, it stops reading.
During multi-threaded parsing, an upper bound of <code>n</code> rows cannot be guaranteed.</p>
</li>
<li>
<p>[<code>cache</code>]: Cache the result after reading.</p>
</li>
<li>
<p>[<code>dtype</code>]: Overwrite the dtypes during inference.</p>
</li>
<li>
<p>[<code>low_memory</code>]: Reduce memory usage in expense of performance.</p>
</li>
<li>
<p>[<code>comment_char</code>]: character that indicates the start of a comment line, for instance '#'.</p>
</li>
<li>
<p>[<code>quote_char</code>]: single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
of quotes off.</p>
</li>
<li>
<p>[<code>null_values</code>]: Values to interpret as null values. You can provide a:</p>
<ul>
<li>str -&gt; all values encountered equal to this string will be null</li>
<li>List[str] -&gt; A null value per column.</li>
<li>Dict[str, str] -&gt; A dictionary that maps column name to a null value string.</li>
</ul>
</li>
<li>
<p>[<code>with_column_names</code>]: Apply a function over the column names. This can be used to update a schema just in time, thus before scanning.</p>
</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>(pl.scan_csv(&quot;my_long_file.csv&quot;)  # lazy, doesn't do a thing
.select([&quot;a&quot;, &quot;c&quot;])              # select only 2 columns (other columns will not be read)
.filter(pl.col(&quot;a&quot;) &gt; 10)        # the filter is pushed down the the scan, so less data read in memory
.fetch(100)                      # pushed a limit of 100 rows to the scan level
)</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="we-can-use-with_column_names-to-modify-the-header-before-scanning"><a class="header" href="#we-can-use-with_column_names-to-modify-the-header-before-scanning">we can use <code>with_column_names</code> to modify the header before scanning</a></h1>
<p>df = pl.DataFrame({
&quot;BrEeZaH&quot;: [1, 2, 3, 4],
&quot;LaNgUaGe&quot;: [&quot;is&quot;, &quot;terrible&quot;, &quot;to&quot;, &quot;read&quot;]
})
df.to_csv(&quot;mydf.csv&quot;)
(pl.scan_csv(&quot;mydf.csv&quot;,
with_column_names=lambda cols: [col.lower() for col in cols])
.fetch()
)
shape: (4, 2)
┌─────────┬──────────┐
│ breezah ┆ language │
│ ---     ┆ ---      │
│ i64     ┆ str      │
╞═════════╪══════════╡
│ 1       ┆ is       │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2       ┆ terrible │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3       ┆ to       │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4       ┆ read     │
└─────────┴──────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def scan_csv(
    file: Union[str, Path],
    infer_schema_length: Optional[int] = 100,
    has_headers: bool = True,
    ignore_errors: bool = False,
    sep: str = &quot;,&quot;,
    skip_rows: int = 0,
    stop_after_n_rows: Optional[int] = None,
    cache: bool = True,
    dtype: Optional[Dict[str, Type[DataType]]] = None,
    low_memory: bool = False,
    comment_char: Optional[str] = None,
    quote_char: Optional[str] = r'&quot;',
    null_values: Optional[Union[str, List[str], Dict[str, str]]] = None,
    with_column_names: Optional[Callable[[List[str]], List[str]]] = None,
) -&gt; LazyFrame:
    &quot;&quot;&quot;
    Lazily read from a csv file.

    This allows the query optimizer to push down predicates and projections to the scan level,
    thereby potentially reducing memory overhead.

    Parameters
    ----------
    file
        Path to a file.
    infer_schema_length
        The number of rows Polars will read to try to determine the schema.
    has_headers
        If the CSV file has headers or not.
    ignore_errors
        Try to keep reading lines if some lines yield errors.
    sep
        Delimiter/ value separator.
    skip_rows
        Start reading after `skip_rows`.
    stop_after_n_rows
        After n rows are read from the CSV, it stops reading.
        During multi-threaded parsing, an upper bound of `n` rows cannot be guaranteed.
    cache
        Cache the result after reading.
    dtype
        Overwrite the dtypes during inference.
    low_memory
        Reduce memory usage in expense of performance.
    comment_char
        character that indicates the start of a comment line, for instance '#'.
    quote_char
        single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
        of quotes off.
    null_values
        Values to interpret as null values. You can provide a:

        - str -&gt; all values encountered equal to this string will be null
        - List[str] -&gt; A null value per column.
        - Dict[str, str] -&gt; A dictionary that maps column name to a null value string.
    with_column_names
        Apply a function over the column names. This can be used to update a schema just in time, thus before scanning.


    Examples
    --------
    &gt;&gt;&gt; (pl.scan_csv(&quot;my_long_file.csv&quot;)  # lazy, doesn't do a thing
    &gt;&gt;&gt;  .select([&quot;a&quot;, &quot;c&quot;])              # select only 2 columns (other columns will not be read)
    &gt;&gt;&gt;  .filter(pl.col(&quot;a&quot;) &gt; 10)        # the filter is pushed down the the scan, so less data read in memory
    &gt;&gt;&gt;  .fetch(100)                      # pushed a limit of 100 rows to the scan level
    &gt;&gt;&gt;  )

    &gt;&gt;&gt; # we can use `with_column_names` to modify the header before scanning
    &gt;&gt;&gt; df = pl.DataFrame({
    &gt;&gt;&gt;     &quot;BrEeZaH&quot;: [1, 2, 3, 4],
    &gt;&gt;&gt;     &quot;LaNgUaGe&quot;: [&quot;is&quot;, &quot;terrible&quot;, &quot;to&quot;, &quot;read&quot;]
    &gt;&gt;&gt; })
    &gt;&gt;&gt; df.to_csv(&quot;mydf.csv&quot;)
    &gt;&gt;&gt; (pl.scan_csv(&quot;mydf.csv&quot;,
    &gt;&gt;&gt;     with_column_names=lambda cols: [col.lower() for col in cols])
    &gt;&gt;&gt; .fetch()
    &gt;&gt;&gt; )
    shape: (4, 2)
    ┌─────────┬──────────┐
    │ breezah ┆ language │
    │ ---     ┆ ---      │
    │ i64     ┆ str      │
    ╞═════════╪══════════╡
    │ 1       ┆ is       │
    ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
    │ 2       ┆ terrible │
    ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
    │ 3       ┆ to       │
    ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
    │ 4       ┆ read     │
    └─────────┴──────────┘


    &quot;&quot;&quot;
    if isinstance(file, Path):
        file = str(file)
    return LazyFrame.scan_csv(
        file=file,
        has_headers=has_headers,
        sep=sep,
        ignore_errors=ignore_errors,
        skip_rows=skip_rows,
        stop_after_n_rows=stop_after_n_rows,
        cache=cache,
        dtype=dtype,
        low_memory=low_memory,
        comment_char=comment_char,
        quote_char=quote_char,
        null_values=null_values,
        infer_schema_length=infer_schema_length,
        with_column_names=with_column_names,
    )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioscan_ipc"><a class="header" href="#polarsioscan_ipc"><code>polars.io.scan_ipc</code></a></h3>
<pre><code class="language-python">scan_ipc(
    file: Union[str, Path], 
    stop_after_n_rows: Optionalint, 
    cache: bool,
) -&gt; LazyFrame:
</code></pre>
<p>Lazily read from an IPC file.</p>
<p>This allows the query optimizer to push down predicates and projections to the scan level,
thereby potentially reducing memory overhead.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file.</li>
<li>[<code>stop_after_n_rows</code>]: After n rows are read from the parquet, it stops reading.</li>
<li>[<code>cache</code>]: Cache the result after reading.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def scan_ipc(
    file: Union[str, Path],
    stop_after_n_rows: Optional[int] = None,
    cache: bool = True,
) -&gt; LazyFrame:
    &quot;&quot;&quot;
    Lazily read from an IPC file.

    This allows the query optimizer to push down predicates and projections to the scan level,
    thereby potentially reducing memory overhead.

    Parameters
    ----------
    file
        Path to a file.
    stop_after_n_rows
        After n rows are read from the parquet, it stops reading.
    cache
        Cache the result after reading.
    &quot;&quot;&quot;
    if isinstance(file, Path):
        file = str(file)
    return LazyFrame.scan_ipc(
        file=file, stop_after_n_rows=stop_after_n_rows, cache=cache
    )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioscan_parquet"><a class="header" href="#polarsioscan_parquet"><code>polars.io.scan_parquet</code></a></h3>
<pre><code class="language-python">scan_parquet(
    file: Union[str, Path], 
    stop_after_n_rows: Optionalint, 
    cache: bool,
) -&gt; LazyFrame:
</code></pre>
<p>Lazily read from a parquet file.</p>
<p>This allows the query optimizer to push down predicates and projections to the scan level,
thereby potentially reducing memory overhead.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file.</li>
<li>[<code>stop_after_n_rows</code>]: After n rows are read from the parquet, it stops reading.</li>
<li>[<code>cache</code>]: Cache the result after reading.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def scan_parquet(
    file: Union[str, Path],
    stop_after_n_rows: Optional[int] = None,
    cache: bool = True,
) -&gt; LazyFrame:
    &quot;&quot;&quot;
    Lazily read from a parquet file.

    This allows the query optimizer to push down predicates and projections to the scan level,
    thereby potentially reducing memory overhead.

    Parameters
    ----------
    file
        Path to a file.
    stop_after_n_rows
        After n rows are read from the parquet, it stops reading.
    cache
        Cache the result after reading.
    &quot;&quot;&quot;
    if isinstance(file, Path):
        file = str(file)
    return LazyFrame.scan_parquet(
        file=file, stop_after_n_rows=stop_after_n_rows, cache=cache
    )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioread_ipc_schema"><a class="header" href="#polarsioread_ipc_schema"><code>polars.io.read_ipc_schema</code></a></h3>
<pre><code class="language-python">read_ipc_schema(
    file: Union[str, BinaryIO, Path, bytes],
) -&gt; Dict[str, TypeDataType]:
</code></pre>
<p>Get a schema of the IPC file without reading data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Dictionary mapping column names to datatypes</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def read_ipc_schema(
    file: Union[str, BinaryIO, Path, bytes]
) -&gt; Dict[str, Type[DataType]]:
    &quot;&quot;&quot;
    Get a schema of the IPC file without reading data.

    Parameters
    ----------
    file
        Path to a file or a file like object.


    Returns
    -------
    Dictionary mapping column names to datatypes
    &quot;&quot;&quot;
    return _ipc_schema(file)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioread_ipc"><a class="header" href="#polarsioread_ipc"><code>polars.io.read_ipc</code></a></h3>
<pre><code class="language-python">read_ipc(
    file: Union[str, BinaryIO, BytesIO, Path, bytes], 
    columns: OptionalList[str], 
    projection: OptionalList[int], 
    stop_after_n_rows: Optionalint, 
    use_pyarrow: bool, 
    memory_map: bool, 
    storage_options: OptionalDict,
) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object.
If <code>fsspec</code> is installed, it will be used to open remote files</li>
<li>[<code>columns</code>]: Columns to select.</li>
<li>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</li>
<li>[<code>stop_after_n_rows</code>]: Only read specified number of rows of the dataset. After <code>n</code> stops reading.</li>
<li>[<code>use_pyarrow</code>]: Use pyarrow or the native rust reader.</li>
<li>[<code>memory_map</code>]: Memory map underlying file. This will likely increase performance.
Only used when 'use_pyarrow=True'</li>
<li>[<code>storage_options</code>]: Extra options that make sense for <code>fsspec.open()</code> or a particular storage connection, e.g. host, port, username, password, etc.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def read_ipc(
    file: Union[str, BinaryIO, BytesIO, Path, bytes],
    columns: Optional[List[str]] = None,
    projection: Optional[List[int]] = None,
    stop_after_n_rows: Optional[int] = None,
    use_pyarrow: bool = _PYARROW_AVAILABLE,
    memory_map: bool = True,
    storage_options: Optional[Dict] = None,
) -&gt; DataFrame:
    &quot;&quot;&quot;
    Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.

    Parameters
    ----------
    file
        Path to a file or a file like object.
        If ``fsspec`` is installed, it will be used to open remote files
    columns
        Columns to select.
    projection
        Indices of columns to select. Note that column indices start at zero.
    stop_after_n_rows
        Only read specified number of rows of the dataset. After `n` stops reading.
    use_pyarrow
        Use pyarrow or the native rust reader.
    memory_map
        Memory map underlying file. This will likely increase performance.
        Only used when 'use_pyarrow=True'
    storage_options
        Extra options that make sense for ``fsspec.open()`` or a particular storage connection, e.g. host, port, username, password, etc.

    Returns
    -------
    DataFrame
    &quot;&quot;&quot;
    if use_pyarrow:
        if stop_after_n_rows:
            raise ValueError(
                &quot;'stop_after_n_rows' cannot be used with 'use_pyarrow=True'.&quot;
            )

    storage_options = storage_options or {}
    with _prepare_file_arg(file, **storage_options) as data:
        if use_pyarrow:
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required when using 'read_ipc(..., use_pyarrow=True)'.&quot;
                )

            # pyarrow accepts column names or column indices.
            tbl = pa.feather.read_table(
                data, memory_map=memory_map, columns=columns if columns else projection
            )
            return DataFrame._from_arrow(tbl)

        if columns:
            # Unset projection if column names where specified.
            projection = None

        return DataFrame.read_ipc(
            data,
            columns=columns,
            projection=projection,
            stop_after_n_rows=stop_after_n_rows,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioread_parquet"><a class="header" href="#polarsioread_parquet"><code>polars.io.read_parquet</code></a></h3>
<pre><code class="language-python">read_parquet(
    source: Union[str, List[str], Path, BinaryIO, BytesIO, bytes], 
    columns: OptionalList[str], 
    projection: OptionalList[int], 
    stop_after_n_rows: Optionalint, 
    use_pyarrow: bool, 
    memory_map: bool, 
    storage_options: OptionalDict, 
    **kwargs,
) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from a parquet file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>source</code>]: Path to a file, list of files, or a file like object. If the path is a directory, that directory will be used
as partition aware scan.
If <code>fsspec</code> is installed, it will be used to open remote files</li>
<li>[<code>columns</code>]: Columns to select.</li>
<li>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</li>
<li>[<code>stop_after_n_rows</code>]: After n rows are read from the parquet, it stops reading.
Only valid when 'use_pyarrow=False'</li>
<li>[<code>use_pyarrow</code>]: Use pyarrow instead of the rust native parquet reader. The pyarrow reader is more stable.</li>
<li>[<code>memory_map</code>]: Memory map underlying file. This will likely increase performance.
Only used when 'use_pyarrow=True'</li>
<li>[<code>storage_options</code>]: Extra options that make sense for <code>fsspec.open()</code> or a particular storage connection, e.g. host, port, username, password, etc.
**kwargs
kwargs for <a href="https:/arrow.apache.org/docs/python/generated/pyarrow.parquet.read_table.html">pyarrow.parquet.read_table</a></li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def read_parquet(
    source: Union[str, List[str], Path, BinaryIO, BytesIO, bytes],
    columns: Optional[List[str]] = None,
    projection: Optional[List[int]] = None,
    stop_after_n_rows: Optional[int] = None,
    use_pyarrow: bool = _PYARROW_AVAILABLE,
    memory_map: bool = True,
    storage_options: Optional[Dict] = None,
    **kwargs: Any,
) -&gt; DataFrame:
    &quot;&quot;&quot;
    Read into a DataFrame from a parquet file.

    Parameters
    ----------
    source
        Path to a file, list of files, or a file like object. If the path is a directory, that directory will be used
        as partition aware scan.
        If ``fsspec`` is installed, it will be used to open remote files
    columns
        Columns to select.
    projection
        Indices of columns to select. Note that column indices start at zero.
    stop_after_n_rows
        After n rows are read from the parquet, it stops reading.
        Only valid when 'use_pyarrow=False'
    use_pyarrow
        Use pyarrow instead of the rust native parquet reader. The pyarrow reader is more stable.
    memory_map
        Memory map underlying file. This will likely increase performance.
        Only used when 'use_pyarrow=True'
    storage_options
        Extra options that make sense for ``fsspec.open()`` or a particular storage connection, e.g. host, port, username, password, etc.
    **kwargs
        kwargs for [pyarrow.parquet.read_table](https://arrow.apache.org/docs/python/generated/pyarrow.parquet.read_table.html)

    Returns
    -------
    DataFrame
    &quot;&quot;&quot;
    if use_pyarrow:
        if stop_after_n_rows:
            raise ValueError(
                &quot;'stop_after_n_rows' cannot be used with 'use_pyarrow=True'.&quot;
            )

    storage_options = storage_options or {}
    with _prepare_file_arg(source, **storage_options) as source_prep:
        if use_pyarrow:
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required when using 'read_parquet(..., use_pyarrow=True)'.&quot;
                )

            # pyarrow accepts column names or column indices.
            return from_arrow(  # type: ignore[return-value]
                pa.parquet.read_table(
                    source_prep,
                    memory_map=memory_map,
                    columns=columns if columns else projection,
                    **kwargs,
                )
            )

        if columns:
            # Unset projection if column names where specified.
            projection = None

        return DataFrame.read_parquet(
            source_prep,
            columns=columns,
            projection=projection,
            stop_after_n_rows=stop_after_n_rows,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioread_json"><a class="header" href="#polarsioread_json"><code>polars.io.read_json</code></a></h3>
<pre><code class="language-python">read_json(source: Union[str, BytesIO]) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from JSON format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>source</code>]: Path to a file or a file like object.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def read_json(source: Union[str, BytesIO]) -&gt; DataFrame:
    &quot;&quot;&quot;
    Read into a DataFrame from JSON format.

    Parameters
    ----------
    source
        Path to a file or a file like object.
    &quot;&quot;&quot;
    return DataFrame.read_json(source)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsioread_sql"><a class="header" href="#polarsioread_sql"><code>polars.io.read_sql</code></a></h3>
<pre><code class="language-python">read_sql(
    sql: Union[List[str], str], 
    connection_uri: str, 
    partition_on: Optionalstr, 
    partition_range: OptionalTuple[int, int], 
    partition_num: Optionalint,
) -&gt; DataFrame:
</code></pre>
<p>Read a SQL query into a DataFrame
Make sure to install connextorx&gt;=0.2</p>
<p><strong>Sources:</strong></p>
<p>Supports reading a sql query from the following data sources:</p>
<ul>
<li>Postgres</li>
<li>Mysql</li>
<li>Sqlite</li>
<li>Redshift (through postgres protocol)</li>
<li>Clickhouse (through mysql protocol)</li>
</ul>
<h2 id="source-not-supported"><a class="header" href="#source-not-supported">Source not supported?</a></h2>
<p>If a database source is not supported, pandas can be used to load the query:</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.from_pandas(pd.read_sql(sql, engine))</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>sql</code>]: raw sql query</li>
<li>[<code>connection_uri</code>]: connectorx connection uri:
- &quot;postgresql:/username:password@server:port/database&quot;</li>
<li>[<code>partition_on</code>]: the column to partition the result.</li>
<li>[<code>partition_range</code>]: the value range of the partition column.</li>
<li>[<code>partition_num</code>]: how many partition to generate.</li>
</ul>
<p><strong>Examples:</strong></p>
<h2 id="single-threaded"><a class="header" href="#single-threaded">Single threaded</a></h2>
<p>Read a DataFrame from a SQL using a single thread:</p>
<blockquote>
<blockquote>
<blockquote>
<p>uri = &quot;postgresql:/username:password@server:port/database&quot;
query = &quot;SELECT * FROM lineitem&quot;
pl.read_sql(query, uri)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="using-10-threads"><a class="header" href="#using-10-threads">Using 10 threads</a></h2>
<p>Read a DataFrame parallelly using 10 threads by automatically partitioning the provided SQL on the partition column:</p>
<blockquote>
<blockquote>
<blockquote>
<p>uri = &quot;postgresql:/username:password@server:port/database&quot;
query = &quot;SELECT * FROM lineitem&quot;
read_sql(query, uri, partition_on=&quot;partition_col&quot;, partition_num=10)</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="using"><a class="header" href="#using">Using</a></h2>
<p>Read a DataFrame parallel using 2 threads by manually providing two partition SQLs:</p>
<blockquote>
<blockquote>
<blockquote>
<p>uri = &quot;postgresql:/username:password@server:port/database&quot;
queries = [&quot;SELECT * FROM lineitem WHERE partition_col &lt;= 10&quot;, &quot;SELECT * FROM lineitem WHERE partition_col &gt; 10&quot;]
read_sql(uri, queries)</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def read_sql(
    sql: Union[List[str], str],
    connection_uri: str,
    partition_on: Optional[str] = None,
    partition_range: Optional[Tuple[int, int]] = None,
    partition_num: Optional[int] = None,
) -&gt; DataFrame:
    &quot;&quot;&quot;
    Read a SQL query into a DataFrame
    Make sure to install connextorx&gt;=0.2

    # Sources
    Supports reading a sql query from the following data sources:

    * Postgres
    * Mysql
    * Sqlite
    * Redshift (through postgres protocol)
    * Clickhouse (through mysql protocol)

    ## Source not supported?
    If a database source is not supported, pandas can be used to load the query:

    &gt;&gt;&gt;&gt; df = pl.from_pandas(pd.read_sql(sql, engine))

    Parameters
    ----------
    sql
        raw sql query
    connection_uri
        connectorx connection uri:
            - &quot;postgresql://username:password@server:port/database&quot;
    partition_on
      the column to partition the result.
    partition_range
      the value range of the partition column.
    partition_num
      how many partition to generate.


    Examples
    --------

    ## Single threaded
    Read a DataFrame from a SQL using a single thread:

    &gt;&gt;&gt; uri = &quot;postgresql://username:password@server:port/database&quot;
    &gt;&gt;&gt; query = &quot;SELECT * FROM lineitem&quot;
    &gt;&gt;&gt; pl.read_sql(query, uri)

    ## Using 10 threads
    Read a DataFrame parallelly using 10 threads by automatically partitioning the provided SQL on the partition column:

    &gt;&gt;&gt; uri = &quot;postgresql://username:password@server:port/database&quot;
    &gt;&gt;&gt; query = &quot;SELECT * FROM lineitem&quot;
    &gt;&gt;&gt; read_sql(query, uri, partition_on=&quot;partition_col&quot;, partition_num=10)

    ## Using
    Read a DataFrame parallel using 2 threads by manually providing two partition SQLs:

    &gt;&gt;&gt; uri = &quot;postgresql://username:password@server:port/database&quot;
    &gt;&gt;&gt; queries = [&quot;SELECT * FROM lineitem WHERE partition_col &lt;= 10&quot;, &quot;SELECT * FROM lineitem WHERE partition_col &gt; 10&quot;]
    &gt;&gt;&gt; read_sql(uri, queries)

    &quot;&quot;&quot;
    if _WITH_CX:
        tbl = cx.read_sql(
            conn=connection_uri,
            query=sql,
            return_type=&quot;arrow&quot;,
            partition_on=partition_on,
            partition_range=partition_range,
            partition_num=partition_num,
        )
        return from_arrow(tbl)  # type: ignore[return-value]
    else:
        raise ImportError(
            &quot;connectorx is not installed.&quot; &quot;Please run pip install connectorx&gt;=0.2.0a3&quot;
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarsstring_cache"><a class="header" href="#module-polarsstring_cache">Module <code>polars.string_cache</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/string_cache.html#polarsstring_cachetoggle_string_cache"><code>toggle_string_cache()</code></a>: Turn on/off the global string cache. This ensures that casts to Categorical types have the categories when string</li>
</ul>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsstring_cachetoggle_string_cache"><a class="header" href="#polarsstring_cachetoggle_string_cache"><code>polars.string_cache.toggle_string_cache</code></a></h3>
<pre><code class="language-python">toggle_string_cache(toggle: bool) -&gt; None:
</code></pre>
<p>Turn on/off the global string cache. This ensures that casts to Categorical types have the categories when string
values are equal.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def toggle_string_cache(toggle: bool) -&gt; None:
    &quot;&quot;&quot;
    Turn on/off the global string cache. This ensures that casts to Categorical types have the categories when string
    values are equal.
    &quot;&quot;&quot;
    pytoggle_string_cache(toggle)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="polarsstring_cachestringcache"><a class="header" href="#polarsstring_cachestringcache"><code>polars.string_cache.StringCache</code></a></h1>
<p>Context manager that allows data sources to share the same categorical features.
This will temporarily cache the string categories until the context manager is finished.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class StringCache:
    &quot;&quot;&quot;
    Context manager that allows data sources to share the same categorical features.
    This will temporarily cache the string categories until the context manager is finished.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        pass

    def __enter__(self) -&gt; &quot;StringCache&quot;:
        pytoggle_string_cache(True)
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -&gt; None:
        pytoggle_string_cache(False)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor-19"><a class="header" href="#constructor-19">Constructor</a></h2>
<pre><code class="language-python">StringCache()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self) -&gt; None:
        pass
</code></pre>
<p>
</details>
</raw><div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="module-polarstesting"><a class="header" href="#module-polarstesting">Module <code>polars.testing</code></a></h1>
<p><strong>Functions:</strong></p>
<ul>
<li><a href="polars/testing.html#polarstestingassert_series_equal"><code>assert_series_equal()</code></a>: </li>
<li><a href="polars/testing.html#polarstestingraise_assert_detail"><code>raise_assert_detail()</code></a>: </li>
</ul>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarstestingassert_series_equal"><a class="header" href="#polarstestingassert_series_equal"><code>polars.testing.assert_series_equal</code></a></h3>
<pre><code class="language-python">assert_series_equal(
    left: Series, 
    right: Series, 
    check_dtype: bool, 
    check_names: bool, 
    check_exact: bool, 
    rtol: float, 
    atol: float,
) -&gt; None:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def assert_series_equal(
    left: Series,
    right: Series,
    check_dtype: bool = True,
    check_names: bool = True,
    check_exact: bool = False,
    rtol: float = 1.0e-5,
    atol: float = 1.0e-8,
) -&gt; None:
    obj = &quot;Series&quot;
    try:
        can_be_subtracted = hasattr(dtype_to_py_type(left.dtype), &quot;__sub__&quot;)
    except NotImplementedError:
        can_be_subtracted = False

    check_exact = check_exact or not can_be_subtracted or left.dtype == Boolean
    if not (isinstance(left, Series) and isinstance(right, Series)):
        raise_assert_detail(obj, &quot;Type mismatch&quot;, type(left), type(right))

    if left.shape != right.shape:
        raise_assert_detail(obj, &quot;Shape mismatch&quot;, left.shape, right.shape)

    if check_dtype:
        if left.dtype != right.dtype:
            raise_assert_detail(obj, &quot;Dtype mismatch&quot;, left.dtype, right.dtype)

    if check_names:
        if left.name != right.name:
            raise_assert_detail(obj, &quot;Name mismatch&quot;, left.name, right.name)

    if check_exact:
        if (left != right).sum() != 0:
            raise_assert_detail(
                obj, &quot;Exact value mismatch&quot;, left=list(left), right=list(right)
            )
    else:
        if ((left - right).abs() &gt; (atol + rtol * right.abs())).sum() != 0:
            raise_assert_detail(
                obj, &quot;Value mismatch&quot;, left=list(left), right=list(right)
            )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarstestingraise_assert_detail"><a class="header" href="#polarstestingraise_assert_detail"><code>polars.testing.raise_assert_detail</code></a></h3>
<pre><code class="language-python">raise_assert_detail(
    obj: str, 
    message: str, 
    left: Any, 
    right: Any,
) -&gt; None:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">def raise_assert_detail(
    obj: str,
    message: str,
    left: Any,
    right: Any,
) -&gt; None:
    __tracebackhide__ = True

    msg = f&quot;&quot;&quot;{obj} are different

{message}&quot;&quot;&quot;

    msg += f&quot;&quot;&quot;
[left]:  {left}
[right]: {right}&quot;&quot;&quot;

    raise AssertionError(msg)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/js/index.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
