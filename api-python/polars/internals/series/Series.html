<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Series - Polars - Python Reference Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../../favicon.png">
        
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../../theme/css/style.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../../polars.html">polars</a></li><li class="chapter-item "><a href="../../../polars/cfg.html">cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/cfg/Config.html">Config</a></li></ol></li><li class="chapter-item "><a href="../../../polars/convert.html">convert</a></li><li class="chapter-item "><a href="../../../polars/datatypes.html">datatypes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/datatypes/DataType.html">DataType</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int8.html">Int8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int16.html">Int16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int32.html">Int32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int64.html">Int64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt8.html">UInt8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt16.html">UInt16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt32.html">UInt32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt64.html">UInt64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float32.html">Float32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float64.html">Float64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Boolean.html">Boolean</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Utf8.html">Utf8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/List.html">List</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date.html">Date</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Datetime.html">Datetime</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time.html">Time</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Object.html">Object</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Categorical.html">Categorical</a></li></ol></li><li class="chapter-item "><a href="../../../polars/datatypes_constructor.html">datatypes_constructor</a></li><li class="chapter-item expanded "><a href="../../../polars/internals.html">internals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/construction.html">construction</a></li><li class="chapter-item "><a href="../../../polars/internals/expr.html">expr</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/expr/Expr.html">Expr</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprListNameSpace.html">ExprListNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprStringNameSpace.html">ExprStringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprDateTimeNameSpace.html">ExprDateTimeNameSpace</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/frame/DataFrame.html">DataFrame</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/GroupBy.html">GroupBy</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/PivotOps.html">PivotOps</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/GBSelection.html">GBSelection</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/functions.html">functions</a></li><li class="chapter-item "><a href="../../../polars/internals/lazy_frame.html">lazy_frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/lazy_frame/LazyFrame.html">LazyFrame</a></li><li class="chapter-item "><a href="../../../polars/internals/lazy_frame/LazyGroupBy.html">LazyGroupBy</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/lazy_functions.html">lazy_functions</a></li><li class="chapter-item expanded "><a href="../../../polars/internals/series.html">series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../polars/internals/series/Series.html" class="active">Series</a></li><li class="chapter-item "><a href="../../../polars/internals/series/StringNameSpace.html">StringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/ListNameSpace.html">ListNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/DateTimeNameSpace.html">DateTimeNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/SeriesIter.html">SeriesIter</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/whenthen.html">whenthen</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/whenthen/WhenThenThen.html">WhenThenThen</a></li><li class="chapter-item "><a href="../../../polars/internals/whenthen/WhenThen.html">WhenThen</a></li><li class="chapter-item "><a href="../../../polars/internals/whenthen/When.html">When</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/io.html">io</a></li><li class="chapter-item "><a href="../../../polars/string_cache.html">string_cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/string_cache/StringCache.html">StringCache</a></li></ol></li><li class="chapter-item "><a href="../../../polars/testing.html">testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - Python Reference Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polarsinternalsseriesseries"><a class="header" href="#polarsinternalsseriesseries"><code>polars.internals.series.Series</code></a></h1>
<p>A Series represents a single column in a polars DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>name</code> [<code>str, default None</code>]: Name of the series. Will be used as a column name when used in a DataFrame.
When not specified, name is set to an empty string.</li>
<li><code>values</code> [<code>ArrayLike, default None</code>]: One-dimensional data in various forms. Supported are: Sequence, Series,
pyarrow Array, and numpy ndarray.</li>
<li><code>dtype</code> [<code>DataType, default None</code>]: Polars dtype of the Series data. If not specified, the dtype is inferred.</li>
<li>[<code>strict</code>]: Throw error on numeric overflow</li>
<li>[<code>nan_to_null</code>]: In case a numpy arrow is used to create this Series, indicate how to deal with np.nan</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Constructing a Series by specifying name and values positionally:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series('a', [1, 2, 3])
s
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>Notice that the dtype is automatically inferred as a polars Int64:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s.dtype
&lt;class 'polars.datatypes.Int64'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a Series with a specific dtype:</p>
<blockquote>
<blockquote>
<blockquote>
<p>s2 = pl.Series('a', [1, 2, 3], dtype=pl.Float32)
s2
shape: (3,)
Series: 'a' [f32]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>It is possible to construct a Series with values as the first positional argument.
This syntax considered an anti-pattern, but it can be useful in certain
scenarios. You must specify any other arguments through keywords.</p>
<blockquote>
<blockquote>
<blockquote>
<p>s3 = pl.Series([1, 2, 3])
s3
shape: (3,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="#polarsinternalsseriesseriesinner"><code>inner()</code></a>: </li>
<li><a href="#polarsinternalsseriesseriessqrt"><code>sqrt()</code></a>: Compute the square root of the elements</li>
<li><a href="#polarsinternalsseriesseriesdrop_nulls"><code>drop_nulls()</code></a>: Create a new Series that copies data from this Series without null values.</li>
<li><a href="#polarsinternalsseriesseriesto_frame"><code>to_frame()</code></a>: Cast this Series to a DataFrame.</li>
<li><a href="#polarsinternalsseriesseriesdtype"><code>dtype()</code></a>: Get the data type of this Series.</li>
<li><a href="#polarsinternalsseriesseriesdescribe"><code>describe()</code></a>: Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.</li>
<li><a href="#polarsinternalsseriesseriessum"><code>sum()</code></a>: Reduce this Series to the sum value.</li>
<li><a href="#polarsinternalsseriesseriesmean"><code>mean()</code></a>: Reduce this Series to the mean value.</li>
<li><a href="#polarsinternalsseriesseriesmin"><code>min()</code></a>: Get the minimal value in this Series.</li>
<li><a href="#polarsinternalsseriesseriesmax"><code>max()</code></a>: Get the maximum value in this Series.</li>
<li><a href="#polarsinternalsseriesseriesstd"><code>std()</code></a>: Get the standard deviation of this Series.</li>
<li><a href="#polarsinternalsseriesseriesvar"><code>var()</code></a>: Get variance of this Series.</li>
<li><a href="#polarsinternalsseriesseriesmedian"><code>median()</code></a>: Get the median of this Series.</li>
<li><a href="#polarsinternalsseriesseriesquantile"><code>quantile()</code></a>: Get the quantile value of this Series.</li>
<li><a href="#polarsinternalsseriesseriesto_dummies"><code>to_dummies()</code></a>: Get dummy variables.</li>
<li><a href="#polarsinternalsseriesseriesvalue_counts"><code>value_counts()</code></a>: Count the unique values in a Series.</li>
<li><a href="#polarsinternalsseriesseriesname"><code>name()</code></a>: Get the name of this Series.</li>
<li><a href="#polarsinternalsseriesseriesalias"><code>alias()</code></a>: Rename the Series</li>
<li><a href="#polarsinternalsseriesseriesrename"><code>rename()</code></a>: Rename this Series.</li>
<li><a href="#polarsinternalsseriesserieschunk_lengths"><code>chunk_lengths()</code></a>: Get the length of each individual chunk.</li>
<li><a href="#polarsinternalsseriesseriesn_chunks"><code>n_chunks()</code></a>: Get the number of chunks that this Series contains.</li>
<li><a href="#polarsinternalsseriesseriescumsum"><code>cumsum()</code></a>: Get an array with the cumulative sum computed at every element.</li>
<li><a href="#polarsinternalsseriesseriescummin"><code>cummin()</code></a>: Get an array with the cumulative min computed at every element.</li>
<li><a href="#polarsinternalsseriesseriescummax"><code>cummax()</code></a>: Get an array with the cumulative max computed at every element.</li>
<li><a href="#polarsinternalsseriesseriescumprod"><code>cumprod()</code></a>: Get an array with the cumulative product computed at every element.</li>
<li><a href="#polarsinternalsseriesserieslimit"><code>limit()</code></a>: Take n elements from this Series.</li>
<li><a href="#polarsinternalsseriesseriesslice"><code>slice()</code></a>: Get a slice of this Series.</li>
<li><a href="#polarsinternalsseriesseriesappend"><code>append()</code></a>: Append a Series to this one.</li>
<li><a href="#polarsinternalsseriesseriesfilter"><code>filter()</code></a>: Filter elements by a boolean mask.</li>
<li><a href="#polarsinternalsseriesserieshead"><code>head()</code></a>: Get first N elements as Series.</li>
<li><a href="#polarsinternalsseriesseriestail"><code>tail()</code></a>: Get last N elements as Series.</li>
<li><a href="#polarsinternalsseriesseriestake_every"><code>take_every()</code></a>: Take every nth value in the Series and return as new Series.</li>
<li><a href="#polarsinternalsseriesseriessort"><code>sort()</code></a>: Sort this Series.</li>
<li><a href="#polarsinternalsseriesseriesargsort"><code>argsort()</code></a>: Index location of the sorted variant of this Series.</li>
<li><a href="#polarsinternalsseriesseriesarg_sort"><code>arg_sort()</code></a>: ..deprecate::</li>
<li><a href="#polarsinternalsseriesseriesarg_unique"><code>arg_unique()</code></a>: Get unique index as Series.</li>
<li><a href="#polarsinternalsseriesseriesarg_min"><code>arg_min()</code></a>: Get the index of the minimal value.</li>
<li><a href="#polarsinternalsseriesseriesarg_max"><code>arg_max()</code></a>: Get the index of the maximal value.</li>
<li><a href="#polarsinternalsseriesseriesunique"><code>unique()</code></a>: Get unique elements in series.</li>
<li><a href="#polarsinternalsseriesseriestake"><code>take()</code></a>: Take values by index.</li>
<li><a href="#polarsinternalsseriesseriesnull_count"><code>null_count()</code></a>: Count the null values in this Series.</li>
<li><a href="#polarsinternalsseriesserieshas_validity"><code>has_validity()</code></a>: Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.</li>
<li><a href="#polarsinternalsseriesseriesis_null"><code>is_null()</code></a>: Get mask of null values.</li>
<li><a href="#polarsinternalsseriesseriesis_not_null"><code>is_not_null()</code></a>: Get mask of non null values.</li>
<li><a href="#polarsinternalsseriesseriesis_finite"><code>is_finite()</code></a>: Get mask of finite values if Series dtype is Float.</li>
<li><a href="#polarsinternalsseriesseriesis_infinite"><code>is_infinite()</code></a>: Get mask of infinite values if Series dtype is Float.</li>
<li><a href="#polarsinternalsseriesseriesis_nan"><code>is_nan()</code></a>: Get mask of NaN values if Series dtype is Float.</li>
<li><a href="#polarsinternalsseriesseriesis_not_nan"><code>is_not_nan()</code></a>: Get negated mask of NaN values if Series dtype is_not Float.</li>
<li><a href="#polarsinternalsseriesseriesis_in"><code>is_in()</code></a>: Check if elements of this Series are in the right Series, or List values of the right Series.</li>
<li><a href="#polarsinternalsseriesseriesarg_true"><code>arg_true()</code></a>: Get index values where Boolean Series evaluate True.</li>
<li><a href="#polarsinternalsseriesseriesis_unique"><code>is_unique()</code></a>: Get mask of all unique values.</li>
<li><a href="#polarsinternalsseriesseriesis_first"><code>is_first()</code></a>: Get a mask of the first unique value.</li>
<li><a href="#polarsinternalsseriesseriesis_duplicated"><code>is_duplicated()</code></a>: Get mask of all duplicated values.</li>
<li><a href="#polarsinternalsseriesseriesexplode"><code>explode()</code></a>: Explode a list or utf8 Series. This means that every item is expanded to a new row.</li>
<li><a href="#polarsinternalsseriesseriesseries_equal"><code>series_equal()</code></a>: Check if series is equal with another Series.</li>
<li><a href="#polarsinternalsseriesserieslen"><code>len()</code></a>: Length of this Series.</li>
<li><a href="#polarsinternalsseriesseriesshape"><code>shape()</code></a>: Shape of this Series.</li>
<li><a href="#polarsinternalsseriesseriescast"><code>cast()</code></a>: Cast between data types.</li>
<li><a href="#polarsinternalsseriesseriesto_list"><code>to_list()</code></a>: Convert this Series to a Python List. This operation clones data.</li>
<li><a href="#polarsinternalsseriesseriesrechunk"><code>rechunk()</code></a>: Create a single chunk of memory for this Series.</li>
<li><a href="#polarsinternalsseriesseriesis_numeric"><code>is_numeric()</code></a>: Check if this Series datatype is numeric.</li>
<li><a href="#polarsinternalsseriesseriesis_datetime"><code>is_datetime()</code></a>: Check if this Series datatype is a datetime.</li>
<li><a href="#polarsinternalsseriesseriesis_float"><code>is_float()</code></a>: Check if this Series has floating point numbers.</li>
<li><a href="#polarsinternalsseriesseriesis_boolean"><code>is_boolean()</code></a>: Check if this Series is a Boolean.</li>
<li><a href="#polarsinternalsseriesseriesis_utf8"><code>is_utf8()</code></a>: Checks if this Series datatype is a Utf8.</li>
<li><a href="#polarsinternalsseriesseriesview"><code>view()</code></a>: Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include</li>
<li><a href="#polarsinternalsseriesseriesto_numpy"><code>to_numpy()</code></a>: Convert this Series to numpy. This operation clones data but is completely safe.</li>
<li><a href="#polarsinternalsseriesseriesto_arrow"><code>to_arrow()</code></a>: Get the underlying Arrow Array. If the Series contains only a single chunk</li>
<li><a href="#polarsinternalsseriesseriesset"><code>set()</code></a>: Set masked values.</li>
<li><a href="#polarsinternalsseriesseriesset_at_idx"><code>set_at_idx()</code></a>: Set values at the index locations.</li>
<li><a href="#polarsinternalsseriesseriesclone"><code>clone()</code></a>: Cheap deep clones.</li>
<li><a href="#polarsinternalsseriesseriesfill_null"><code>fill_null()</code></a>: Fill null values with a filling strategy.</li>
<li><a href="#polarsinternalsseriesseriesfloor"><code>floor()</code></a>: Floor underlying floating point array to the lowest integers smaller or equal to the float value.</li>
<li><a href="#polarsinternalsseriesseriesround"><code>round()</code></a>: Round underlying floating point data by <code>decimals</code> digits.</li>
<li><a href="#polarsinternalsseriesseriesdot"><code>dot()</code></a>: Compute the dot/inner product between two Series</li>
<li><a href="#polarsinternalsseriesseriesmode"><code>mode()</code></a>: Compute the most occurring value(s). Can return multiple Values</li>
<li><a href="#polarsinternalsseriesseriessin"><code>sin()</code></a>: Compute the element-wise value for Trigonometric sine.</li>
<li><a href="#polarsinternalsseriesseriescos"><code>cos()</code></a>: Compute the element-wise value for Trigonometric cosine.</li>
<li><a href="#polarsinternalsseriesseriestan"><code>tan()</code></a>: Compute the element-wise value for Trigonometric tangent.</li>
<li><a href="#polarsinternalsseriesseriesarcsin"><code>arcsin()</code></a>: Compute the element-wise value for Trigonometric Inverse sine.</li>
<li><a href="#polarsinternalsseriesseriesarccos"><code>arccos()</code></a>: Compute the element-wise value for Trigonometric Inverse cosine.</li>
<li><a href="#polarsinternalsseriesseriesarctan"><code>arctan()</code></a>: Compute the element-wise value for Trigonometric Inverse tangent.</li>
<li><a href="#polarsinternalsseriesseriesapply"><code>apply()</code></a>: Apply a function over elements in this Series and return a new Series.</li>
<li><a href="#polarsinternalsseriesseriesshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="#polarsinternalsseriesseriesshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="#polarsinternalsseriesserieszip_with"><code>zip_with()</code></a>: Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</li>
<li><a href="#polarsinternalsseriesseriesrolling_min"><code>rolling_min()</code></a>: apply a rolling min (moving min) over the values in this array.</li>
<li><a href="#polarsinternalsseriesseriesrolling_max"><code>rolling_max()</code></a>: Apply a rolling max (moving max) over the values in this array.</li>
<li><a href="#polarsinternalsseriesseriesrolling_mean"><code>rolling_mean()</code></a>: Apply a rolling mean (moving mean) over the values in this array.</li>
<li><a href="#polarsinternalsseriesseriesrolling_sum"><code>rolling_sum()</code></a>: Apply a rolling sum (moving sum) over the values in this array.</li>
<li><a href="#polarsinternalsseriesseriesrolling_std"><code>rolling_std()</code></a>: Compute a rolling std dev</li>
<li><a href="#polarsinternalsseriesseriesrolling_var"><code>rolling_var()</code></a>: Compute a rolling variance.</li>
<li><a href="#polarsinternalsseriesseriesrolling_apply"><code>rolling_apply()</code></a>: Allows a custom rolling window function.</li>
<li><a href="#polarsinternalsseriesseriesrolling_median"><code>rolling_median()</code></a>: Compute a rolling median</li>
<li><a href="#polarsinternalsseriesseriesrolling_quantile"><code>rolling_quantile()</code></a>: Compute a rolling quantile</li>
<li><a href="#polarsinternalsseriesseriesrolling_skew"><code>rolling_skew()</code></a>: Compute a rolling skew</li>
<li><a href="#polarsinternalsseriesseriessample"><code>sample()</code></a>: Sample from this Series by setting either <code>n</code> or <code>frac</code>.</li>
<li><a href="#polarsinternalsseriesseriespeak_max"><code>peak_max()</code></a>: Get a boolean mask of the local maximum peaks.</li>
<li><a href="#polarsinternalsseriesseriespeak_min"><code>peak_min()</code></a>: Get a boolean mask of the local minimum peaks.</li>
<li><a href="#polarsinternalsseriesseriesn_unique"><code>n_unique()</code></a>: Count the number of unique values in this Series.</li>
<li><a href="#polarsinternalsseriesseriesshrink_to_fit"><code>shrink_to_fit()</code></a>: Shrink memory usage of this Series to fit the exact capacity needed to hold the data.</li>
<li><a href="#polarsinternalsseriesseriesdt"><code>dt()</code></a>: Create an object namespace of all datetime related methods.</li>
<li><a href="#polarsinternalsseriesseriesarr"><code>arr()</code></a>: Create an object namespace of all list related methods.</li>
<li><a href="#polarsinternalsseriesseriesstr"><code>str()</code></a>: Create an object namespace of all string related methods.</li>
<li><a href="#polarsinternalsseriesserieshash"><code>hash()</code></a>: Hash the Series.</li>
<li><a href="#polarsinternalsseriesseriesreinterpret"><code>reinterpret()</code></a>: Reinterpret the underlying bits as a signed/unsigned integer.</li>
<li><a href="#polarsinternalsseriesseriesinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
<li><a href="#polarsinternalsseriesseriesabs"><code>abs()</code></a>: Take absolute values</li>
<li><a href="#polarsinternalsseriesseriesrank"><code>rank()</code></a>: Assign ranks to data, dealing with ties appropriately.</li>
<li><a href="#polarsinternalsseriesseriesdiff"><code>diff()</code></a>: Calculate the n-th discrete difference.</li>
<li><a href="#polarsinternalsseriesseriesskew"><code>skew()</code></a>: Compute the sample skewness of a data set.</li>
<li><a href="#polarsinternalsseriesserieskurtosis"><code>kurtosis()</code></a>: Compute the kurtosis (Fisher or Pearson) of a dataset.</li>
<li><a href="#polarsinternalsseriesseriesclip"><code>clip()</code></a>: Clip (limit) the values in an array.</li>
<li><a href="#polarsinternalsseriesseriesstr_concat"><code>str_concat()</code></a>: Vertically concat the values in the Series to a single string value.</li>
<li><a href="#polarsinternalsseriesseriesreshape"><code>reshape()</code></a>: Reshape this Series to a flat series, shape: (len,)</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Series:
    &quot;&quot;&quot;
    A Series represents a single column in a polars DataFrame.

    Parameters
    ----------
    name : str, default None
        Name of the series. Will be used as a column name when used in a DataFrame.
        When not specified, name is set to an empty string.
    values : ArrayLike, default None
        One-dimensional data in various forms. Supported are: Sequence, Series,
        pyarrow Array, and numpy ndarray.
    dtype : DataType, default None
        Polars dtype of the Series data. If not specified, the dtype is inferred.
    strict
        Throw error on numeric overflow
    nan_to_null
        In case a numpy arrow is used to create this Series, indicate how to deal with np.nan

    Examples
    --------
    Constructing a Series by specifying name and values positionally:

    &gt;&gt;&gt; s = pl.Series('a', [1, 2, 3])
    &gt;&gt;&gt; s
    shape: (3,)
    Series: 'a' [i64]
    [
            1
            2
            3
    ]

    Notice that the dtype is automatically inferred as a polars Int64:

    &gt;&gt;&gt; s.dtype
    &lt;class 'polars.datatypes.Int64'&gt;

    Constructing a Series with a specific dtype:

    &gt;&gt;&gt; s2 = pl.Series('a', [1, 2, 3], dtype=pl.Float32)
    &gt;&gt;&gt; s2
    shape: (3,)
    Series: 'a' [f32]
    [
            1
            2
            3
    ]

    It is possible to construct a Series with values as the first positional argument.
    This syntax considered an anti-pattern, but it can be useful in certain
    scenarios. You must specify any other arguments through keywords.

    &gt;&gt;&gt; s3 = pl.Series([1, 2, 3])
    &gt;&gt;&gt; s3
    shape: (3,)
    Series: '' [i64]
    [
            1
            2
            3
    ]

    &quot;&quot;&quot;

    def __init__(
        self,
        name: Optional[Union[str, ArrayLike]] = None,
        values: Optional[ArrayLike] = None,
        dtype: Optional[Type[DataType]] = None,
        strict: bool = True,
        nan_to_null: bool = False,
    ):

        # Handle case where values are passed as the first argument
        if name is not None and not isinstance(name, str):
            if values is None:
                values = name
                name = None
            else:
                raise ValueError(&quot;Series name must be a string.&quot;)

        # TODO: Remove if-statement below once Series name is allowed to be None
        if name is None:
            name = &quot;&quot;

        if values is None:
            self._s = sequence_to_pyseries(name, [], dtype=dtype)
        elif isinstance(values, Series):
            self._s = series_to_pyseries(name, values)
        elif _PYARROW_AVAILABLE and isinstance(values, pa.Array):
            self._s = arrow_to_pyseries(name, values)
        elif isinstance(values, np.ndarray):
            self._s = numpy_to_pyseries(name, values, strict, nan_to_null)
        elif isinstance(values, Sequence):
            self._s = sequence_to_pyseries(name, values, dtype=dtype, strict=strict)
        elif _PANDAS_AVAILABLE and isinstance(values, (pd.Series, pd.DatetimeIndex)):
            self._s = pandas_to_pyseries(name, values)
        else:
            raise ValueError(&quot;Series constructor not called properly.&quot;)

    @classmethod
    def _from_pyseries(cls, pyseries: &quot;PySeries&quot;) -&gt; &quot;Series&quot;:
        series = cls.__new__(cls)
        series._s = pyseries
        return series

    @classmethod
    def _repeat(
        cls, name: str, val: Union[int, float, str, bool], n: int, dtype: Type[DataType]
    ) -&gt; &quot;Series&quot;:
        return cls._from_pyseries(PySeries.repeat(name, val, n, dtype))

    @classmethod
    def _from_arrow(cls, name: str, values: &quot;pa.Array&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Construct a Series from an Arrow Array.
        &quot;&quot;&quot;
        return cls._from_pyseries(arrow_to_pyseries(name, values))

    @classmethod
    def _from_pandas(
        cls,
        name: str,
        values: Union[&quot;pd.Series&quot;, &quot;pd.DatetimeIndex&quot;],
        nan_to_none: bool = True,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Construct a Series from a pandas Series or DatetimeIndex.
        &quot;&quot;&quot;
        return cls._from_pyseries(
            pandas_to_pyseries(name, values, nan_to_none=nan_to_none)
        )

    def inner(self) -&gt; &quot;PySeries&quot;:
        return self._s

    def __getstate__(self):  # type: ignore
        return self._s.__getstate__()

    def __setstate__(self, state):  # type: ignore
        self._s = sequence_to_pyseries(&quot;&quot;, [], Float32)
        self._s.__setstate__(state)

    def __str__(self) -&gt; str:
        return self._s.as_str()

    def __repr__(self) -&gt; str:
        return self.__str__()

    def __and__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        if not isinstance(other, Series):
            other = Series([other])
        return wrap_s(self._s.bitand(other._s))

    def __rand__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return self.__and__(other)

    def __or__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        if not isinstance(other, Series):
            other = Series([other])
        return wrap_s(self._s.bitor(other._s))

    def __ror__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return self.__or__(other)

    def __xor__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        if not isinstance(other, Series):
            other = Series([other])
        return wrap_s(self._s.bitxor(other._s))

    def __rxor__(self, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        return self.__xor__(other)

    def __eq__(self, other: Any) -&gt; &quot;Series&quot;:  # type: ignore[override]
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.eq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __ne__(self, other: Any) -&gt; &quot;Series&quot;:  # type: ignore[override]
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.neq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;neq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __gt__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.gt(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;gt_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __lt__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.lt(other._s))
        # cast other if it doesn't match
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;lt_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __ge__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.gt_eq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;gt_eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __le__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Sequence) and not isinstance(other, str):
            other = Series(&quot;&quot;, other)
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.lt_eq(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;lt_eq_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __add__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, str):
            other = Series(&quot;&quot;, [other])
        if isinstance(other, Series):
            return wrap_s(self._s.add(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;add_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __sub__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.sub(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;sub_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __truediv__(self, other: Any) -&gt; &quot;Series&quot;:
        # this branch is exactly the floordiv function without rounding the floats
        if self.is_float():
            if isinstance(other, Series):
                return Series._from_pyseries(self._s.div(other._s))

            other = maybe_cast(other, self.dtype)
            f = get_ffi_func(&quot;div_&lt;&gt;&quot;, self.dtype, self._s)
            if f is None:
                return NotImplemented
            return wrap_s(f(other))

        return self.cast(Float64) / other

    def __floordiv__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            if self.is_float():
                return Series._from_pyseries(self._s.div(other._s)).floor()
            return Series._from_pyseries(self._s.div(other._s))

        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;div_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        if self.is_float():
            return wrap_s(f(other)).floor()
        return wrap_s(f(other))

    def __mul__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.mul(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;mul_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __mod__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.rem(other._s))
        other = maybe_cast(other, self.dtype)
        f = get_ffi_func(&quot;rem_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rmod__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.rem(self._s))
        other = maybe_cast(other, self.dtype)
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;rem_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __radd__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.add(other._s))
        other = maybe_cast(other, self.dtype)
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;add_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rsub__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.sub(self._s))
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;sub_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __invert__(self) -&gt; &quot;Series&quot;:
        if self.dtype == Boolean:
            return wrap_s(self._s._not())
        return NotImplemented

    def __rtruediv__(self, other: Any) -&gt; np.ndarray:
        if self.is_float():
            self.__rfloordiv__(other)

        if isinstance(other, int):
            other = float(other)

        return self.cast(Float64).__rfloordiv__(other)  # type: ignore

    def __rfloordiv__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(other._s.div(self._s))
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;div_&lt;&gt;_rhs&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __rmul__(self, other: Any) -&gt; &quot;Series&quot;:
        if isinstance(other, Series):
            return Series._from_pyseries(self._s.mul(other._s))
        other = match_dtype(other, self.dtype)
        f = get_ffi_func(&quot;mul_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(other))

    def __pow__(self, power: float, modulo: None = None) -&gt; &quot;Series&quot;:
        return np.power(self, power)  # type: ignore

    def __neg__(self) -&gt; &quot;Series&quot;:
        return 0 - self

    def __getitem__(self, item: Any) -&gt; Any:
        if isinstance(item, int):
            if item &lt; 0:
                item = self.len() + item
            if self.dtype in (List, Date, Datetime, Object):
                f = get_ffi_func(&quot;get_&lt;&gt;&quot;, self.dtype, self._s)
                if f is None:
                    return NotImplemented
                out = f(item)
                if self.dtype == List:
                    if out is None:
                        return None
                    return wrap_s(out)
                return out

            return self._s.get_idx(item)
        # assume it is boolean mask
        if isinstance(item, Series):
            return Series._from_pyseries(self._s.filter(item._s))

        if isinstance(item, range):
            step: Optional[int]
            # maybe we can slice instead of take by indices
            if item.step != 1:
                step = item.step
            else:
                step = None
            slc = slice(item.start, item.stop, step)
            return self[slc]

        # slice
        if type(item) == slice:
            start, stop, stride = item.indices(self.len())
            out = self.slice(start, stop - start)
            if stride != 1:
                return out.take_every(stride)
            else:
                return out
        f = get_ffi_func(&quot;get_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        out = f(item)
        if self.dtype == List:
            return wrap_s(out)
        return out

    def __setitem__(self, key: Any, value: Any) -&gt; None:
        if isinstance(value, list):
            raise ValueError(&quot;cannot set with a list as value, use a primitive value&quot;)
        if isinstance(key, Series):
            if key.dtype == Boolean:
                self._s = self.set(key, value)._s
            elif key.dtype == UInt64:
                self._s = self.set_at_idx(key.cast(UInt32), value)._s
            elif key.dtype == UInt32:
                self._s = self.set_at_idx(key, value)._s
        # TODO: implement for these types without casting to series
        elif isinstance(key, (np.ndarray, list, tuple)):
            s = wrap_s(PySeries.new_u32(&quot;&quot;, np.array(key, np.uint32), True))
            self.__setitem__(s, value)
        elif isinstance(key, int):
            self.__setitem__([key], value)
        else:
            raise ValueError(f'cannot use &quot;{key}&quot; for indexing')

    def sqrt(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements

        Syntactic sugar for

        &gt;&gt;&gt; pl.Series([1, 2]) ** 0.5
        &quot;&quot;&quot;
        return self ** 0.5

    def drop_nulls(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a new Series that copies data from this Series without null values.
        &quot;&quot;&quot;
        return wrap_s(self._s.drop_nulls())

    def to_frame(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Cast this Series to a DataFrame.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; df = s.to_frame()
        &gt;&gt;&gt; df
        shape: (3, 1)
        ╭─────╮
        │ a   │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        ╰─────╯

        &gt;&gt;&gt; type(df)
        &lt;class 'polars.eager.frame.DataFrame'&gt;

        &quot;&quot;&quot;
        return pli.wrap_df(PyDataFrame([self._s]))

    @property
    def dtype(self) -&gt; Type[DataType]:
        &quot;&quot;&quot;
        Get the data type of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.dtype
        &lt;class 'polars.datatypes.Int64'&gt;

        &quot;&quot;&quot;
        return DTYPES[self._s.dtype()]

    def describe(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.

        Returns
        -------
        Dictionary with summary statistics of a Series.

        Examples
        --------
        &gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; series_num.describe()
        shape: (6, 2)
        ┌──────────────┬────────────────────┐
        │ statistic    ┆ value              │
        │ ---          ┆ ---                │
        │ str          ┆ f64                │
        ╞══════════════╪════════════════════╡
        │ &quot;min&quot;        ┆ 1                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;max&quot;        ┆ 5                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 0.0                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;mean&quot;       ┆ 3                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;std&quot;        ┆ 1.5811388300841898 │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5                  │
        └──────────────┴────────────────────┘

        &gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, None, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; series_str.describe()
        shape: (3, 2)
        ┌──────────────┬───────┐
        │ statistic    ┆ value │
        │ ---          ┆ ---   │
        │ str          ┆ i64   │
        ╞══════════════╪═══════╡
        │ &quot;unique&quot;     ┆ 4     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 1     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5     │
        └──────────────┴───────┘

        &quot;&quot;&quot;
        stats: Dict[str, Union[Optional[float], int, str]]

        if self.len() == 0:
            raise ValueError(&quot;Series must contain at least one value&quot;)
        elif self.is_numeric():
            s = self.cast(Float64)
            stats = {
                &quot;min&quot;: s.min(),
                &quot;max&quot;: s.max(),
                &quot;null_count&quot;: s.null_count(),
                &quot;mean&quot;: s.mean(),
                &quot;std&quot;: s.std(),
                &quot;count&quot;: s.len(),
            }
        elif self.is_boolean():
            stats = {
                &quot;sum&quot;: self.sum(),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_utf8():
            stats = {
                &quot;unique&quot;: len(self.unique()),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_datetime():
            # we coerce all to string, because a polars column
            # only has a single dtype and dates: datetime and count: int don't match
            stats = {
                &quot;min&quot;: str(self.dt.min()),
                &quot;max&quot;: str(self.dt.max()),
                &quot;null_count&quot;: str(self.null_count()),
                &quot;count&quot;: str(self.len()),
            }
        else:
            raise TypeError(&quot;This type is not supported&quot;)

        return pli.DataFrame(
            {&quot;statistic&quot;: list(stats.keys()), &quot;value&quot;: list(stats.values())}
        )

    def sum(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the sum value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.sum()
        6

        &quot;&quot;&quot;
        return self._s.sum()

    def mean(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the mean value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.mean()
        2.0

        &quot;&quot;&quot;
        return self._s.mean()

    def min(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the minimal value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        1

        &quot;&quot;&quot;
        return self._s.min()

    def max(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the maximum value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        3

        &quot;&quot;&quot;
        return self._s.max()

    def std(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get the standard deviation of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.std()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.std(self.drop_nulls().view(), ddof=ddof)

    def var(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get variance of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.var()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.var(self.drop_nulls().view(), ddof=ddof)

    def median(self) -&gt; float:
        &quot;&quot;&quot;
        Get the median of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.median()
        2.0

        &quot;&quot;&quot;
        return self._s.median()

    def quantile(self, quantile: float) -&gt; float:
        &quot;&quot;&quot;
        Get the quantile value of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.quantile(0.5)
        2

        &quot;&quot;&quot;
        return self._s.quantile(quantile)

    def to_dummies(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Get dummy variables.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_dummies()
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a_1 ┆ a_2 ┆ a_3 │
        │ --- ┆ --- ┆ --- │
        │ u8  ┆ u8  ┆ u8  │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 0   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 1   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 0   ┆ 1   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.to_dummies())

    def value_counts(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Count the unique values in a Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.value_counts()
        shape: (3, 2)
        ╭─────┬────────╮
        │ a   ┆ counts │
        │ --- ┆ ---    │
        │ i64 ┆ u32    │
        ╞═════╪════════╡
        │ 2   ┆ 2      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 1   ┆ 1      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 3   ┆ 1      │
        ╰─────┴────────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.value_counts())

    @property
    def name(self) -&gt; str:
        &quot;&quot;&quot;
        Get the name of this Series.
        &quot;&quot;&quot;
        return self._s.name()

    def alias(self, name: str) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Rename the Series

        Parameters
        ----------
        name
            New name

        Returns
        -------

        &quot;&quot;&quot;
        s = self.clone()
        s._s.rename(name)
        return s

    def rename(self, name: str, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Rename this Series.

        Parameters
        ----------
        name
            New name.
        in_place
            Modify the Series in-place.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.rename('b')
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.rename(name)
            return None
        else:
            return self.alias(name)

    def chunk_lengths(self) -&gt; tp.List[int]:
        &quot;&quot;&quot;
        Get the length of each individual chunk.
        &quot;&quot;&quot;
        return self._s.chunk_lengths()

    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get the number of chunks that this Series contains.
        &quot;&quot;&quot;
        return self._s.n_chunks()

    def cumsum(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumsum()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                3
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumsum(reverse))

    def cummin(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummin()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                1
                1
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummin(reverse))

    def cummax(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummax()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummax(reverse))

    def cumprod(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumprod()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumprod(reverse))

    def limit(self, num_elements: int = 10) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take n elements from this Series.

        Parameters
        ----------
        num_elements
            Amount of elements to take.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.limit(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.limit(num_elements))

    def slice(self, offset: int, length: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a slice of this Series.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.slice(1, 2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.slice(offset, length))

    def append(self, other: &quot;Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Append a Series to this one.

        Parameters
        ----------
        other
            Series to append.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.append(s2)
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
                6
        ]

        &quot;&quot;&quot;
        self._s.append(other._s)

    def filter(self, predicate: Union[&quot;Series&quot;, list]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Filter elements by a boolean mask.

        Parameters
        ----------
        predicate
            Boolean mask.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; mask = pl.Series(&quot;&quot;, [True, False, True])
        &gt;&gt;&gt; s.filter(mask)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        if isinstance(predicate, list):
            predicate = Series(&quot;&quot;, predicate)
        return wrap_s(self._s.filter(predicate._s))

    def head(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get first N elements as Series.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.head(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.head(length))

    def tail(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get last N elements as Series.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.tail(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.tail(length))

    def take_every(self, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as new Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take_every(2)
        shape: (2,)
        Series: '' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.take_every(n))

    def sort(self, in_place: bool = False, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sort this Series.

        Parameters
        ----------
        in_place
            Sort in place.
        reverse
            Reverse sort.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 3, 4, 2])
        &gt;&gt;&gt; s.sort()
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
        ]
        &gt;&gt;&gt; s.sort(reverse=True)
        shape: (4,)
        Series: 'a' [i64]
        [
                4
                3
                2
                1
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.sort_in_place(reverse)
            return self
        else:
            return wrap_s(self._s.sort(reverse))

    def argsort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [5, 3, 4, 1, 2])
        &gt;&gt;&gt; s.argsort()
        shape: (4,)
        Series: 'a' [i64]
        [
            3
            4
            1
            2
            0
        ]
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))

    def arg_sort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        ..deprecate::

        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))

    def arg_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique index as Series.
        &quot;&quot;&quot;
        return wrap_s(self._s.arg_unique())

    def arg_min(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return self._s.arg_min()

    def arg_max(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return self._s.arg_max()

    def unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique elements in series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.unique()
        shape: (3,)
        Series: 'a' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.unique())

    def take(self, indices: Union[np.ndarray, tp.List[int]]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        indices
            Index location used for selection.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take([1, 3])
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                4
        ]

        &quot;&quot;&quot;
        if isinstance(indices, list):
            indices = np.array(indices)
        return Series._from_pyseries(self._s.take(indices))

    def null_count(self) -&gt; int:
        &quot;&quot;&quot;
        Count the null values in this Series.
        &quot;&quot;&quot;
        return self._s.null_count()

    def has_validity(self) -&gt; bool:
        &quot;&quot;&quot;
        Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.
        Use this to swiftly assert a Series does not have null values.
        &quot;&quot;&quot;
        return self._s.has_validity()

    def is_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_null()
        shape: (4,)
        Series: 'is_null' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_null())

    def is_not_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of non null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_not_null()
        shape: (4,)
        Series: 'is_not_null' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_null())

    def is_finite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of finite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_finite()
        shape: (3,)
        Series: 'a' [bool]
        [
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_finite())

    def is_infinite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of infinite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_infinite()
        shape: (3,)
        Series: 'a' [bool]
        [
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_infinite())

    def is_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of NaN values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_nan())

    def is_not_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get negated mask of NaN values if Series dtype is_not Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_not_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_nan())

    def is_in(self, other: Union[&quot;Series&quot;, tp.List]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [2, 4])
        &gt;&gt;&gt; s2.is_in(s)
        shape: (2,)
        Series: 'b' [bool]
        [
                true
                false
        ]

        &quot;&quot;&quot;
        if type(other) is list:
            other = Series(&quot;&quot;, other)
        return wrap_s(self._s.is_in(other._s))  # type: ignore

    def arg_true(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get index values where Boolean Series evaluate True.

        Returns
        -------
        UInt32 Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.arg_true())

    def is_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all unique values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_unique()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_unique())

    def is_first(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_first())

    def is_duplicated(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all duplicated values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_duplicated()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_duplicated())

    def explode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series('a', [[1, 2], [3, 4], [9, 10]])
        &gt;&gt;&gt; s.explode()
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                9
                10
        ]

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_s(self._s.explode())

    def series_equal(
        self, other: &quot;Series&quot;, null_equal: bool = False, strict: bool = False
    ) -&gt; bool:
        &quot;&quot;&quot;
        Check if series is equal with another Series.

        Parameters
        ----------
        other
            Series to compare with.
        null_equal
            Consider null values as equal.
        strict
            Don't allow different numerical dtypes, e.g. comparing `pl.UInt32` with a `pl.Int64` will return `False`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.series_equal(s))
        True
        &gt;&gt;&gt; s.series_equal(s2))
        False

        &quot;&quot;&quot;
        return self._s.series_equal(other._s, null_equal, strict)

    def len(self) -&gt; int:
        &quot;&quot;&quot;
        Length of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.len()
        3

        &quot;&quot;&quot;
        return self._s.len()

    @property
    def shape(self) -&gt; Tuple[int]:
        &quot;&quot;&quot;
        Shape of this Series.
        &quot;&quot;&quot;
        return (self._s.len(),)

    def __len__(self) -&gt; int:
        return self.len()

    def cast(
        self,
        dtype: Union[Type[DataType], Type[int], Type[float], Type[str], Type[bool]],
        strict: bool = True,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        shape: (3,)
        Series: 'a' [bool]
        [
            true
            false
            true
        ]
        &gt;&gt;&gt; s.cast(pl.UInt32)
        shape: (3,)
        Series: 'a' [u32]
        [
            1
            0
            1
        ]

        &quot;&quot;&quot;
        pl_dtype = py_type_to_dtype(dtype)
        return wrap_s(self._s.cast(str(pl_dtype), strict))

    def to_list(self, use_pyarrow: bool = False) -&gt; tp.List[Optional[Any]]:
        &quot;&quot;&quot;
        Convert this Series to a Python List. This operation clones data.

        Parameters
        ----------
        use_pyarrow
            Use pyarrow for the conversion.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_list()
        [1, 2, 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'list'&gt;

        &quot;&quot;&quot;
        if use_pyarrow:
            return self.to_arrow().to_pylist()
        return self._s.to_list()

    def __iter__(self) -&gt; &quot;SeriesIter&quot;:
        return SeriesIter(self.len(), self)

    def rechunk(self, in_place: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a single chunk of memory for this Series.

        Parameters
        ----------
        in_place
            In place or not.
        &quot;&quot;&quot;
        opt_s = self._s.rechunk(in_place)
        if in_place:
            return self
        else:
            return wrap_s(opt_s)

    def is_numeric(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is numeric.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.is_numeric()
        True

        &quot;&quot;&quot;
        return self.dtype in (
            Int8,
            Int16,
            Int32,
            Int64,
            UInt8,
            UInt16,
            UInt32,
            UInt64,
            Float32,
            Float64,
        )

    def is_datetime(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is a datetime.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series([date(2021, 1, 1), date(2021, 1, 2), date(2021, 1, 3)])
        &gt;&gt;&gt; s.is_datetime()
        True

        &quot;&quot;&quot;
        return self.dtype in (Date, Datetime)

    def is_float(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series has floating point numbers.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0])
        &gt;&gt;&gt; s.is_float()
        True

        &quot;&quot;&quot;
        return self.dtype in (Float32, Float64)

    def is_boolean(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series is a Boolean.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        &gt;&gt;&gt; s.is_boolean()
        True

        &quot;&quot;&quot;
        return self.dtype is Boolean

    def is_utf8(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks if this Series datatype is a Utf8.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; s.is_utf8()
        True
        &quot;&quot;&quot;
        return self.dtype is Utf8

    def view(self, ignore_nulls: bool = False) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
        missing values. Don't use this unless you know what you are doing.

        .. warning::

            This function can lead to undefined behavior in the following cases:

            &gt;&gt;&gt; # returns a view to a piece of memory that is already dropped.
            &gt;&gt;&gt; pl.Series([1, 3, 5]).sort().view()

            &gt;&gt;&gt; # Sums invalid data that is missing.
            &gt;&gt;&gt; pl.Series([1, 2, None]).view().sum()

        &quot;&quot;&quot;
        if not ignore_nulls:
            assert not self.has_validity()

        ptr_type = dtype_to_ctype(self.dtype)
        ptr = self._s.as_single_ptr()
        array = _ptr_to_numpy(ptr, self.len(), ptr_type)
        array.setflags(write=False)
        return array

    def __array__(self, dtype=None) -&gt; np.ndarray:  # type: ignore
        return self.to_numpy().__array__(dtype)

    def __array_ufunc__(
        self, ufunc: Callable[..., Any], method: str, *inputs: Any, **kwargs: Any
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Numpy universal functions.
        &quot;&quot;&quot;
        if self._s.n_chunks() &gt; 0:
            self._s.rechunk(in_place=True)

        if method == &quot;__call__&quot;:
            args: tp.List[Union[Number, np.ndarray]] = []
            for arg in inputs:
                if isinstance(arg, Number):
                    args.append(arg)
                elif isinstance(arg, Series):
                    args.append(arg.view(ignore_nulls=True))
                else:
                    return NotImplemented

            if &quot;dtype&quot; in kwargs:
                dtype = kwargs.pop(&quot;dtype&quot;)
            else:
                dtype = self.dtype

            try:
                f = get_ffi_func(&quot;apply_ufunc_&lt;&gt;&quot;, dtype, self._s)
                if f is None:
                    return NotImplemented
                series = f(lambda out: ufunc(*args, out=out, **kwargs))
                return wrap_s(series)
            except TypeError:
                # some integer to float ufuncs do not work, try on f64
                s = self.cast(Float64)
                args[0] = s.view(ignore_nulls=True)
                f = get_ffi_func(&quot;apply_ufunc_&lt;&gt;&quot;, Float64, self._s)
                if f is None:
                    return NotImplemented
                series = f(lambda out: ufunc(*args, out=out, **kwargs))
                return wrap_s(series)

        else:
            return NotImplemented

    def to_numpy(
        self, *args: Any, zero_copy_only: bool = False, **kwargs: Any
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert this Series to numpy. This operation clones data but is completely safe.

        If you want a zero-copy view and know what you are doing, use `.view()`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_numpy()
        &gt;&gt;&gt; s
        [1 2 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'numpy.ndarray'&gt;

        Parameters
        ----------
        args
            args will be sent to pyarrow.Array.to_numpy.
        zero_copy_only
            If True, an exception will be raised if the conversion to a numpy
            array would require copying the underlying data (e.g. in presence
            of nulls, or for non-primitive types).
        kwargs
            kwargs will be sent to pyarrow.Array.to_numpy
        &quot;&quot;&quot;
        if _PYARROW_AVAILABLE:
            return self.to_arrow().to_numpy(
                *args, zero_copy_only=zero_copy_only, **kwargs
            )
        else:
            if not self.has_validity():
                return self.view(ignore_nulls=True)
            return self._s.to_numpy()

    def to_arrow(self) -&gt; &quot;pa.Array&quot;:
        &quot;&quot;&quot;
        Get the underlying Arrow Array. If the Series contains only a single chunk
        this operation is zero copy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_arrow()
        &gt;&gt;&gt; s
        [
        1,
        2,
        3
        ]
        &gt;&gt;&gt; type(s)
        &lt;class 'pyarrow.lib.Int64Array'&gt;

        &quot;&quot;&quot;
        return self._s.to_arrow()

    def set(self, filter: &quot;Series&quot;, value: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set masked values.

        Parameters
        ----------
        filter
            Boolean mask.
        value
            Value to replace the the masked values with.
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_with_mask_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(filter._s, value))

    def set_at_idx(
        self, idx: Union[&quot;Series&quot;, np.ndarray], value: Union[int, float]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set values at the index locations.

        Parameters
        ----------
        idx
            Integers representing the index locations.
        value
            replacement values.

        Returns
        -------
        New allocated Series
        &quot;&quot;&quot;

        # the set_at_idx function expects a np.array of dtype u32
        f = get_ffi_func(&quot;set_at_idx_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            raise ValueError(
                f&quot;could not find the FFI function needed to set at idx for series {self._s}&quot;
            )
        if isinstance(idx, Series):
            # make sure the dtype matches
            idx = idx.cast(UInt32)
            idx_array = idx.view()
        elif isinstance(idx, np.ndarray):
            if not idx.data.c_contiguous:
                idx_array = np.ascontiguousarray(idx, dtype=np.uint32)
            else:
                idx_array = idx
                if idx_array.dtype != np.uint32:
                    idx_array = np.array(idx_array, np.uint32)

        else:
            idx_array = np.array(idx, dtype=np.uint32)

        return wrap_s(f(idx_array, value))

    def clone(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cheap deep clones.
        &quot;&quot;&quot;
        return wrap_s(self._s.clone())

    def __copy__(self) -&gt; &quot;Series&quot;:  # type: ignore
        return self.clone()

    def __deepcopy__(self, memodict={}) -&gt; &quot;Series&quot;:  # type: ignore
        return self.clone()

    def fill_null(self, strategy: Union[str, int, &quot;pli.Expr&quot;]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Fill null values with a filling strategy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, None])
        &gt;&gt;&gt; s.fill_null('forward'))
        shape: (4,)
        Series: '' [i64]
        [
                1
                2
                3
                3
        ]
        &gt;&gt;&gt; s.fill_null('min'))
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                1
        ]

        Parameters
        ----------
        strategy

        Fill null strategy or a value
               * &quot;backward&quot;
               * &quot;forward&quot;
               * &quot;min&quot;
               * &quot;max&quot;
               * &quot;mean&quot;
               * &quot;one&quot;
               * &quot;zero&quot;
        &quot;&quot;&quot;
        if not isinstance(strategy, str):
            return self.to_frame().select(pli.col(self.name).fill_null(strategy))[
                self.name
            ]
        return wrap_s(self._s.fill_null(strategy))

    def floor(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_s(self._s.floor())

    def round(self, decimals: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.12345, 2.56789, 3.901234])
        &gt;&gt;&gt; s.round(2)
        shape: (3,)
        Series: 'a' [f64]
        [
                1.12
                2.57
                3.9
        ]

        Parameters
        ----------
        decimals
            number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_s(self._s.round(decimals))

    def dot(self, other: &quot;Series&quot;) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4.0, 5.0, 6.0])
        &gt;&gt;&gt; s.dot(s2)
        32.0

        Parameters
        ----------
        other
            Series to compute dot product with
        &quot;&quot;&quot;
        return self._s.dot(other._s)

    def mode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.mode()
        shape: (1,)
        Series: 'a' [i64]
        [
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.mode())

    def sin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.sin()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1
                1.2246467991473532e-16
        ]
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore

    def cos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.cos()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore

    def tan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.tan()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore

    def arcsin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arcsin()
        shape: (3,)
        Series: 'a' [f64]
        [
                1.5707963267948966
                0.0
                -1.5707963267948966e0
        ]
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore

    def arccos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arccos()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1.5707963267948966
                3.141592653589793
        ]
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore

    def arctan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arctan()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.7853981633974483
                0.0
                -7.853981633974483e-1
        ]
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore

    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a function over elements in this Series and return a new Series.

        If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.apply(lambda x: x + 10)
        shape: (3,)
        Series: 'a' [i64]
        [
                11
                12
                13
        ]

        Parameters
        ----------
        func
            function or lambda.
        return_dtype
            Output datatype. If none is given, the same datatype as this Series will be used.

        Returns
        -------
        Series
        &quot;&quot;&quot;
        if return_dtype is None:
            pl_return_dtype = None
        else:
            pl_return_dtype = py_type_to_dtype(return_dtype)
        return wrap_s(self._s.apply_lambda(func, pl_return_dtype))

    def shift(self, periods: int = 1) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.shift(periods=1)
        shape: (3,)
        Series: 'a' [i64]
        [
                null
                1
                2
        ]
        &gt;&gt;&gt; s.shift(periods=-1)
        shape: (3,)
        Series: 'a' [i64]
        [
                2
                3
                null
        ]

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_s(self._s.shift(periods))

    def shift_and_fill(
        self, periods: int, fill_value: Union[int, &quot;pli.Expr&quot;]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).shift_and_fill(periods, fill_value)  # type: ignore
        )[self.name]

    def zip_with(self, mask: &quot;Series&quot;, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.

        Parameters
        ----------
        mask
            Boolean Series.
        other
            Series of same type.

        Returns
        -------
        New Series
        &quot;&quot;&quot;
        return wrap_s(self._s.zip_with(mask._s, other._s))

    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_min(window_size=3)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                100
                200
                300
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_min(window_size, weights, min_periods, center))

    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_max(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                300
                400
                500
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_max(window_size, weights, min_periods, center))

    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_mean(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                150
                250
                350
                450
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_mean(window_size, weights, min_periods, center))

    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.rolling_sum(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                3
                5
                7
                9
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_sum(window_size, weights, min_periods, center))

    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_std(window_size, weights, min_periods, center))

    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_var(window_size, weights, min_periods, center))

    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.
        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum
        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function
        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;A&quot;, [1.0, 2.0, 9.0, 2.0, 13.0])
        &gt;&gt;&gt; s.rolling_apply(window_size=3, function=lambda s: s.std())
        shape: (5,)
        Series: 'A' [f64]
        [
            null
            null
            4.358898943540674
            4.041451884327381
            5.5677643628300215
        ]
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_apply(window_size, function)  # type: ignore
        )[self.name]

    def rolling_median(self, window_size: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_median(window_size)  # type: ignore
        )[self.name]

    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_quantile(window_size, quantile)  # type: ignore
        )[self.name]

    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_skew(window_size, bias)  # type: ignore
        )[self.name]

    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sample from this Series by setting either `n` or `frac`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.sample(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                5
        ]

        Parameters
        ----------
        n
            Number of samples &lt; self.len().
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            sample with replacement.
        &quot;&quot;&quot;
        if n is not None:
            return wrap_s(self._s.sample_n(n, with_replacement))
        return wrap_s(self._s.sample_frac(frac, with_replacement))

    def peak_max(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local maximum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.peak_max()
        shape: (5,)
        Series: '' [bool]
        [
                false
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_max())

    def peak_min(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local minimum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [4, 1, 3, 2, 5])
        &gt;&gt;&gt; s.peak_min()
        shape: (5,)
        Series: '' [bool]
        [
                false
                true
                false
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_min())

    def n_unique(self) -&gt; int:
        &quot;&quot;&quot;
        Count the number of unique values in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.n_unique()
        3

        &quot;&quot;&quot;
        return self._s.n_unique()

    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this Series to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._s.shrink_to_fit()
            return None
        else:
            series = self.clone()
            series._s.shrink_to_fit()
            return series

    @property
    def dt(self) -&gt; &quot;DateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return DateTimeNameSpace(self)

    @property
    def arr(self) -&gt; &quot;ListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all list related methods.
        &quot;&quot;&quot;
        return ListNameSpace(self)

    @property
    def str(self) -&gt; &quot;StringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return StringNameSpace(self)

    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `UInt64`

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.hash(k0=42)
        shape: (3,)
        Series: 'a' [u64]
        [
                18040498172617206516
                5352755651785478209
                3939059409923356085
        ]

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_s(self._s.hash(k0, k1, k2, k3))

    def reinterpret(self, signed: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_s(self._s.reinterpret(signed))

    def interpolate(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, None, None, 5])
        &gt;&gt;&gt; s.interpolate()
        shape: (5,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.interpolate())

    def abs(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_s(self._s.abs())

    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_s(self._s.rank(method))

    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_s(self._s.diff(n, null_behavior))

    def skew(self, bias: bool = True) -&gt; Optional[float]:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return self._s.skew(bias)

    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; Optional[float]:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self._s.kurtosis(fisher, bias)

    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).clip(min_val, max_val)  # type: ignore
        )[self.name]

    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; pl.Series([1, None, 2]).str_concat(&quot;-&quot;)[0]
        &quot;1-null-2&quot;

        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).str_concat(delimiter)  # type: ignore
        )[self.name]

    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reshape this Series to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Series
        &quot;&quot;&quot;
        return wrap_s(self._s.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-python">Series(name: OptionalUnion[str, ArrayLike], 
    values: OptionalArrayLike, 
    dtype: OptionalTypeDataType, 
    strict: bool, 
    nan_to_null: bool,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        name: Optional[Union[str, ArrayLike]] = None,
        values: Optional[ArrayLike] = None,
        dtype: Optional[Type[DataType]] = None,
        strict: bool = True,
        nan_to_null: bool = False,
    ):

        # Handle case where values are passed as the first argument
        if name is not None and not isinstance(name, str):
            if values is None:
                values = name
                name = None
            else:
                raise ValueError(&quot;Series name must be a string.&quot;)

        # TODO: Remove if-statement below once Series name is allowed to be None
        if name is None:
            name = &quot;&quot;

        if values is None:
            self._s = sequence_to_pyseries(name, [], dtype=dtype)
        elif isinstance(values, Series):
            self._s = series_to_pyseries(name, values)
        elif _PYARROW_AVAILABLE and isinstance(values, pa.Array):
            self._s = arrow_to_pyseries(name, values)
        elif isinstance(values, np.ndarray):
            self._s = numpy_to_pyseries(name, values, strict, nan_to_null)
        elif isinstance(values, Sequence):
            self._s = sequence_to_pyseries(name, values, dtype=dtype, strict=strict)
        elif _PANDAS_AVAILABLE and isinstance(values, (pd.Series, pd.DatetimeIndex)):
            self._s = pandas_to_pyseries(name, values)
        else:
            raise ValueError(&quot;Series constructor not called properly.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesinner"><a class="header" href="#polarsinternalsseriesseriesinner"><code>polars.internals.series.Series.inner</code></a></h3>
<pre><code class="language-python">inner() -&gt; PySeries:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def inner(self) -&gt; &quot;PySeries&quot;:
        return self._s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessqrt"><a class="header" href="#polarsinternalsseriesseriessqrt"><code>polars.internals.series.Series.sqrt</code></a></h3>
<pre><code class="language-python">sqrt() -&gt; Series:
</code></pre>
<p>Compute the square root of the elements</p>
<p>Syntactic sugar for</p>
<blockquote>
<blockquote>
<blockquote>
<p>pl.Series([1, 2]) ** 0.5</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sqrt(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements

        Syntactic sugar for

        &gt;&gt;&gt; pl.Series([1, 2]) ** 0.5
        &quot;&quot;&quot;
        return self ** 0.5
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdrop_nulls"><a class="header" href="#polarsinternalsseriesseriesdrop_nulls"><code>polars.internals.series.Series.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls() -&gt; Series:
</code></pre>
<p>Create a new Series that copies data from this Series without null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a new Series that copies data from this Series without null values.
        &quot;&quot;&quot;
        return wrap_s(self._s.drop_nulls())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_frame"><a class="header" href="#polarsinternalsseriesseriesto_frame"><code>polars.internals.series.Series.to_frame</code></a></h3>
<pre><code class="language-python">to_frame() -&gt; pli.DataFrame:
</code></pre>
<p>Cast this Series to a DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
df = s.to_frame()
df
shape: (3, 1)
╭─────╮
│ a   │
│ --- │
│ i64 │
╞═════╡
│ 1   │
├╌╌╌╌╌┤
│ 2   │
├╌╌╌╌╌┤
│ 3   │
╰─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>type(df)
&lt;class 'polars.eager.frame.DataFrame'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_frame(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Cast this Series to a DataFrame.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; df = s.to_frame()
        &gt;&gt;&gt; df
        shape: (3, 1)
        ╭─────╮
        │ a   │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        ╰─────╯

        &gt;&gt;&gt; type(df)
        &lt;class 'polars.eager.frame.DataFrame'&gt;

        &quot;&quot;&quot;
        return pli.wrap_df(PyDataFrame([self._s]))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdtype"><a class="header" href="#polarsinternalsseriesseriesdtype"><code>polars.internals.series.Series.dtype</code></a></h3>
<pre><code class="language-python">dtype() -&gt; TypeDataType:
</code></pre>
<p>Get the data type of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.dtype
&lt;class 'polars.datatypes.Int64'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dtype(self) -&gt; Type[DataType]:
        &quot;&quot;&quot;
        Get the data type of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.dtype
        &lt;class 'polars.datatypes.Int64'&gt;

        &quot;&quot;&quot;
        return DTYPES[self._s.dtype()]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdescribe"><a class="header" href="#polarsinternalsseriesseriesdescribe"><code>polars.internals.series.Series.describe</code></a></h3>
<pre><code class="language-python">describe() -&gt; pli.DataFrame:
</code></pre>
<p>Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.</p>
<p><strong>Returns:</strong></p>
<p>Dictionary with summary statistics of a Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>series_num = pl.Series([1, 2, 3, 4, 5])
series_num.describe()
shape: (6, 2)
┌──────────────┬────────────────────┐
│ statistic    ┆ value              │
│ ---          ┆ ---                │
│ str          ┆ f64                │
╞══════════════╪════════════════════╡
│ &quot;min&quot;        ┆ 1                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;max&quot;        ┆ 5                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;null_count&quot; ┆ 0.0                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;mean&quot;       ┆ 3                  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;std&quot;        ┆ 1.5811388300841898 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;count&quot;      ┆ 5                  │
└──────────────┴────────────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, None, &quot;b&quot;, &quot;c&quot;])
series_str.describe()
shape: (3, 2)
┌──────────────┬───────┐
│ statistic    ┆ value │
│ ---          ┆ ---   │
│ str          ┆ i64   │
╞══════════════╪═══════╡
│ &quot;unique&quot;     ┆ 4     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;null_count&quot; ┆ 1     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;count&quot;      ┆ 5     │
└──────────────┴───────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Quick summary statistics of a series. Series with mixed datatypes will return summary statistics for the datatype of the first value.

        Returns
        -------
        Dictionary with summary statistics of a Series.

        Examples
        --------
        &gt;&gt;&gt; series_num = pl.Series([1, 2, 3, 4, 5])
        &gt;&gt;&gt; series_num.describe()
        shape: (6, 2)
        ┌──────────────┬────────────────────┐
        │ statistic    ┆ value              │
        │ ---          ┆ ---                │
        │ str          ┆ f64                │
        ╞══════════════╪════════════════════╡
        │ &quot;min&quot;        ┆ 1                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;max&quot;        ┆ 5                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 0.0                │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;mean&quot;       ┆ 3                  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;std&quot;        ┆ 1.5811388300841898 │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5                  │
        └──────────────┴────────────────────┘

        &gt;&gt;&gt; series_str = pl.Series([&quot;a&quot;, &quot;a&quot;, None, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; series_str.describe()
        shape: (3, 2)
        ┌──────────────┬───────┐
        │ statistic    ┆ value │
        │ ---          ┆ ---   │
        │ str          ┆ i64   │
        ╞══════════════╪═══════╡
        │ &quot;unique&quot;     ┆ 4     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;null_count&quot; ┆ 1     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ &quot;count&quot;      ┆ 5     │
        └──────────────┴───────┘

        &quot;&quot;&quot;
        stats: Dict[str, Union[Optional[float], int, str]]

        if self.len() == 0:
            raise ValueError(&quot;Series must contain at least one value&quot;)
        elif self.is_numeric():
            s = self.cast(Float64)
            stats = {
                &quot;min&quot;: s.min(),
                &quot;max&quot;: s.max(),
                &quot;null_count&quot;: s.null_count(),
                &quot;mean&quot;: s.mean(),
                &quot;std&quot;: s.std(),
                &quot;count&quot;: s.len(),
            }
        elif self.is_boolean():
            stats = {
                &quot;sum&quot;: self.sum(),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_utf8():
            stats = {
                &quot;unique&quot;: len(self.unique()),
                &quot;null_count&quot;: self.null_count(),
                &quot;count&quot;: self.len(),
            }
        elif self.is_datetime():
            # we coerce all to string, because a polars column
            # only has a single dtype and dates: datetime and count: int don't match
            stats = {
                &quot;min&quot;: str(self.dt.min()),
                &quot;max&quot;: str(self.dt.max()),
                &quot;null_count&quot;: str(self.null_count()),
                &quot;count&quot;: str(self.len()),
            }
        else:
            raise TypeError(&quot;This type is not supported&quot;)

        return pli.DataFrame(
            {&quot;statistic&quot;: list(stats.keys()), &quot;value&quot;: list(stats.values())}
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessum"><a class="header" href="#polarsinternalsseriesseriessum"><code>polars.internals.series.Series.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Union[int, float]:
</code></pre>
<p>Reduce this Series to the sum value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.sum()
6</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the sum value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.sum()
        6

        &quot;&quot;&quot;
        return self._s.sum()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmean"><a class="header" href="#polarsinternalsseriesseriesmean"><code>polars.internals.series.Series.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Union[int, float]:
</code></pre>
<p>Reduce this Series to the mean value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.mean()
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Reduce this Series to the mean value.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.mean()
        2.0

        &quot;&quot;&quot;
        return self._s.mean()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmin"><a class="header" href="#polarsinternalsseriesseriesmin"><code>polars.internals.series.Series.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Union[int, float]:
</code></pre>
<p>Get the minimal value in this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.min()
1</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the minimal value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        1

        &quot;&quot;&quot;
        return self._s.min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmax"><a class="header" href="#polarsinternalsseriesseriesmax"><code>polars.internals.series.Series.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Union[int, float]:
</code></pre>
<p>Get the maximum value in this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.min()
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; Union[int, float]:
        &quot;&quot;&quot;
        Get the maximum value in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.min()
        3

        &quot;&quot;&quot;
        return self._s.max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesstd"><a class="header" href="#polarsinternalsseriesseriesstd"><code>polars.internals.series.Series.std</code></a></h3>
<pre><code class="language-python">std(ddof: int) -&gt; Optionalfloat:
</code></pre>
<p>Get the standard deviation of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ddof</code>]: “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
where N represents the number of elements.
By default ddof is 1.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.std()
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get the standard deviation of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.std()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.std(self.drop_nulls().view(), ddof=ddof)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesvar"><a class="header" href="#polarsinternalsseriesseriesvar"><code>polars.internals.series.Series.var</code></a></h3>
<pre><code class="language-python">var(ddof: int) -&gt; Optionalfloat:
</code></pre>
<p>Get variance of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>ddof</code>]: “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
where N represents the number of elements.
By default ddof is 1.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.var()
1.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self, ddof: int = 1) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Get variance of this Series.

        Parameters
        ----------
        ddof
            “Delta Degrees of Freedom”: the divisor used in the calculation is N - ddof,
            where N represents the number of elements.
            By default ddof is 1.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.var()
        1.0

        &quot;&quot;&quot;
        if not self.is_numeric():
            return None
        return np.var(self.drop_nulls().view(), ddof=ddof)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmedian"><a class="header" href="#polarsinternalsseriesseriesmedian"><code>polars.internals.series.Series.median</code></a></h3>
<pre><code class="language-python">median() -&gt; float:
</code></pre>
<p>Get the median of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.median()
2.0</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; float:
        &quot;&quot;&quot;
        Get the median of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.median()
        2.0

        &quot;&quot;&quot;
        return self._s.median()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesquantile"><a class="header" href="#polarsinternalsseriesseriesquantile"><code>polars.internals.series.Series.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; float:
</code></pre>
<p>Get the quantile value of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.quantile(0.5)
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; float:
        &quot;&quot;&quot;
        Get the quantile value of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.quantile(0.5)
        2

        &quot;&quot;&quot;
        return self._s.quantile(quantile)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_dummies"><a class="header" href="#polarsinternalsseriesseriesto_dummies"><code>polars.internals.series.Series.to_dummies</code></a></h3>
<pre><code class="language-python">to_dummies() -&gt; pli.DataFrame:
</code></pre>
<p>Get dummy variables.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_dummies()
shape: (3, 3)
╭─────┬─────┬─────╮
│ a_1 ┆ a_2 ┆ a_3 │
│ --- ┆ --- ┆ --- │
│ u8  ┆ u8  ┆ u8  │
╞═════╪═════╪═════╡
│ 1   ┆ 0   ┆ 0   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 0   ┆ 1   ┆ 0   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 0   ┆ 0   ┆ 1   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dummies(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Get dummy variables.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_dummies()
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a_1 ┆ a_2 ┆ a_3 │
        │ --- ┆ --- ┆ --- │
        │ u8  ┆ u8  ┆ u8  │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 0   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 1   ┆ 0   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 0   ┆ 0   ┆ 1   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.to_dummies())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesvalue_counts"><a class="header" href="#polarsinternalsseriesseriesvalue_counts"><code>polars.internals.series.Series.value_counts</code></a></h3>
<pre><code class="language-python">value_counts() -&gt; pli.DataFrame:
</code></pre>
<p>Count the unique values in a Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.value_counts()
shape: (3, 2)
╭─────┬────────╮
│ a   ┆ counts │
│ --- ┆ ---    │
│ i64 ┆ u32    │
╞═════╪════════╡
│ 2   ┆ 2      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1   ┆ 1      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3   ┆ 1      │
╰─────┴────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def value_counts(self) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Count the unique values in a Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.value_counts()
        shape: (3, 2)
        ╭─────┬────────╮
        │ a   ┆ counts │
        │ --- ┆ ---    │
        │ i64 ┆ u32    │
        ╞═════╪════════╡
        │ 2   ┆ 2      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 1   ┆ 1      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 3   ┆ 1      │
        ╰─────┴────────╯

        &quot;&quot;&quot;
        return pli.wrap_df(self._s.value_counts())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesname"><a class="header" href="#polarsinternalsseriesseriesname"><code>polars.internals.series.Series.name</code></a></h3>
<pre><code class="language-python">name() -&gt; str:
</code></pre>
<p>Get the name of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def name(self) -&gt; str:
        &quot;&quot;&quot;
        Get the name of this Series.
        &quot;&quot;&quot;
        return self._s.name()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesalias"><a class="header" href="#polarsinternalsseriesseriesalias"><code>polars.internals.series.Series.alias</code></a></h3>
<pre><code class="language-python">alias(name: str) -&gt; Series:
</code></pre>
<p>Rename the Series</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name</li>
</ul>
<p><strong>Returns:</strong></p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def alias(self, name: str) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Rename the Series

        Parameters
        ----------
        name
            New name

        Returns
        -------

        &quot;&quot;&quot;
        s = self.clone()
        s._s.rename(name)
        return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrename"><a class="header" href="#polarsinternalsseriesseriesrename"><code>polars.internals.series.Series.rename</code></a></h3>
<pre><code class="language-python">rename(name: str, in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Rename this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name.</li>
<li>[<code>in_place</code>]: Modify the Series in-place.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.rename('b')
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rename(self, name: str, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Rename this Series.

        Parameters
        ----------
        name
            New name.
        in_place
            Modify the Series in-place.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.rename('b')
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.rename(name)
            return None
        else:
            return self.alias(name)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieschunk_lengths"><a class="header" href="#polarsinternalsseriesserieschunk_lengths"><code>polars.internals.series.Series.chunk_lengths</code></a></h3>
<pre><code class="language-python">chunk_lengths() -&gt; tp.List[int]:
</code></pre>
<p>Get the length of each individual chunk.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def chunk_lengths(self) -&gt; tp.List[int]:
        &quot;&quot;&quot;
        Get the length of each individual chunk.
        &quot;&quot;&quot;
        return self._s.chunk_lengths()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesn_chunks"><a class="header" href="#polarsinternalsseriesseriesn_chunks"><code>polars.internals.series.Series.n_chunks</code></a></h3>
<pre><code class="language-python">n_chunks() -&gt; int:
</code></pre>
<p>Get the number of chunks that this Series contains.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get the number of chunks that this Series contains.
        &quot;&quot;&quot;
        return self._s.n_chunks()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescumsum"><a class="header" href="#polarsinternalsseriesseriescumsum"><code>polars.internals.series.Series.cumsum</code></a></h3>
<pre><code class="language-python">cumsum(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative sum computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cumsum()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  6
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumsum(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumsum()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                3
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumsum(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescummin"><a class="header" href="#polarsinternalsseriesseriescummin"><code>polars.internals.series.Series.cummin</code></a></h3>
<pre><code class="language-python">cummin(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative min computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cummin()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  1
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummin(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummin()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                1
                1
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummin(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescummax"><a class="header" href="#polarsinternalsseriesseriescummax"><code>polars.internals.series.Series.cummax</code></a></h3>
<pre><code class="language-python">cummax(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative max computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cummax()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummax(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cummax()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cummax(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescumprod"><a class="header" href="#polarsinternalsseriesseriescumprod"><code>polars.internals.series.Series.cumprod</code></a></h3>
<pre><code class="language-python">cumprod(reverse: bool) -&gt; Series:
</code></pre>
<p>Get an array with the cumulative product computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: reverse the operation.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.cumprod()
shape: (3,)
Series: 'b' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  6
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumprod(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            reverse the operation.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.cumprod()
        shape: (3,)
        Series: 'b' [i64]
        [
                1
                2
                6
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.cumprod(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieslimit"><a class="header" href="#polarsinternalsseriesserieslimit"><code>polars.internals.series.Series.limit</code></a></h3>
<pre><code class="language-python">limit(num_elements: int) -&gt; Series:
</code></pre>
<p>Take n elements from this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>num_elements</code>]: Amount of elements to take.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.limit(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def limit(self, num_elements: int = 10) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take n elements from this Series.

        Parameters
        ----------
        num_elements
            Amount of elements to take.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.limit(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.limit(num_elements))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesslice"><a class="header" href="#polarsinternalsseriesseriesslice"><code>polars.internals.series.Series.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; Series:
</code></pre>
<p>Get a slice of this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Offset index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.slice(1, 2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a slice of this Series.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.slice(1, 2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesappend"><a class="header" href="#polarsinternalsseriesseriesappend"><code>polars.internals.series.Series.append</code></a></h3>
<pre><code class="language-python">append(other: Series) -&gt; None:
</code></pre>
<p>Append a Series to this one.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to append.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
s.append(s2)
shape: (6,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def append(self, other: &quot;Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Append a Series to this one.

        Parameters
        ----------
        other
            Series to append.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.append(s2)
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
                6
        ]

        &quot;&quot;&quot;
        self._s.append(other._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesfilter"><a class="header" href="#polarsinternalsseriesseriesfilter"><code>polars.internals.series.Series.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Union[Series, list]) -&gt; Series:
</code></pre>
<p>Filter elements by a boolean mask.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean mask.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
mask = pl.Series(&quot;&quot;, [True, False, True])
s.filter(mask)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: Union[&quot;Series&quot;, list]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Filter elements by a boolean mask.

        Parameters
        ----------
        predicate
            Boolean mask.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; mask = pl.Series(&quot;&quot;, [True, False, True])
        &gt;&gt;&gt; s.filter(mask)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        if isinstance(predicate, list):
            predicate = Series(&quot;&quot;, predicate)
        return wrap_s(self._s.filter(predicate._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieshead"><a class="header" href="#polarsinternalsseriesserieshead"><code>polars.internals.series.Series.head</code></a></h3>
<pre><code class="language-python">head(length: Optionalint) -&gt; Series:
</code></pre>
<p>Get first N elements as Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the head.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.head(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get first N elements as Series.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.head(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.head(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestail"><a class="header" href="#polarsinternalsseriesseriestail"><code>polars.internals.series.Series.tail</code></a></h3>
<pre><code class="language-python">tail(length: Optionalint) -&gt; Series:
</code></pre>
<p>Get last N elements as Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the tail.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.tail(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, length: Optional[int] = None) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get last N elements as Series.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.tail(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.tail(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestake_every"><a class="header" href="#polarsinternalsseriesseriestake_every"><code>polars.internals.series.Series.take_every</code></a></h3>
<pre><code class="language-python">take_every(n: int) -&gt; Series:
</code></pre>
<p>Take every nth value in the Series and return as new Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
s.take_every(2)
shape: (2,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take_every(self, n: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as new Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take_every(2)
        shape: (2,)
        Series: '' [i64]
        [
                1
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.take_every(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessort"><a class="header" href="#polarsinternalsseriesseriessort"><code>polars.internals.series.Series.sort</code></a></h3>
<pre><code class="language-python">sort(in_place: bool, reverse: bool) -&gt; Series:
</code></pre>
<p>Sort this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>in_place</code>]: Sort in place.</li>
<li>[<code>reverse</code>]: Reverse sort.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 3, 4, 2])
s.sort()
shape: (4,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]
&gt;&gt;&gt; s.sort(reverse=True)
shape: (4,)
Series: 'a' [i64]
[</p>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, in_place: bool = False, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sort this Series.

        Parameters
        ----------
        in_place
            Sort in place.
        reverse
            Reverse sort.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 3, 4, 2])
        &gt;&gt;&gt; s.sort()
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
        ]
        &gt;&gt;&gt; s.sort(reverse=True)
        shape: (4,)
        Series: 'a' [i64]
        [
                4
                3
                2
                1
        ]

        &quot;&quot;&quot;
        if in_place:
            self._s.sort_in_place(reverse)
            return self
        else:
            return wrap_s(self._s.sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesargsort"><a class="header" href="#polarsinternalsseriesseriesargsort"><code>polars.internals.series.Series.argsort</code></a></h3>
<pre><code class="language-python">argsort(reverse: bool) -&gt; Series:
</code></pre>
<p>Index location of the sorted variant of this Series.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>indexes</code>]: Indexes that can be used to sort this array.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [5, 3, 4, 1, 2])
s.argsort()
shape: (4,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>0
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def argsort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [5, 3, 4, 1, 2])
        &gt;&gt;&gt; s.argsort()
        shape: (4,)
        Series: 'a' [i64]
        [
            3
            4
            1
            2
            0
        ]
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_sort"><a class="header" href="#polarsinternalsseriesseriesarg_sort"><code>polars.internals.series.Series.arg_sort</code></a></h3>
<pre><code class="language-python">arg_sort(reverse: bool) -&gt; Series:
</code></pre>
<p>..deprecate::</p>
<p>Index location of the sorted variant of this Series.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>indexes</code>]: Indexes that can be used to sort this array.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_sort(self, reverse: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        ..deprecate::

        Index location of the sorted variant of this Series.

        Returns
        -------
        indexes
            Indexes that can be used to sort this array.
        &quot;&quot;&quot;
        return wrap_s(self._s.argsort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_unique"><a class="header" href="#polarsinternalsseriesseriesarg_unique"><code>polars.internals.series.Series.arg_unique</code></a></h3>
<pre><code class="language-python">arg_unique() -&gt; Series:
</code></pre>
<p>Get unique index as Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique index as Series.
        &quot;&quot;&quot;
        return wrap_s(self._s.arg_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_min"><a class="header" href="#polarsinternalsseriesseriesarg_min"><code>polars.internals.series.Series.arg_min</code></a></h3>
<pre><code class="language-python">arg_min() -&gt; Optionalint:
</code></pre>
<p>Get the index of the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_min(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return self._s.arg_min()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_max"><a class="header" href="#polarsinternalsseriesseriesarg_max"><code>polars.internals.series.Series.arg_max</code></a></h3>
<pre><code class="language-python">arg_max() -&gt; Optionalint:
</code></pre>
<p>Get the index of the maximal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_max(self) -&gt; Optional[int]:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return self._s.arg_max()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesunique"><a class="header" href="#polarsinternalsseriesseriesunique"><code>polars.internals.series.Series.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Series:
</code></pre>
<p>Get unique elements in series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.unique()
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get unique elements in series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.unique()
        shape: (3,)
        Series: 'a' [i64]
        [
                1
                2
                3
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestake"><a class="header" href="#polarsinternalsseriesseriestake"><code>polars.internals.series.Series.take</code></a></h3>
<pre><code class="language-python">take(indices: Union[np.ndarray, tp.List[int]],) -&gt; Series:
</code></pre>
<p>Take values by index.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>indices</code>]: Index location used for selection.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
s.take([1, 3])
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take(self, indices: Union[np.ndarray, tp.List[int]]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        indices
            Index location used for selection.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4])
        &gt;&gt;&gt; s.take([1, 3])
        shape: (2,)
        Series: 'a' [i64]
        [
                2
                4
        ]

        &quot;&quot;&quot;
        if isinstance(indices, list):
            indices = np.array(indices)
        return Series._from_pyseries(self._s.take(indices))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesnull_count"><a class="header" href="#polarsinternalsseriesseriesnull_count"><code>polars.internals.series.Series.null_count</code></a></h3>
<pre><code class="language-python">null_count() -&gt; int:
</code></pre>
<p>Count the null values in this Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def null_count(self) -&gt; int:
        &quot;&quot;&quot;
        Count the null values in this Series.
        &quot;&quot;&quot;
        return self._s.null_count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieshas_validity"><a class="header" href="#polarsinternalsseriesserieshas_validity"><code>polars.internals.series.Series.has_validity</code></a></h3>
<pre><code class="language-python">has_validity() -&gt; bool:
</code></pre>
<p>Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.
Use this to swiftly assert a Series does not have null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def has_validity(self) -&gt; bool:
        &quot;&quot;&quot;
        Returns True if the Series has a validity bitmask. If there is none, it means that there are no null values.
        Use this to swiftly assert a Series does not have null values.
        &quot;&quot;&quot;
        return self._s.has_validity()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_null"><a class="header" href="#polarsinternalsseriesseriesis_null"><code>polars.internals.series.Series.is_null</code></a></h3>
<pre><code class="language-python">is_null() -&gt; Series:
</code></pre>
<p>Get mask of null values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
s.is_null()
shape: (4,)
Series: 'is_null' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_null()
        shape: (4,)
        Series: 'is_null' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_not_null"><a class="header" href="#polarsinternalsseriesseriesis_not_null"><code>polars.internals.series.Series.is_not_null</code></a></h3>
<pre><code class="language-python">is_not_null() -&gt; Series:
</code></pre>
<p>Get mask of non null values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
s.is_not_null()
shape: (4,)
Series: 'is_not_null' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_null(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of non null values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, None])
        &gt;&gt;&gt; s.is_not_null()
        shape: (4,)
        Series: 'is_not_null' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_finite"><a class="header" href="#polarsinternalsseriesseriesis_finite"><code>polars.internals.series.Series.is_finite</code></a></h3>
<pre><code class="language-python">is_finite() -&gt; Series:
</code></pre>
<p>Get mask of finite values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
s.is_finite()
shape: (3,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  false
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_finite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of finite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_finite()
        shape: (3,)
        Series: 'a' [bool]
        [
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_finite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_infinite"><a class="header" href="#polarsinternalsseriesseriesis_infinite"><code>polars.internals.series.Series.is_infinite</code></a></h3>
<pre><code class="language-python">is_infinite() -&gt; Series:
</code></pre>
<p>Get mask of infinite values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
s.is_infinite()
shape: (3,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  true
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_infinite(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of infinite values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, np.inf])
        &gt;&gt;&gt; s.is_infinite()
        shape: (3,)
        Series: 'a' [bool]
        [
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_infinite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_nan"><a class="header" href="#polarsinternalsseriesseriesis_nan"><code>polars.internals.series.Series.is_nan</code></a></h3>
<pre><code class="language-python">is_nan() -&gt; Series:
</code></pre>
<p>Get mask of NaN values if Series dtype is Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
s.is_nan()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of NaN values if Series dtype is Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_not_nan"><a class="header" href="#polarsinternalsseriesseriesis_not_nan"><code>polars.internals.series.Series.is_not_nan</code></a></h3>
<pre><code class="language-python">is_not_nan() -&gt; Series:
</code></pre>
<p>Get negated mask of NaN values if Series dtype is_not Float.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
s.is_not_nan()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_nan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get negated mask of NaN values if Series dtype is_not Float.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0, np.NaN])
        &gt;&gt;&gt; s.is_not_nan()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.is_not_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_in"><a class="header" href="#polarsinternalsseriesseriesis_in"><code>polars.internals.series.Series.is_in</code></a></h3>
<pre><code class="language-python">is_in(other: Union[Series, tp.List]) -&gt; Series:
</code></pre>
<p>Check if elements of this Series are in the right Series, or List values of the right Series.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [2, 4])
s2.is_in(s)
shape: (2,)
Series: 'b' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_in(self, other: Union[&quot;Series&quot;, tp.List]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [2, 4])
        &gt;&gt;&gt; s2.is_in(s)
        shape: (2,)
        Series: 'b' [bool]
        [
                true
                false
        ]

        &quot;&quot;&quot;
        if type(other) is list:
            other = Series(&quot;&quot;, other)
        return wrap_s(self._s.is_in(other._s))  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarg_true"><a class="header" href="#polarsinternalsseriesseriesarg_true"><code>polars.internals.series.Series.arg_true</code></a></h3>
<pre><code class="language-python">arg_true() -&gt; Series:
</code></pre>
<p>Get index values where Boolean Series evaluate True.</p>
<p><strong>Returns:</strong></p>
<p>UInt32 Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_true(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get index values where Boolean Series evaluate True.

        Returns
        -------
        UInt32 Series
        &quot;&quot;&quot;
        return Series._from_pyseries(self._s.arg_true())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_unique"><a class="header" href="#polarsinternalsseriesseriesis_unique"><code>polars.internals.series.Series.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; Series:
</code></pre>
<p>Get mask of all unique values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.is_unique()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all unique values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_unique()
        shape: (4,)
        Series: 'a' [bool]
        [
                true
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_first"><a class="header" href="#polarsinternalsseriesseriesis_first"><code>polars.internals.series.Series.is_first</code></a></h3>
<pre><code class="language-python">is_first() -&gt; Series:
</code></pre>
<p>Get a mask of the first unique value.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_first(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_s(self._s.is_first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_duplicated"><a class="header" href="#polarsinternalsseriesseriesis_duplicated"><code>polars.internals.series.Series.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; Series:
</code></pre>
<p>Get mask of all duplicated values.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.is_duplicated()
shape: (4,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get mask of all duplicated values.

        Returns
        -------
        Boolean Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.is_duplicated()
        shape: (4,)
        Series: 'a' [bool]
        [
                false
                true
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesexplode"><a class="header" href="#polarsinternalsseriesseriesexplode"><code>polars.internals.series.Series.explode</code></a></h3>
<pre><code class="language-python">explode() -&gt; Series:
</code></pre>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series('a', [[1, 2], [3, 4], [9, 10]])
s.explode()
shape: (6,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>]</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series('a', [[1, 2], [3, 4], [9, 10]])
        &gt;&gt;&gt; s.explode()
        shape: (6,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                9
                10
        ]

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_s(self._s.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesseries_equal"><a class="header" href="#polarsinternalsseriesseriesseries_equal"><code>polars.internals.series.Series.series_equal</code></a></h3>
<pre><code class="language-python">series_equal(other: Series, 
    null_equal: bool, 
    strict: bool,) -&gt; bool:
</code></pre>
<p>Check if series is equal with another Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to compare with.</li>
<li>[<code>null_equal</code>]: Consider null values as equal.</li>
<li>[<code>strict</code>]: Don't allow different numerical dtypes, e.g. comparing <code>pl.UInt32</code> with a <code>pl.Int64</code> will return <code>False</code>.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
s.series_equal(s))
True
s.series_equal(s2))
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def series_equal(
        self, other: &quot;Series&quot;, null_equal: bool = False, strict: bool = False
    ) -&gt; bool:
        &quot;&quot;&quot;
        Check if series is equal with another Series.

        Parameters
        ----------
        other
            Series to compare with.
        null_equal
            Consider null values as equal.
        strict
            Don't allow different numerical dtypes, e.g. comparing `pl.UInt32` with a `pl.Int64` will return `False`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4, 5, 6])
        &gt;&gt;&gt; s.series_equal(s))
        True
        &gt;&gt;&gt; s.series_equal(s2))
        False

        &quot;&quot;&quot;
        return self._s.series_equal(other._s, null_equal, strict)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieslen"><a class="header" href="#polarsinternalsseriesserieslen"><code>polars.internals.series.Series.len</code></a></h3>
<pre><code class="language-python">len() -&gt; int:
</code></pre>
<p>Length of this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.len()
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def len(self) -&gt; int:
        &quot;&quot;&quot;
        Length of this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.len()
        3

        &quot;&quot;&quot;
        return self._s.len()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshape"><a class="header" href="#polarsinternalsseriesseriesshape"><code>polars.internals.series.Series.shape</code></a></h3>
<pre><code class="language-python">shape() -&gt; Tupleint:
</code></pre>
<p>Shape of this Series.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shape(self) -&gt; Tuple[int]:
        &quot;&quot;&quot;
        Shape of this Series.
        &quot;&quot;&quot;
        return (self._s.len(),)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescast"><a class="header" href="#polarsinternalsseriesseriescast"><code>polars.internals.series.Series.cast</code></a></h3>
<pre><code class="language-python">cast(dtype: Union[TypeDataType, Typeint, Typefloat, Typestr, Typebool], 
    strict: bool,) -&gt; Series:
</code></pre>
<p>Cast between data types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dtype</code>]: DataType to cast to</li>
<li>[<code>strict</code>]: Throw an error if a cast could not be done for instance due to an overflow</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [True, False, True])
shape: (3,)
Series: 'a' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>true
]
&gt;&gt;&gt; s.cast(pl.UInt32)
shape: (3,)
Series: 'a' [u32]
[</li>
<li>1
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cast(
        self,
        dtype: Union[Type[DataType], Type[int], Type[float], Type[str], Type[bool]],
        strict: bool = True,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        shape: (3,)
        Series: 'a' [bool]
        [
            true
            false
            true
        ]
        &gt;&gt;&gt; s.cast(pl.UInt32)
        shape: (3,)
        Series: 'a' [u32]
        [
            1
            0
            1
        ]

        &quot;&quot;&quot;
        pl_dtype = py_type_to_dtype(dtype)
        return wrap_s(self._s.cast(str(pl_dtype), strict))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_list"><a class="header" href="#polarsinternalsseriesseriesto_list"><code>polars.internals.series.Series.to_list</code></a></h3>
<pre><code class="language-python">to_list(use_pyarrow: bool) -&gt; tp.List[OptionalAny]:
</code></pre>
<p>Convert this Series to a Python List. This operation clones data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>use_pyarrow</code>]: Use pyarrow for the conversion.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_list()
[1, 2, 3]
type(s)
&lt;class 'list'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_list(self, use_pyarrow: bool = False) -&gt; tp.List[Optional[Any]]:
        &quot;&quot;&quot;
        Convert this Series to a Python List. This operation clones data.

        Parameters
        ----------
        use_pyarrow
            Use pyarrow for the conversion.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_list()
        [1, 2, 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'list'&gt;

        &quot;&quot;&quot;
        if use_pyarrow:
            return self.to_arrow().to_pylist()
        return self._s.to_list()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrechunk"><a class="header" href="#polarsinternalsseriesseriesrechunk"><code>polars.internals.series.Series.rechunk</code></a></h3>
<pre><code class="language-python">rechunk(in_place: bool) -&gt; Series:
</code></pre>
<p>Create a single chunk of memory for this Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>in_place</code>]: In place or not.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rechunk(self, in_place: bool = False) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Create a single chunk of memory for this Series.

        Parameters
        ----------
        in_place
            In place or not.
        &quot;&quot;&quot;
        opt_s = self._s.rechunk(in_place)
        if in_place:
            return self
        else:
            return wrap_s(opt_s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_numeric"><a class="header" href="#polarsinternalsseriesseriesis_numeric"><code>polars.internals.series.Series.is_numeric</code></a></h3>
<pre><code class="language-python">is_numeric() -&gt; bool:
</code></pre>
<p>Check if this Series datatype is numeric.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.is_numeric()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_numeric(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is numeric.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.is_numeric()
        True

        &quot;&quot;&quot;
        return self.dtype in (
            Int8,
            Int16,
            Int32,
            Int64,
            UInt8,
            UInt16,
            UInt32,
            UInt64,
            Float32,
            Float64,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_datetime"><a class="header" href="#polarsinternalsseriesseriesis_datetime"><code>polars.internals.series.Series.is_datetime</code></a></h3>
<pre><code class="language-python">is_datetime() -&gt; bool:
</code></pre>
<p>Check if this Series datatype is a datetime.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series([date(2021, 1, 1), date(2021, 1, 2), date(2021, 1, 3)])
s.is_datetime()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_datetime(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series datatype is a datetime.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series([date(2021, 1, 1), date(2021, 1, 2), date(2021, 1, 3)])
        &gt;&gt;&gt; s.is_datetime()
        True

        &quot;&quot;&quot;
        return self.dtype in (Date, Datetime)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_float"><a class="header" href="#polarsinternalsseriesseriesis_float"><code>polars.internals.series.Series.is_float</code></a></h3>
<pre><code class="language-python">is_float() -&gt; bool:
</code></pre>
<p>Check if this Series has floating point numbers.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0])
s.is_float()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_float(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series has floating point numbers.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.0, 2.0, 3.0])
        &gt;&gt;&gt; s.is_float()
        True

        &quot;&quot;&quot;
        return self.dtype in (Float32, Float64)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_boolean"><a class="header" href="#polarsinternalsseriesseriesis_boolean"><code>polars.internals.series.Series.is_boolean</code></a></h3>
<pre><code class="language-python">is_boolean() -&gt; bool:
</code></pre>
<p>Check if this Series is a Boolean.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [True, False, True])
s.is_boolean()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_boolean(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if this Series is a Boolean.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [True, False, True])
        &gt;&gt;&gt; s.is_boolean()
        True

        &quot;&quot;&quot;
        return self.dtype is Boolean
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesis_utf8"><a class="header" href="#polarsinternalsseriesseriesis_utf8"><code>polars.internals.series.Series.is_utf8</code></a></h3>
<pre><code class="language-python">is_utf8() -&gt; bool:
</code></pre>
<p>Checks if this Series datatype is a Utf8.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
s.is_utf8()
True</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_utf8(self) -&gt; bool:
        &quot;&quot;&quot;
        Checks if this Series datatype is a Utf8.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;x&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        &gt;&gt;&gt; s.is_utf8()
        True
        &quot;&quot;&quot;
        return self.dtype is Utf8
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesview"><a class="header" href="#polarsinternalsseriesseriesview"><code>polars.internals.series.Series.view</code></a></h3>
<pre><code class="language-python">view(ignore_nulls: bool) -&gt; np.ndarray:
</code></pre>
<p>Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
missing values. Don't use this unless you know what you are doing.</p>
<p>.. warning::</p>
<pre><code>This function can lead to undefined behavior in the following cases:

&gt;&gt;&gt; # returns a view to a piece of memory that is already dropped.
&gt;&gt;&gt; pl.Series([1, 3, 5]).sort().view()

&gt;&gt;&gt; # Sums invalid data that is missing.
&gt;&gt;&gt; pl.Series([1, 2, None]).view().sum()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def view(self, ignore_nulls: bool = False) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Get a view into this Series data with a numpy array. This operation doesn't clone data, but does not include
        missing values. Don't use this unless you know what you are doing.

        .. warning::

            This function can lead to undefined behavior in the following cases:

            &gt;&gt;&gt; # returns a view to a piece of memory that is already dropped.
            &gt;&gt;&gt; pl.Series([1, 3, 5]).sort().view()

            &gt;&gt;&gt; # Sums invalid data that is missing.
            &gt;&gt;&gt; pl.Series([1, 2, None]).view().sum()

        &quot;&quot;&quot;
        if not ignore_nulls:
            assert not self.has_validity()

        ptr_type = dtype_to_ctype(self.dtype)
        ptr = self._s.as_single_ptr()
        array = _ptr_to_numpy(ptr, self.len(), ptr_type)
        array.setflags(write=False)
        return array
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_numpy"><a class="header" href="#polarsinternalsseriesseriesto_numpy"><code>polars.internals.series.Series.to_numpy</code></a></h3>
<pre><code class="language-python">to_numpy(*args, **kwargs) -&gt; np.ndarray:
</code></pre>
<p>Convert this Series to numpy. This operation clones data but is completely safe.</p>
<p>If you want a zero-copy view and know what you are doing, use <code>.view()</code>.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_numpy()
s
[1 2 3]
type(s)
&lt;class 'numpy.ndarray'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>args</code>]: args will be sent to pyarrow.Array.to_numpy.</li>
<li>[<code>zero_copy_only</code>]: If True, an exception will be raised if the conversion to a numpy
array would require copying the underlying data (e.g. in presence
of nulls, or for non-primitive types).</li>
<li>[<code>kwargs</code>]: kwargs will be sent to pyarrow.Array.to_numpy</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_numpy(
        self, *args: Any, zero_copy_only: bool = False, **kwargs: Any
    ) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert this Series to numpy. This operation clones data but is completely safe.

        If you want a zero-copy view and know what you are doing, use `.view()`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_numpy()
        &gt;&gt;&gt; s
        [1 2 3]
        &gt;&gt;&gt; type(s)
        &lt;class 'numpy.ndarray'&gt;

        Parameters
        ----------
        args
            args will be sent to pyarrow.Array.to_numpy.
        zero_copy_only
            If True, an exception will be raised if the conversion to a numpy
            array would require copying the underlying data (e.g. in presence
            of nulls, or for non-primitive types).
        kwargs
            kwargs will be sent to pyarrow.Array.to_numpy
        &quot;&quot;&quot;
        if _PYARROW_AVAILABLE:
            return self.to_arrow().to_numpy(
                *args, zero_copy_only=zero_copy_only, **kwargs
            )
        else:
            if not self.has_validity():
                return self.view(ignore_nulls=True)
            return self._s.to_numpy()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesto_arrow"><a class="header" href="#polarsinternalsseriesseriesto_arrow"><code>polars.internals.series.Series.to_arrow</code></a></h3>
<pre><code class="language-python">to_arrow() -&gt; pa.Array:
</code></pre>
<p>Get the underlying Arrow Array. If the Series contains only a single chunk
this operation is zero copy.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.to_arrow()
s
[
1,
2,
3
]
type(s)
&lt;class 'pyarrow.lib.Int64Array'&gt;</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_arrow(self) -&gt; &quot;pa.Array&quot;:
        &quot;&quot;&quot;
        Get the underlying Arrow Array. If the Series contains only a single chunk
        this operation is zero copy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.to_arrow()
        &gt;&gt;&gt; s
        [
        1,
        2,
        3
        ]
        &gt;&gt;&gt; type(s)
        &lt;class 'pyarrow.lib.Int64Array'&gt;

        &quot;&quot;&quot;
        return self._s.to_arrow()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesset"><a class="header" href="#polarsinternalsseriesseriesset"><code>polars.internals.series.Series.set</code></a></h3>
<pre><code class="language-python">set(filter: Series, 
    value: Union[int, float],) -&gt; Series:
</code></pre>
<p>Set masked values.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>filter</code>]: Boolean mask.</li>
<li>[<code>value</code>]: Value to replace the the masked values with.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set(self, filter: &quot;Series&quot;, value: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set masked values.

        Parameters
        ----------
        filter
            Boolean mask.
        value
            Value to replace the the masked values with.
        &quot;&quot;&quot;
        f = get_ffi_func(&quot;set_with_mask_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            return NotImplemented
        return wrap_s(f(filter._s, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesset_at_idx"><a class="header" href="#polarsinternalsseriesseriesset_at_idx"><code>polars.internals.series.Series.set_at_idx</code></a></h3>
<pre><code class="language-python">set_at_idx(idx: Union[Series, np.ndarray], 
    value: Union[int, float],) -&gt; Series:
</code></pre>
<p>Set values at the index locations.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>idx</code>]: Integers representing the index locations.</li>
<li>[<code>value</code>]: replacement values.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>New allocated Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def set_at_idx(
        self, idx: Union[&quot;Series&quot;, np.ndarray], value: Union[int, float]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Set values at the index locations.

        Parameters
        ----------
        idx
            Integers representing the index locations.
        value
            replacement values.

        Returns
        -------
        New allocated Series
        &quot;&quot;&quot;

        # the set_at_idx function expects a np.array of dtype u32
        f = get_ffi_func(&quot;set_at_idx_&lt;&gt;&quot;, self.dtype, self._s)
        if f is None:
            raise ValueError(
                f&quot;could not find the FFI function needed to set at idx for series {self._s}&quot;
            )
        if isinstance(idx, Series):
            # make sure the dtype matches
            idx = idx.cast(UInt32)
            idx_array = idx.view()
        elif isinstance(idx, np.ndarray):
            if not idx.data.c_contiguous:
                idx_array = np.ascontiguousarray(idx, dtype=np.uint32)
            else:
                idx_array = idx
                if idx_array.dtype != np.uint32:
                    idx_array = np.array(idx_array, np.uint32)

        else:
            idx_array = np.array(idx, dtype=np.uint32)

        return wrap_s(f(idx_array, value))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesclone"><a class="header" href="#polarsinternalsseriesseriesclone"><code>polars.internals.series.Series.clone</code></a></h3>
<pre><code class="language-python">clone() -&gt; Series:
</code></pre>
<p>Cheap deep clones.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clone(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Cheap deep clones.
        &quot;&quot;&quot;
        return wrap_s(self._s.clone())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesfill_null"><a class="header" href="#polarsinternalsseriesseriesfill_null"><code>polars.internals.series.Series.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(strategy: Union[str, int, pli.Expr],) -&gt; Series:
</code></pre>
<p>Fill null values with a filling strategy.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, None])
s.fill_null('forward'))
shape: (4,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li></li>
</ul>
<p>]
&gt;&gt;&gt; s.fill_null('min'))
shape: (4,)
Series: 'a' [i64]
[</p>
<ul>
<li></li>
<li></li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<p>strategy</p>
<ul>
<li>
<pre><code> * &quot;forward&quot;
 * &quot;min&quot;
 * &quot;max&quot;
 * &quot;mean&quot;
 * &quot;one&quot;
 * &quot;zero&quot;
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, strategy: Union[str, int, &quot;pli.Expr&quot;]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Fill null values with a filling strategy.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, None])
        &gt;&gt;&gt; s.fill_null('forward'))
        shape: (4,)
        Series: '' [i64]
        [
                1
                2
                3
                3
        ]
        &gt;&gt;&gt; s.fill_null('min'))
        shape: (4,)
        Series: 'a' [i64]
        [
                1
                2
                3
                1
        ]

        Parameters
        ----------
        strategy

        Fill null strategy or a value
               * &quot;backward&quot;
               * &quot;forward&quot;
               * &quot;min&quot;
               * &quot;max&quot;
               * &quot;mean&quot;
               * &quot;one&quot;
               * &quot;zero&quot;
        &quot;&quot;&quot;
        if not isinstance(strategy, str):
            return self.to_frame().select(pli.col(self.name).fill_null(strategy))[
                self.name
            ]
        return wrap_s(self._s.fill_null(strategy))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesfloor"><a class="header" href="#polarsinternalsseriesseriesfloor"><code>polars.internals.series.Series.floor</code></a></h3>
<pre><code class="language-python">floor() -&gt; Series:
</code></pre>
<p>Floor underlying floating point array to the lowest integers smaller or equal to the float value.</p>
<p>Only works on floating point Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def floor(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_s(self._s.floor())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesround"><a class="header" href="#polarsinternalsseriesseriesround"><code>polars.internals.series.Series.round</code></a></h3>
<pre><code class="language-python">round(decimals: int) -&gt; Series:
</code></pre>
<p>Round underlying floating point data by <code>decimals</code> digits.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1.12345, 2.56789, 3.901234])
s.round(2)
shape: (3,)
Series: 'a' [f64]
[
1.12
2.57
3.9
]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>decimals</code>]: number of decimals to round by.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, decimals: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1.12345, 2.56789, 3.901234])
        &gt;&gt;&gt; s.round(2)
        shape: (3,)
        Series: 'a' [f64]
        [
                1.12
                2.57
                3.9
        ]

        Parameters
        ----------
        decimals
            number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_s(self._s.round(decimals))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdot"><a class="header" href="#polarsinternalsseriesseriesdot"><code>polars.internals.series.Series.dot</code></a></h3>
<pre><code class="language-python">dot(other: Series) -&gt; Optionalfloat:
</code></pre>
<p>Compute the dot/inner product between two Series</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s2 = pl.Series(&quot;b&quot;, [4.0, 5.0, 6.0])
s.dot(s2)
32.0</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series to compute dot product with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dot(self, other: &quot;Series&quot;) -&gt; Optional[float]:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Series

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s2 = pl.Series(&quot;b&quot;, [4.0, 5.0, 6.0])
        &gt;&gt;&gt; s.dot(s2)
        32.0

        Parameters
        ----------
        other
            Series to compute dot product with
        &quot;&quot;&quot;
        return self._s.dot(other._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesmode"><a class="header" href="#polarsinternalsseriesseriesmode"><code>polars.internals.series.Series.mode</code></a></h3>
<pre><code class="language-python">mode() -&gt; Series:
</code></pre>
<p>Compute the most occurring value(s). Can return multiple Values</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.mode()
shape: (1,)
Series: 'a' [i64]
[
2
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mode(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.mode()
        shape: (1,)
        Series: 'a' [i64]
        [
                2
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.mode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessin"><a class="header" href="#polarsinternalsseriesseriessin"><code>polars.internals.series.Series.sin</code></a></h3>
<pre><code class="language-python">sin() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric sine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
s.sin()
shape: (3,)
Series: 'a' [f64]
[
0.0</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.sin()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1
                1.2246467991473532e-16
        ]
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriescos"><a class="header" href="#polarsinternalsseriesseriescos"><code>polars.internals.series.Series.cos</code></a></h3>
<pre><code class="language-python">cos() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric cosine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
s.cos()
shape: (3,)
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  -1e0
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.cos()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriestan"><a class="header" href="#polarsinternalsseriesseriestan"><code>polars.internals.series.Series.tan</code></a></h3>
<pre><code class="language-python">tan() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric tangent.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
s.tan()
shape: (3,)
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  -1e0
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((0., np.pi/2., np.pi)))
        &gt;&gt;&gt; s.tan()
        shape: (3,)
        Series: 'a' [f64]
        [
                1
                6.123233995736766e-17
                -1e0
        ]
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarcsin"><a class="header" href="#polarsinternalsseriesseriesarcsin"><code>polars.internals.series.Series.arcsin</code></a></h3>
<pre><code class="language-python">arcsin() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric Inverse sine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
s.arcsin()
shape: (3,)
Series: 'a' [f64]
[
1.5707963267948966
0.0
-1.5707963267948966e0
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arcsin(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse sine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arcsin()
        shape: (3,)
        Series: 'a' [f64]
        [
                1.5707963267948966
                0.0
                -1.5707963267948966e0
        ]
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarccos"><a class="header" href="#polarsinternalsseriesseriesarccos"><code>polars.internals.series.Series.arccos</code></a></h3>
<pre><code class="language-python">arccos() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric Inverse cosine.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
s.arccos()
shape: (3,)
Series: 'a' [f64]
[
0.0
1.5707963267948966
3.141592653589793
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arccos(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse cosine.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arccos()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.0
                1.5707963267948966
                3.141592653589793
        ]
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarctan"><a class="header" href="#polarsinternalsseriesseriesarctan"><code>polars.internals.series.Series.arctan</code></a></h3>
<pre><code class="language-python">arctan() -&gt; Series:
</code></pre>
<p>Compute the element-wise value for Trigonometric Inverse tangent.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np
s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
s.arctan()
shape: (3,)
Series: 'a' [f64]
[
0.7853981633974483
0.0
-7.853981633974483e-1
]</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arctan(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric Inverse tangent.

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, np.array((1.0, 0., -1)))
        &gt;&gt;&gt; s.arctan()
        shape: (3,)
        Series: 'a' [f64]
        [
                0.7853981633974483
                0.0
                -7.853981633974483e-1
        ]
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesapply"><a class="header" href="#polarsinternalsseriesseriesapply"><code>polars.internals.series.Series.apply</code></a></h3>
<pre><code class="language-python">apply(func: Callable[[Any], Any], 
    return_dtype: OptionalTypeDataType,) -&gt; Series:
</code></pre>
<p>Apply a function over elements in this Series and return a new Series.</p>
<p>If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.apply(lambda x: x + 10)
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  13
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>func</code>]: function or lambda.</li>
<li>[<code>return_dtype</code>]: Output datatype. If none is given, the same datatype as this Series will be used.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        func: Callable[[Any], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a function over elements in this Series and return a new Series.

        If the function returns another datatype, the return_dtype arg should be set, otherwise the method will fail.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.apply(lambda x: x + 10)
        shape: (3,)
        Series: 'a' [i64]
        [
                11
                12
                13
        ]

        Parameters
        ----------
        func
            function or lambda.
        return_dtype
            Output datatype. If none is given, the same datatype as this Series will be used.

        Returns
        -------
        Series
        &quot;&quot;&quot;
        if return_dtype is None:
            pl_return_dtype = None
        else:
            pl_return_dtype = py_type_to_dtype(return_dtype)
        return wrap_s(self._s.apply_lambda(func, pl_return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshift"><a class="header" href="#polarsinternalsseriesseriesshift"><code>polars.internals.series.Series.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; Series:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.shift(periods=1)
shape: (3,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  2
</code></pre>
</li>
</ul>
<p>]
&gt;&gt;&gt; s.shift(periods=-1)
shape: (3,)
Series: 'a' [i64]
[</p>
<ul>
<li>
<pre><code>  null
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int = 1) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.shift(periods=1)
        shape: (3,)
        Series: 'a' [i64]
        [
                null
                1
                2
        ]
        &gt;&gt;&gt; s.shift(periods=-1)
        shape: (3,)
        Series: 'a' [i64]
        [
                2
                3
                null
        ]

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_s(self._s.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshift_and_fill"><a class="header" href="#polarsinternalsseriesseriesshift_and_fill"><code>polars.internals.series.Series.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, 
    fill_value: Union[int, pli.Expr],) -&gt; Series:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: Fill None values with the result of this expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(
        self, periods: int, fill_value: Union[int, &quot;pli.Expr&quot;]
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).shift_and_fill(periods, fill_value)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieszip_with"><a class="header" href="#polarsinternalsseriesserieszip_with"><code>polars.internals.series.Series.zip_with</code></a></h3>
<pre><code class="language-python">zip_with(mask: Series, other: Series) -&gt; Series:
</code></pre>
<p>Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mask</code>]: Boolean Series.</li>
<li>[<code>other</code>]: Series of same type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>New Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def zip_with(self, mask: &quot;Series&quot;, other: &quot;Series&quot;) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.

        Parameters
        ----------
        mask
            Boolean Series.
        other
            Series of same type.

        Returns
        -------
        New Series
        &quot;&quot;&quot;
        return wrap_s(self._s.zip_with(mask._s, other._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_min"><a class="header" href="#polarsinternalsseriesseriesrolling_min"><code>polars.internals.series.Series.rolling_min</code></a></h3>
<pre><code class="language-python">rolling_min(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>apply a rolling min (moving min) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
s.rolling_min(window_size=3)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  300
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_min(window_size=3)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                100
                200
                300
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_min(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_max"><a class="header" href="#polarsinternalsseriesseriesrolling_max"><code>polars.internals.series.Series.rolling_max</code></a></h3>
<pre><code class="language-python">rolling_max(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Apply a rolling max (moving max) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
s.rolling_max(window_size=2)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  500
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_max(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                null
                300
                400
                500
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_max(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_mean"><a class="header" href="#polarsinternalsseriesseriesrolling_mean"><code>polars.internals.series.Series.rolling_mean</code></a></h3>
<pre><code class="language-python">rolling_mean(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Apply a rolling mean (moving mean) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
s.rolling_mean(window_size=2)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  450
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [100, 200, 300, 400, 500])
        &gt;&gt;&gt; s.rolling_mean(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                150
                250
                350
                450
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_mean(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_sum"><a class="header" href="#polarsinternalsseriesseriesrolling_sum"><code>polars.internals.series.Series.rolling_sum</code></a></h3>
<pre><code class="language-python">rolling_sum(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Apply a rolling sum (moving sum) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s.rolling_sum(window_size=2)
shape: (5,)
Series: '' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  9
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.rolling_sum(window_size=2)
        shape: (5,)
        Series: '' [i64]
        [
                null
                3
                5
                7
                9
        ]

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_sum(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_std"><a class="header" href="#polarsinternalsseriesseriesrolling_std"><code>polars.internals.series.Series.rolling_std</code></a></h3>
<pre><code class="language-python">rolling_std(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Compute a rolling std dev</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_std(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_var"><a class="header" href="#polarsinternalsseriesseriesrolling_var"><code>polars.internals.series.Series.rolling_var</code></a></h3>
<pre><code class="language-python">rolling_var(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Series:
</code></pre>
<p>Compute a rolling variance.</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_s(self._s.rolling_var(window_size, weights, min_periods, center))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_apply"><a class="header" href="#polarsinternalsseriesseriesrolling_apply"><code>polars.internals.series.Series.rolling_apply</code></a></h3>
<pre><code class="language-python">rolling_apply(window_size: int, 
    function: Callable[[pli.Series], Any],) -&gt; pli.Series:
</code></pre>
<p>Allows a custom rolling window function.
Prefer the specific rolling window functions over this one, as they are faster.
Prefer:
* rolling_min
* rolling_max
* rolling_mean
* rolling_sum
<strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>function</code>]: Aggregation function
<strong>Examples:</strong></li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;A&quot;, [1.0, 2.0, 9.0, 2.0, 13.0])
s.rolling_apply(window_size=3, function=lambda s: s.std())
shape: (5,)
Series: 'A' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>4.358898943540674
4.041451884327381
5.5677643628300215
]</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.
        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum
        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function
        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;A&quot;, [1.0, 2.0, 9.0, 2.0, 13.0])
        &gt;&gt;&gt; s.rolling_apply(window_size=3, function=lambda s: s.std())
        shape: (5,)
        Series: 'A' [f64]
        [
            null
            null
            4.358898943540674
            4.041451884327381
            5.5677643628300215
        ]
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_apply(window_size, function)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_median"><a class="header" href="#polarsinternalsseriesseriesrolling_median"><code>polars.internals.series.Series.rolling_median</code></a></h3>
<pre><code class="language-python">rolling_median(window_size: int) -&gt; Series:
</code></pre>
<p>Compute a rolling median</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_median(self, window_size: int) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_median(window_size)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_quantile"><a class="header" href="#polarsinternalsseriesseriesrolling_quantile"><code>polars.internals.series.Series.rolling_quantile</code></a></h3>
<pre><code class="language-python">rolling_quantile(window_size: int, 
    quantile: float,) -&gt; Series:
</code></pre>
<p>Compute a rolling quantile</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>quantile</code>]: quantile to compute</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_quantile(window_size, quantile)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrolling_skew"><a class="header" href="#polarsinternalsseriesseriesrolling_skew"><code>polars.internals.series.Series.rolling_skew</code></a></h3>
<pre><code class="language-python">rolling_skew(window_size: int, bias: bool) -&gt; Series:
</code></pre>
<p>Compute a rolling skew</p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>bias</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).rolling_skew(window_size, bias)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriessample"><a class="header" href="#polarsinternalsseriesseriessample"><code>polars.internals.series.Series.sample</code></a></h3>
<pre><code class="language-python">sample(n: Optionalint, 
    frac: Optionalfloat, 
    with_replacement: bool,) -&gt; Series:
</code></pre>
<p>Sample from this Series by setting either <code>n</code> or <code>frac</code>.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s.sample(2)
shape: (2,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of samples &lt; self.len().</li>
<li>[<code>frac</code>]: Fraction between 0.0 and 1.0 .</li>
<li>[<code>with_replacement</code>]: sample with replacement.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Sample from this Series by setting either `n` or `frac`.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.sample(2)
        shape: (2,)
        Series: 'a' [i64]
        [
                1
                5
        ]

        Parameters
        ----------
        n
            Number of samples &lt; self.len().
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            sample with replacement.
        &quot;&quot;&quot;
        if n is not None:
            return wrap_s(self._s.sample_n(n, with_replacement))
        return wrap_s(self._s.sample_frac(frac, with_replacement))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriespeak_max"><a class="header" href="#polarsinternalsseriesseriespeak_max"><code>polars.internals.series.Series.peak_max</code></a></h3>
<pre><code class="language-python">peak_max() -&gt; Series:
</code></pre>
<p>Get a boolean mask of the local maximum peaks.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s.peak_max()
shape: (5,)
Series: '' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  true
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def peak_max(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local maximum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
        &gt;&gt;&gt; s.peak_max()
        shape: (5,)
        Series: '' [bool]
        [
                false
                false
                false
                false
                true
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriespeak_min"><a class="header" href="#polarsinternalsseriesseriespeak_min"><code>polars.internals.series.Series.peak_min</code></a></h3>
<pre><code class="language-python">peak_min() -&gt; Series:
</code></pre>
<p>Get a boolean mask of the local minimum peaks.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [4, 1, 3, 2, 5])
s.peak_min()
shape: (5,)
Series: '' [bool]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  false
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def peak_min(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Get a boolean mask of the local minimum peaks.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [4, 1, 3, 2, 5])
        &gt;&gt;&gt; s.peak_min()
        shape: (5,)
        Series: '' [bool]
        [
                false
                true
                false
                true
                false
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.peak_min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesn_unique"><a class="header" href="#polarsinternalsseriesseriesn_unique"><code>polars.internals.series.Series.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; int:
</code></pre>
<p>Count the number of unique values in this Series.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
s.n_unique()
3</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; int:
        &quot;&quot;&quot;
        Count the number of unique values in this Series.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 2, 3])
        &gt;&gt;&gt; s.n_unique()
        3

        &quot;&quot;&quot;
        return self._s.n_unique()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesshrink_to_fit"><a class="header" href="#polarsinternalsseriesseriesshrink_to_fit"><code>polars.internals.series.Series.shrink_to_fit</code></a></h3>
<pre><code class="language-python">shrink_to_fit(in_place: bool) -&gt; OptionalSeries:
</code></pre>
<p>Shrink memory usage of this Series to fit the exact capacity needed to hold the data.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;Series&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this Series to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._s.shrink_to_fit()
            return None
        else:
            series = self.clone()
            series._s.shrink_to_fit()
            return series
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdt"><a class="header" href="#polarsinternalsseriesseriesdt"><code>polars.internals.series.Series.dt</code></a></h3>
<pre><code class="language-python">dt() -&gt; DateTimeNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dt(self) -&gt; &quot;DateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return DateTimeNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesarr"><a class="header" href="#polarsinternalsseriesseriesarr"><code>polars.internals.series.Series.arr</code></a></h3>
<pre><code class="language-python">arr() -&gt; ListNameSpace:
</code></pre>
<p>Create an object namespace of all list related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arr(self) -&gt; &quot;ListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all list related methods.
        &quot;&quot;&quot;
        return ListNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesstr"><a class="header" href="#polarsinternalsseriesseriesstr"><code>polars.internals.series.Series.str</code></a></h3>
<pre><code class="language-python">str() -&gt; StringNameSpace:
</code></pre>
<p>Create an object namespace of all string related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str(self) -&gt; &quot;StringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return StringNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieshash"><a class="header" href="#polarsinternalsseriesserieshash"><code>polars.internals.series.Series.hash</code></a></h3>
<pre><code class="language-python">hash(k0: int, k1: int, k2: int, k3: int) -&gt; pli.Series:
</code></pre>
<p>Hash the Series.</p>
<p>The hash value is of type <code>UInt64</code></p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, 3])
s.hash(k0=42)
shape: (3,)
Series: 'a' [u64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  3939059409923356085
</code></pre>
</li>
</ul>
<p>]</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `UInt64`

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, 3])
        &gt;&gt;&gt; s.hash(k0=42)
        shape: (3,)
        Series: 'a' [u64]
        [
                18040498172617206516
                5352755651785478209
                3939059409923356085
        ]

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_s(self._s.hash(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesreinterpret"><a class="header" href="#polarsinternalsseriesseriesreinterpret"><code>polars.internals.series.Series.reinterpret</code></a></h3>
<pre><code class="language-python">reinterpret(signed: bool) -&gt; Series:
</code></pre>
<p>Reinterpret the underlying bits as a signed/unsigned integer.
This operation is only allowed for 64bit integers. For lower bits integers,
you can safely use that cast operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>signed</code>]: True -&gt; pl.Int64
False -&gt; pl.UInt64</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reinterpret(self, signed: bool = True) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_s(self._s.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesinterpolate"><a class="header" href="#polarsinternalsseriesseriesinterpolate"><code>polars.internals.series.Series.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; Series:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>s = pl.Series(&quot;a&quot;, [1, 2, None, None, 5])
s.interpolate()
shape: (5,)
Series: 'a' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>
<pre><code>  5
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.

        Examples
        --------
        &gt;&gt;&gt; s = pl.Series(&quot;a&quot;, [1, 2, None, None, 5])
        &gt;&gt;&gt; s.interpolate()
        shape: (5,)
        Series: 'a' [i64]
        [
                1
                2
                3
                4
                5
        ]

        &quot;&quot;&quot;
        return wrap_s(self._s.interpolate())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesabs"><a class="header" href="#polarsinternalsseriesseriesabs"><code>polars.internals.series.Series.abs</code></a></h3>
<pre><code class="language-python">abs() -&gt; Series:
</code></pre>
<p>Take absolute values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def abs(self) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_s(self._s.abs())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesrank"><a class="header" href="#polarsinternalsseriesseriesrank"><code>polars.internals.series.Series.rank</code></a></h3>
<pre><code class="language-python">rank(method: str) -&gt; Series:
</code></pre>
<p>Assign ranks to data, dealing with ties appropriately.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>method</code>]: {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
The method used to assign ranks to tied elements.
The following methods are available (default is 'average'):
* 'average': The average of the ranks that would have been assigned to
all the tied values is assigned to each value.
* 'min': The minimum of the ranks that would have been assigned to all
the tied values is assigned to each value.  (This is also
referred to as &quot;competition&quot; ranking.)
* 'max': The maximum of the ranks that would have been assigned to all
the tied values is assigned to each value.
* 'dense': Like 'min', but the rank of the next highest element is</li>
<li>
<pre><code>* 'ordinal': All values are given a distinct rank, corresponding to
  the order that the values occur in `a`.
* 'random': Like 'ordinal', but the rank for ties is not dependent
  on the order that the values occur in `a`.
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_s(self._s.rank(method))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesdiff"><a class="header" href="#polarsinternalsseriesseriesdiff"><code>polars.internals.series.Series.diff</code></a></h3>
<pre><code class="language-python">diff(n: int, null_behavior: str) -&gt; Series:
</code></pre>
<p>Calculate the n-th discrete difference.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: number of slots to shift</li>
<li>[<code>null_behavior</code>]: {'ignore', 'drop'}</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_s(self._s.diff(n, null_behavior))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesskew"><a class="header" href="#polarsinternalsseriesseriesskew"><code>polars.internals.series.Series.skew</code></a></h3>
<pre><code class="language-python">skew(bias: bool) -&gt; Optionalfloat:
</code></pre>
<p>Compute the sample skewness of a data set.
For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function <code>skewtest</code> can be used to determine if the skewness value
is close enough to zero, statistically speaking.</p>
<p>See scipy.stats for more information.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p><strong>Notes:</strong></p>
<p>The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.
.. math::
g_1=\frac{m_3}{m_2^{3/2}}
where
.. math::
m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
is the biased sample :math:<code>i\texttt{th}</code> central moment, and
:math:<code>\bar{x}</code> is
the sample mean.  If <code>bias</code> is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.
.. math::
G_1=\frac{k_3}{k_2^{3/2}}=
\frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def skew(self, bias: bool = True) -&gt; Optional[float]:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return self._s.skew(bias)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesserieskurtosis"><a class="header" href="#polarsinternalsseriesserieskurtosis"><code>polars.internals.series.Series.kurtosis</code></a></h3>
<pre><code class="language-python">kurtosis(fisher: bool, bias: bool) -&gt; Optionalfloat:
</code></pre>
<p>Compute the kurtosis (Fisher or Pearson) of a dataset.
Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.
If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators</p>
<p>See scipy.stats for more information</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fisher</code> [<code>bool, optional</code>]: If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
Pearson's definition is used (normal ==&gt; 3.0).</li>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; Optional[float]:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return self._s.kurtosis(fisher, bias)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesclip"><a class="header" href="#polarsinternalsseriesseriesclip"><code>polars.internals.series.Series.clip</code></a></h3>
<pre><code class="language-python">clip(min_val: Union[int, float], 
    max_val: Union[int, float],) -&gt; Series:
</code></pre>
<p>Clip (limit) the values in an array.</p>
<p><strong>Parameters:</strong></p>
<p>min_val, max_val
Minimum and maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).clip(min_val, max_val)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesstr_concat"><a class="header" href="#polarsinternalsseriesseriesstr_concat"><code>polars.internals.series.Series.str_concat</code></a></h3>
<pre><code class="language-python">str_concat(delimiter: str) -&gt; Series:
</code></pre>
<p>Vertically concat the values in the Series to a single string value.</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Utf8</p>
<p>Examples
&gt;&gt;&gt; pl.Series([1, None, 2]).str_concat(&quot;-&quot;)[0]
&quot;1-null-2&quot;</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Series&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; pl.Series([1, None, 2]).str_concat(&quot;-&quot;)[0]
        &quot;1-null-2&quot;

        &quot;&quot;&quot;
        return self.to_frame().select(
            pli.col(self.name).str_concat(delimiter)  # type: ignore
        )[self.name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsseriesseriesreshape"><a class="header" href="#polarsinternalsseriesseriesreshape"><code>polars.internals.series.Series.reshape</code></a></h3>
<pre><code class="language-python">reshape(dims: tp.Tuple[int, ]) -&gt; Series:
</code></pre>
<p>Reshape this Series to a flat series, shape: (len,)
or a List series, shape: (rows, cols)</p>
<p>if a -1 is used in any of the dimensions, that dimension is inferred.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dims</code>]: Tuple of the dimension sizes</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Series&quot;:
        &quot;&quot;&quot;
        Reshape this Series to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Series
        &quot;&quot;&quot;
        return wrap_s(self._s.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../polars/internals/series.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../../polars/internals/series/StringNameSpace.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../polars/internals/series.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../../polars/internals/series/StringNameSpace.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../../theme/js/index.js"></script>
        

        

    </body>
</html>
