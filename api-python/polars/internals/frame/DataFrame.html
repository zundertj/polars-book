<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DataFrame - Polars - Python Reference Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../../favicon.png">
        
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../../theme/css/style.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../../polars.html">polars</a></li><li class="chapter-item "><a href="../../../polars/cfg.html">cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/cfg/Config.html">Config</a></li></ol></li><li class="chapter-item "><a href="../../../polars/convert.html">convert</a></li><li class="chapter-item "><a href="../../../polars/datatypes.html">datatypes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/datatypes/DataType.html">DataType</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int8.html">Int8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int16.html">Int16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int32.html">Int32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int64.html">Int64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt8.html">UInt8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt16.html">UInt16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt32.html">UInt32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt64.html">UInt64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float32.html">Float32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float64.html">Float64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Boolean.html">Boolean</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Utf8.html">Utf8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/List.html">List</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date.html">Date</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Datetime.html">Datetime</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time.html">Time</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Object.html">Object</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Categorical.html">Categorical</a></li></ol></li><li class="chapter-item "><a href="../../../polars/datatypes_constructor.html">datatypes_constructor</a></li><li class="chapter-item expanded "><a href="../../../polars/internals.html">internals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/construction.html">construction</a></li><li class="chapter-item "><a href="../../../polars/internals/expr.html">expr</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/expr/Expr.html">Expr</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprListNameSpace.html">ExprListNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprStringNameSpace.html">ExprStringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprDateTimeNameSpace.html">ExprDateTimeNameSpace</a></li></ol></li><li class="chapter-item expanded "><a href="../../../polars/internals/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../polars/internals/frame/DataFrame.html" class="active">DataFrame</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/GroupBy.html">GroupBy</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/PivotOps.html">PivotOps</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/GBSelection.html">GBSelection</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/functions.html">functions</a></li><li class="chapter-item "><a href="../../../polars/internals/lazy_frame.html">lazy_frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/lazy_frame/LazyFrame.html">LazyFrame</a></li><li class="chapter-item "><a href="../../../polars/internals/lazy_frame/LazyGroupBy.html">LazyGroupBy</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/lazy_functions.html">lazy_functions</a></li><li class="chapter-item "><a href="../../../polars/internals/series.html">series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/series/Series.html">Series</a></li><li class="chapter-item "><a href="../../../polars/internals/series/StringNameSpace.html">StringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/ListNameSpace.html">ListNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/DateTimeNameSpace.html">DateTimeNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/SeriesIter.html">SeriesIter</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/whenthen.html">whenthen</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/whenthen/WhenThenThen.html">WhenThenThen</a></li><li class="chapter-item "><a href="../../../polars/internals/whenthen/WhenThen.html">WhenThen</a></li><li class="chapter-item "><a href="../../../polars/internals/whenthen/When.html">When</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/io.html">io</a></li><li class="chapter-item "><a href="../../../polars/string_cache.html">string_cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/string_cache/StringCache.html">StringCache</a></li></ol></li><li class="chapter-item "><a href="../../../polars/testing.html">testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - Python Reference Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polarsinternalsframedataframe"><a class="header" href="#polarsinternalsframedataframe"><code>polars.internals.frame.DataFrame</code></a></h1>
<p>A DataFrame is a two-dimensional data structure that represents data as a table
with rows and columns.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>data</code> [<code>dict, Sequence, ndarray, Series, or pandas.DataFrame</code>]: Two-dimensional data in various forms. dict must contain Sequences.
Sequence may contain Series or other Sequences.</li>
<li><code>columns</code> [<code>Sequence of str, default None</code>]: Column labels to use for resulting DataFrame. If specified, overrides any
labels already present in the data. Must match data dimensions.
orient : {'col', 'row'}, default None
Whether to interpret two-dimensional data as columns or as rows. If None,
the orientation is inferred by matching the columns and data dimensions. If
this does not yield conclusive results, column orientation is used.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Constructing a DataFrame from a dictionary:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = {'a': [1, 2], 'b': [3, 4]}
df = pl.DataFrame(data)
df
shape: (2, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 4   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Notice that the dtype is automatically inferred as a polars Int64:</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.dtypes
[&lt;class 'polars.datatypes.Int64'&gt;, &lt;class 'polars.datatypes.Int64'&gt;]</p>
</blockquote>
</blockquote>
</blockquote>
<p>In order to specify dtypes for your columns, initialize the DataFrame with a list
of Series instead:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [pl.Series('col1', [1, 2], dtype=pl.Float32),
...         pl.Series('col2', [3, 4], dtype=pl.Int64)]
df2 = pl.DataFrame(series)
df2
shape: (2, 2)
╭──────┬──────╮
│ col1 ┆ col2 │
│ ---  ┆ ---  │
│ f32  ┆ i64  │
╞══════╪══════╡
│ 1    ┆ 3    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ 4    │
╰──────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a DataFrame from a numpy ndarray, specifying column names:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = np.array([(1, 2), (3, 4)])
df3 = pl.DataFrame(data, columns=['a', 'b'], orient='col')
df3
shape: (2, 2)
╭─────┬─────╮
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 4   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>Constructing a DataFrame from a list of lists, row orientation inferred:</p>
<blockquote>
<blockquote>
<blockquote>
<p>data = [[1, 2, 3], [4, 5, 6]]
df4 = pl.DataFrame(data, columns=['a', 'b', 'c'])
df4
shape: (2, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 5   ┆ 6   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="#polarsinternalsframedataframeread_csv"><code>read_csv()</code></a>: Read a CSV file into a Dataframe.</li>
<li><a href="#polarsinternalsframedataframeread_parquet"><code>read_parquet()</code></a>: Read into a DataFrame from a parquet file.</li>
<li><a href="#polarsinternalsframedataframeread_ipc"><code>read_ipc()</code></a>: Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.</li>
<li><a href="#polarsinternalsframedataframeread_json"><code>read_json()</code></a>: Read into a DataFrame from JSON format.</li>
<li><a href="#polarsinternalsframedataframeto_arrow"><code>to_arrow()</code></a>: Collect the underlying arrow arrays in an Arrow Table.</li>
<li><a href="#polarsinternalsframedataframeto_dict"><code>to_dict()</code></a>: Convert DataFrame to a dictionary mapping column name to values.</li>
<li><a href="#polarsinternalsframedataframeto_json"><code>to_json()</code></a>: Serialize to JSON representation.</li>
<li><a href="#polarsinternalsframedataframeto_pandas"><code>to_pandas()</code></a>: Cast to a Pandas DataFrame. This requires that Pandas is installed.</li>
<li><a href="#polarsinternalsframedataframeto_csv"><code>to_csv()</code></a>: Write Dataframe to comma-separated values file (csv).</li>
<li><a href="#polarsinternalsframedataframeto_ipc"><code>to_ipc()</code></a>: Write to Arrow IPC binary stream, or a feather file.</li>
<li><a href="#polarsinternalsframedataframeto_dicts"><code>to_dicts()</code></a>: </li>
<li><a href="#polarsinternalsframedataframetranspose"><code>transpose()</code></a>: Transpose a DataFrame over the diagonal.</li>
<li><a href="#polarsinternalsframedataframeto_parquet"><code>to_parquet()</code></a>: Write the DataFrame disk in parquet format.</li>
<li><a href="#polarsinternalsframedataframeto_numpy"><code>to_numpy()</code></a>: Convert DataFrame to a 2d numpy array.</li>
<li><a href="#polarsinternalsframedataframefind_idx_by_name"><code>find_idx_by_name()</code></a>: Find the index of a column by name.</li>
<li><a href="#polarsinternalsframedataframeto_series"><code>to_series()</code></a>: Select column as Series at index location.</li>
<li><a href="#polarsinternalsframedataframerename"><code>rename()</code></a>: Rename column names.</li>
<li><a href="#polarsinternalsframedataframeinsert_at_idx"><code>insert_at_idx()</code></a>: Insert a Series at a certain column index. This operation is in place.</li>
<li><a href="#polarsinternalsframedataframefilter"><code>filter()</code></a>: Filter the rows in the DataFrame based on a predicate expression.</li>
<li><a href="#polarsinternalsframedataframeshape"><code>shape()</code></a>: Get the shape of the DataFrame.</li>
<li><a href="#polarsinternalsframedataframeheight"><code>height()</code></a>: Get the height of the DataFrame.</li>
<li><a href="#polarsinternalsframedataframewidth"><code>width()</code></a>: Get the width of the DataFrame.</li>
<li><a href="#polarsinternalsframedataframecolumns"><code>columns()</code></a>: Change the column names of the <code>DataFrame</code>.</li>
<li><a href="#polarsinternalsframedataframedtypes"><code>dtypes()</code></a>: Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</li>
<li><a href="#polarsinternalsframedataframedescribe"><code>describe()</code></a>: Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.</li>
<li><a href="#polarsinternalsframedataframedescribedescribe_cast"><code>describe_cast()</code></a>: </li>
<li><a href="#polarsinternalsframedataframereplace_at_idx"><code>replace_at_idx()</code></a>: Replace a column at an index location.</li>
<li><a href="#polarsinternalsframedataframesort"><code>sort()</code></a>: Sort the DataFrame by column.</li>
<li><a href="#polarsinternalsframedataframeframe_equal"><code>frame_equal()</code></a>: Check if DataFrame is equal to other.</li>
<li><a href="#polarsinternalsframedataframereplace"><code>replace()</code></a>: Replace a column by a new Series.</li>
<li><a href="#polarsinternalsframedataframeslice"><code>slice()</code></a>: Slice this DataFrame over the rows direction.</li>
<li><a href="#polarsinternalsframedataframelimit"><code>limit()</code></a>: Get first N rows as DataFrame.</li>
<li><a href="#polarsinternalsframedataframehead"><code>head()</code></a>: Get first N rows as DataFrame.</li>
<li><a href="#polarsinternalsframedataframetail"><code>tail()</code></a>: Get last N rows as DataFrame.</li>
<li><a href="#polarsinternalsframedataframedrop_nulls"><code>drop_nulls()</code></a>: Return a new DataFrame where the null values are dropped.</li>
<li><a href="#polarsinternalsframedataframepipe"><code>pipe()</code></a>: Apply a function on Self.</li>
<li><a href="#polarsinternalsframedataframewith_row_count"><code>with_row_count()</code></a>: Add a column at index 0 that counts the rows.</li>
<li><a href="#polarsinternalsframedataframegroupby"><code>groupby()</code></a>: Start a groupby operation.</li>
<li><a href="#polarsinternalsframedataframedownsample"><code>downsample()</code></a>: Start a downsampling groupby operation.</li>
<li><a href="#polarsinternalsframedataframeupsample"><code>upsample()</code></a>: Upsample a DataFrame at a regular frequency.</li>
<li><a href="#polarsinternalsframedataframejoin"><code>join()</code></a>: SQL like joins.</li>
<li><a href="#polarsinternalsframedataframeapply"><code>apply()</code></a>: Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.</li>
<li><a href="#polarsinternalsframedataframewith_column"><code>with_column()</code></a>: Return a new DataFrame with the column added or replaced.</li>
<li><a href="#polarsinternalsframedataframewith_column_renamed"><code>with_column_renamed()</code></a>: Return a new DataFrame with the column renamed.</li>
<li><a href="#polarsinternalsframedataframehstack"><code>hstack()</code></a>: Return a new DataFrame grown horizontally by stacking multiple Series to it.</li>
<li><a href="#polarsinternalsframedataframevstack"><code>vstack()</code></a>: Grow this DataFrame vertically by stacking a DataFrame to it.</li>
<li><a href="#polarsinternalsframedataframedrop"><code>drop()</code></a>: Remove column from DataFrame and return as new.</li>
<li><a href="#polarsinternalsframedataframedrop_in_place"><code>drop_in_place()</code></a>: Drop in place.</li>
<li><a href="#polarsinternalsframedataframeselect_at_idx"><code>select_at_idx()</code></a>: Select column at index location.</li>
<li><a href="#polarsinternalsframedataframeclone"><code>clone()</code></a>: Very cheap deep clone.</li>
<li><a href="#polarsinternalsframedataframeget_columns"><code>get_columns()</code></a>: Get the DataFrame as a List of Series.</li>
<li><a href="#polarsinternalsframedataframeget_column"><code>get_column()</code></a>: Get a single column as Series by name.</li>
<li><a href="#polarsinternalsframedataframefill_null"><code>fill_null()</code></a>: Fill None/missing values by a filling strategy or an Expression evaluation.</li>
<li><a href="#polarsinternalsframedataframefill_nan"><code>fill_nan()</code></a>: Fill None/missing values by a an Expression evaluation.</li>
<li><a href="#polarsinternalsframedataframeexplode"><code>explode()</code></a>: Explode <code>DataFrame</code> to long format by exploding a column with Lists.</li>
<li><a href="#polarsinternalsframedataframemelt"><code>melt()</code></a>: Unpivot DataFrame to long format.</li>
<li><a href="#polarsinternalsframedataframeshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="#polarsinternalsframedataframeshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="#polarsinternalsframedataframeis_duplicated"><code>is_duplicated()</code></a>: Get a mask of all duplicated rows in this DataFrame.</li>
<li><a href="#polarsinternalsframedataframeis_unique"><code>is_unique()</code></a>: Get a mask of all unique rows in this DataFrame.</li>
<li><a href="#polarsinternalsframedataframelazy"><code>lazy()</code></a>: Start a lazy query from this point. This returns a <code>LazyFrame</code> object.</li>
<li><a href="#polarsinternalsframedataframeselect"><code>select()</code></a>: Select columns from this DataFrame.</li>
<li><a href="#polarsinternalsframedataframewith_columns"><code>with_columns()</code></a>: Add or overwrite multiple columns in a DataFrame.</li>
<li><a href="#polarsinternalsframedataframen_chunks"><code>n_chunks()</code></a>: Get number of chunks used by the ChunkedArrays of this DataFrame.</li>
<li><a href="#polarsinternalsframedataframemax"><code>max()</code></a>: Aggregate the columns of this DataFrame to their maximum value.</li>
<li><a href="#polarsinternalsframedataframemin"><code>min()</code></a>: Aggregate the columns of this DataFrame to their minimum value.</li>
<li><a href="#polarsinternalsframedataframesum"><code>sum()</code></a>: Aggregate the columns of this DataFrame to their sum value.</li>
<li><a href="#polarsinternalsframedataframemean"><code>mean()</code></a>: Aggregate the columns of this DataFrame to their mean value.</li>
<li><a href="#polarsinternalsframedataframestd"><code>std()</code></a>: Aggregate the columns of this DataFrame to their standard deviation value.</li>
<li><a href="#polarsinternalsframedataframevar"><code>var()</code></a>: Aggregate the columns of this DataFrame to their variance value.</li>
<li><a href="#polarsinternalsframedataframemedian"><code>median()</code></a>: Aggregate the columns of this DataFrame to their median value.</li>
<li><a href="#polarsinternalsframedataframequantile"><code>quantile()</code></a>: Aggregate the columns of this DataFrame to their quantile value.</li>
<li><a href="#polarsinternalsframedataframeto_dummies"><code>to_dummies()</code></a>: Get one hot encoded dummy variables.</li>
<li><a href="#polarsinternalsframedataframedrop_duplicates"><code>drop_duplicates()</code></a>: Drop duplicate rows from this DataFrame.</li>
<li><a href="#polarsinternalsframedataframerechunk"><code>rechunk()</code></a>: Rechunk the data in this DataFrame to a contiguous allocation.</li>
<li><a href="#polarsinternalsframedataframenull_count"><code>null_count()</code></a>: Create a new DataFrame that shows the null counts per column.</li>
<li><a href="#polarsinternalsframedataframesample"><code>sample()</code></a>: Sample from this DataFrame by setting either <code>n</code> or <code>frac</code>.</li>
<li><a href="#polarsinternalsframedataframefold"><code>fold()</code></a>: Apply a horizontal reduction on a DataFrame. This can be used to effectively</li>
<li><a href="#polarsinternalsframedataframerow"><code>row()</code></a>: Get a row as tuple.</li>
<li><a href="#polarsinternalsframedataframerows"><code>rows()</code></a>: Convert columnar data to rows as python tuples.</li>
<li><a href="#polarsinternalsframedataframeshrink_to_fit"><code>shrink_to_fit()</code></a>: Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.</li>
<li><a href="#polarsinternalsframedataframehash_rows"><code>hash_rows()</code></a>: Hash and combine the rows in this DataFrame.</li>
<li><a href="#polarsinternalsframedataframeinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
<li><a href="#polarsinternalsframedataframeis_empty"><code>is_empty()</code></a>: Check if the dataframe is empty</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class DataFrame:
    &quot;&quot;&quot;
    A DataFrame is a two-dimensional data structure that represents data as a table
    with rows and columns.

    Parameters
    ----------
    data : dict, Sequence, ndarray, Series, or pandas.DataFrame
        Two-dimensional data in various forms. dict must contain Sequences.
        Sequence may contain Series or other Sequences.
    columns : Sequence of str, default None
        Column labels to use for resulting DataFrame. If specified, overrides any
        labels already present in the data. Must match data dimensions.
    orient : {'col', 'row'}, default None
        Whether to interpret two-dimensional data as columns or as rows. If None,
        the orientation is inferred by matching the columns and data dimensions. If
        this does not yield conclusive results, column orientation is used.

    Examples
    --------
    Constructing a DataFrame from a dictionary:

    &gt;&gt;&gt; data = {'a': [1, 2], 'b': [3, 4]}
    &gt;&gt;&gt; df = pl.DataFrame(data)
    &gt;&gt;&gt; df
    shape: (2, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 4   │
    ╰─────┴─────╯

    Notice that the dtype is automatically inferred as a polars Int64:

    &gt;&gt;&gt; df.dtypes
    [&lt;class 'polars.datatypes.Int64'&gt;, &lt;class 'polars.datatypes.Int64'&gt;]

    In order to specify dtypes for your columns, initialize the DataFrame with a list
    of Series instead:

    &gt;&gt;&gt; data = [pl.Series('col1', [1, 2], dtype=pl.Float32),
    ...         pl.Series('col2', [3, 4], dtype=pl.Int64)]
    &gt;&gt;&gt; df2 = pl.DataFrame(series)
    &gt;&gt;&gt; df2
    shape: (2, 2)
    ╭──────┬──────╮
    │ col1 ┆ col2 │
    │ ---  ┆ ---  │
    │ f32  ┆ i64  │
    ╞══════╪══════╡
    │ 1    ┆ 3    │
    ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
    │ 2    ┆ 4    │
    ╰──────┴──────╯

    Constructing a DataFrame from a numpy ndarray, specifying column names:

    &gt;&gt;&gt; data = np.array([(1, 2), (3, 4)])
    &gt;&gt;&gt; df3 = pl.DataFrame(data, columns=['a', 'b'], orient='col')
    &gt;&gt;&gt; df3
    shape: (2, 2)
    ╭─────┬─────╮
    │ a   ┆ b   │
    │ --- ┆ --- │
    │ i64 ┆ i64 │
    ╞═════╪═════╡
    │ 1   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┤
    │ 2   ┆ 4   │
    ╰─────┴─────╯

    Constructing a DataFrame from a list of lists, row orientation inferred:

    &gt;&gt;&gt; data = [[1, 2, 3], [4, 5, 6]]
    &gt;&gt;&gt; df4 = pl.DataFrame(data, columns=['a', 'b', 'c'])
    &gt;&gt;&gt; df4
    shape: (2, 3)
    ╭─────┬─────┬─────╮
    │ a   ┆ b   ┆ c   │
    │ --- ┆ --- ┆ --- │
    │ i64 ┆ i64 ┆ i64 │
    ╞═════╪═════╪═════╡
    │ 1   ┆ 2   ┆ 3   │
    ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
    │ 4   ┆ 5   ┆ 6   │
    ╰─────┴─────┴─────╯
    &quot;&quot;&quot;

    def __init__(
        self,
        data: Optional[
            Union[
                Dict[str, Sequence[Any]],
                Sequence[Any],
                np.ndarray,
                &quot;pa.Table&quot;,
                &quot;pd.DataFrame&quot;,
                &quot;pli.Series&quot;,
            ]
        ] = None,
        columns: Optional[Sequence[str]] = None,
        orient: Optional[str] = None,
    ):
        if data is None:
            self._df = dict_to_pydf({}, columns=columns)

        elif isinstance(data, dict):
            self._df = dict_to_pydf(data, columns=columns)

        elif isinstance(data, np.ndarray):
            self._df = numpy_to_pydf(data, columns=columns, orient=orient)

        elif _PYARROW_AVAILABLE and isinstance(data, pa.Table):
            self._df = arrow_to_pydf(data, columns=columns)

        elif isinstance(data, Sequence) and not isinstance(data, str):
            self._df = sequence_to_pydf(data, columns=columns, orient=orient)

        elif isinstance(data, pli.Series):
            self._df = series_to_pydf(data, columns=columns)

        elif _PANDAS_AVAILABLE and isinstance(data, pd.DataFrame):
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required for converting a pandas DataFrame to a polars DataFrame.&quot;
                )
            self._df = pandas_to_pydf(data, columns=columns)

        else:
            raise ValueError(&quot;DataFrame constructor not called properly.&quot;)

    @classmethod
    def _from_pydf(cls, py_df: &quot;PyDataFrame&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct Polars DataFrame from FFI PyDataFrame object.
        &quot;&quot;&quot;
        df = cls.__new__(cls)
        df._df = py_df
        return df

    @classmethod
    def _from_dicts(cls, data: Sequence[Dict[str, Any]]) -&gt; &quot;DataFrame&quot;:
        pydf = PyDataFrame.read_dicts(data)
        return DataFrame._from_pydf(pydf)

    @classmethod
    def _from_dict(
        cls,
        data: Dict[str, Sequence[Any]],
        columns: Optional[Sequence[str]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a DataFrame from a dictionary of sequences.

        Parameters
        ----------
        data : dict of sequences
            Two-dimensional data represented as a dictionary. dict must contain
            Sequences.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. If specified, overrides any
            labels already present in the data. Must match data dimensions.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return cls._from_pydf(dict_to_pydf(data, columns=columns))

    @classmethod
    def _from_records(
        cls,
        data: Union[np.ndarray, Sequence[Sequence[Any]]],
        columns: Optional[Sequence[str]] = None,
        orient: Optional[str] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a DataFrame from a numpy ndarray or sequence of sequences.

        Parameters
        ----------
        data : numpy ndarray or Sequence of sequences
            Two-dimensional data represented as numpy ndarray or sequence of sequences.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. Must match data dimensions.
            If not specified, columns will be named `column_0`, `column_1`, etc.
        orient : {'col', 'row'}, default None
            Whether to interpret two-dimensional data as columns or as rows. If None,
            the orientation is inferred by matching the columns and data dimensions. If
            this does not yield conclusive results, column orientation is used.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        if isinstance(data, np.ndarray):
            pydf = numpy_to_pydf(data, columns=columns, orient=orient)
        else:
            pydf = sequence_to_pydf(data, columns=columns, orient=orient)
        return cls._from_pydf(pydf)

    @classmethod
    def _from_arrow(
        cls,
        data: &quot;pa.Table&quot;,
        columns: Optional[Sequence[str]] = None,
        rechunk: bool = True,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a DataFrame from an Arrow table.

        This operation will be zero copy for the most part. Types that are not
        supported by Polars may be cast to the closest supported type.

        Parameters
        ----------
        data : numpy ndarray or Sequence of sequences
            Two-dimensional data represented as Arrow table.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. Must match data dimensions.
            If not specified, existing Array table columns are used, with missing names
            named as `column_0`, `column_1`, etc.
        rechunk : bool, default True
            Make sure that all data is contiguous.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return cls._from_pydf(arrow_to_pydf(data, columns=columns, rechunk=rechunk))

    @classmethod
    def _from_pandas(
        cls,
        data: &quot;pd.DataFrame&quot;,
        columns: Optional[Sequence[str]] = None,
        rechunk: bool = True,
        nan_to_none: bool = True,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Construct a Polars DataFrame from a pandas DataFrame.

        Parameters
        ----------
        data : pandas DataFrame
            Two-dimensional data represented as a pandas DataFrame.
        columns : Sequence of str, default None
            Column labels to use for resulting DataFrame. If specified, overrides any
            labels already present in the data. Must match data dimensions.
        rechunk : bool, default True
            Make sure that all data is contiguous.
        nan_to_none : bool, default True
            If data contains NaN values PyArrow will convert the NaN to None

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        return cls._from_pydf(
            pandas_to_pydf(
                data, columns=columns, rechunk=rechunk, nan_to_none=nan_to_none
            )
        )

    @staticmethod
    def read_csv(
        file: Union[str, BinaryIO, bytes],
        infer_schema_length: Optional[int] = 100,
        batch_size: int = 64,
        has_headers: bool = True,
        ignore_errors: bool = False,
        stop_after_n_rows: Optional[int] = None,
        skip_rows: int = 0,
        projection: Optional[tp.List[int]] = None,
        sep: str = &quot;,&quot;,
        columns: Optional[tp.List[str]] = None,
        rechunk: bool = True,
        encoding: str = &quot;utf8&quot;,
        n_threads: Optional[int] = None,
        dtype: Union[Dict[str, Type[DataType]], tp.List[Type[DataType]], None] = None,
        low_memory: bool = False,
        comment_char: Optional[str] = None,
        quote_char: Optional[str] = r'&quot;',
        null_values: Optional[Union[str, tp.List[str], Dict[str, str]]] = None,
        parse_dates: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read a CSV file into a Dataframe.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used. Example: `file.csv`.
        infer_schema_length
            Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
            If set to `None`, a full table scan will be done (slow).
        batch_size
            Number of lines to read into the buffer at once. Modify this to change performance.
        has_headers
            Indicate if first row of dataset is header or not. If set to False first row will be set to `column_x`,
            `x` being an enumeration over every column in the dataset.
        ignore_errors
            Try to keep reading lines if some lines yield errors.
        stop_after_n_rows
            After n rows are read from the CSV, it stops reading.
            During multi-threaded parsing, an upper bound of `n` rows
            cannot be guaranteed.
        skip_rows
            Start reading after `skip_rows`.
        projection
            Indices of columns to select. Note that column indices start at zero.
        sep
            Character to use as delimiter in the file.
        columns
            Columns to select.
        rechunk
            Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.
        encoding
            Allowed encodings: `utf8`, `utf8-lossy`. Lossy means that invalid utf8 values are replaced with `�` character.
        n_threads
            Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.
        dtype
            Overwrite the dtypes during inference.
        low_memory
            Reduce memory usage in expense of performance.
        comment_char
            character that indicates the start of a comment line, for instance '#'.
        quote_char
            single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
            of quotes off.
        null_values
            Values to interpret as null values. You can provide a:

            - str -&gt; all values encountered equal to this string will be null
            - tp.List[str] -&gt; A null value per column.
            - Dict[str, str] -&gt; A dictionary that maps column name to a null value string.
        parse_dates
            Whether to attempt to parse dates or not

        Returns
        -------
        DataFrame

        Examples
        --------

        &gt;&gt;&gt; df = pl.read_csv('file.csv', sep=';', stop_after_n_rows=25)

        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)

        path: Optional[str]
        if isinstance(file, str):
            path = file
        else:
            path = None
            if isinstance(file, BytesIO):
                file = file.getvalue()
            if isinstance(file, StringIO):
                file = file.getvalue().encode()

        dtype_list: Optional[tp.List[Tuple[str, Type[DataType]]]] = None
        dtype_slice: Optional[tp.List[Type[DataType]]] = None
        if dtype is not None:
            if isinstance(dtype, dict):
                dtype_list = []
                for k, v in dtype.items():
                    dtype_list.append((k, py_type_to_dtype(v)))
            elif isinstance(dtype, list):
                dtype_slice = dtype
            else:
                raise ValueError(&quot;dtype arg should be list or dict&quot;)

        processed_null_values = _process_null_values(null_values)

        self._df = PyDataFrame.read_csv(
            file,
            infer_schema_length,
            batch_size,
            has_headers,
            ignore_errors,
            stop_after_n_rows,
            skip_rows,
            projection,
            sep,
            rechunk,
            columns,
            encoding,
            n_threads,
            path,
            dtype_list,
            dtype_slice,
            low_memory,
            comment_char,
            quote_char,
            processed_null_values,
            parse_dates,
        )
        return self

    @staticmethod
    def read_parquet(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from a parquet file.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_parquet(
            file, columns, projection, stop_after_n_rows
        )
        return self

    @staticmethod
    def read_ipc(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_ipc(file, columns, projection, stop_after_n_rows)
        return self

    @staticmethod
    def read_json(file: Union[str, BytesIO]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from JSON format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        &quot;&quot;&quot;
        if not isinstance(file, str):
            file = file.read().decode(&quot;utf8&quot;)
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_json(file)
        return self

    def to_arrow(self) -&gt; &quot;pa.Table&quot;:
        &quot;&quot;&quot;
        Collect the underlying arrow arrays in an Arrow Table.
        This operation is mostly zero copy.

        Data types that do copy:
            - CategoricalType
        &quot;&quot;&quot;
        if not _PYARROW_AVAILABLE:
            raise ImportError(
                &quot;'pyarrow' is required for converting a polars DataFrame to an Arrow Table.&quot;
            )
        record_batches = self._df.to_arrow()
        return pa.Table.from_batches(record_batches)

    def to_dict(
        self, as_series: bool = True
    ) -&gt; Union[Dict[str, &quot;pli.Series&quot;], Dict[str, tp.List[Any]]]:
        &quot;&quot;&quot;
        Convert DataFrame to a dictionary mapping column name to values.

        Parameters
        ----------
        as_series
            True -&gt; Values are series
            False -&gt; Values are List[Any]

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;      &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;      &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;      &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;      &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt;      &quot;optional&quot;: [28, 300, None, 2, -30],
        &gt;&gt;&gt; })
        shape: (5, 5)
        ┌─────┬──────────┬─────┬──────────┬──────────┐
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ optional │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64      │
        ╞═════╪══════════╪═════╪══════════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 28       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 300      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ null     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ -30      │
        └─────┴──────────┴─────┴──────────┴──────────┘
        &gt;&gt;&gt; df.to_dict(as_series=False)
        {'A': [1, 2, 3, 4, 5],
        'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'],
        'B': [5, 4, 3, 2, 1],
        'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'],
        'optional': [28, 300, None, 2, -30]}
        &gt;&gt;&gt; df.to_dict(as_series=True)
        {'A': shape: (5,)
         Series: 'A' [i64]
         [
            1
            2
            3
            4
            5
         ],
         'fruits': shape: (5,)
         ...
         Series: 'optional' [i64]
         [
            28
            300
            null
            2
            -30
         ]}

        &quot;&quot;&quot;
        if as_series:
            return {s.name: s for s in self}
        else:
            return {s.name: s.to_list() for s in self}

    def to_json(
        self,
        file: Optional[Union[BytesIO, str, Path]] = None,
        pretty: bool = False,
        to_string: bool = False,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Serialize to JSON representation.

        Parameters
        ----------
        file
            Write to this file instead of returning an string.
        pretty
            Pretty serialize json.
        to_string
            Ignore file argument and return a string.
        &quot;&quot;&quot;
        if to_string or file is None:
            file = BytesIO()
            self._df.to_json(file, pretty)
            file.seek(0)
            return file.read().decode(&quot;utf8&quot;)
        else:
            self._df.to_json(file, pretty)
            return None

    def to_pandas(
        self, *args: Any, date_as_object: bool = False, **kwargs: Any
    ) -&gt; &quot;pd.DataFrame&quot;:  # noqa: F821
        &quot;&quot;&quot;
        Cast to a Pandas DataFrame. This requires that Pandas is installed.
        This operation clones data.

        Parameters
        ----------
        args
            Arguments will be sent to pyarrow.Table.to_pandas.
        date_as_object
            Cast dates to objects. If False, convert to datetime64[ns] dtype.
        kwargs
            Arguments will be sent to pyarrow.Table.to_pandas.

        Examples
        --------

        &gt;&gt;&gt; import pandas
        &gt;&gt;&gt; df = pl.DataFrame({
            &quot;foo&quot;: [1, 2, 3],
            &quot;bar&quot;: [6, 7, 8],
            &quot;ham&quot;: ['a', 'b', 'c']
            })
        &gt;&gt;&gt; pandas_df = df.to_pandas()
        &gt;&gt;&gt; type(pandas_df)
        pandas.core.frame.DataFrame
        &quot;&quot;&quot;
        return self.to_arrow().to_pandas(*args, date_as_object=date_as_object, **kwargs)

    def to_csv(
        self,
        file: Optional[Union[TextIO, BytesIO, str, Path]] = None,
        has_headers: bool = True,
        sep: str = &quot;,&quot;,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Write Dataframe to comma-separated values file (csv).

        Parameters
        ---
        file
            File path to which the file should be written.
        has_headers
            Whether or not to include header in the CSV output.
        sep
            Separate CSV fields with this symbol.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_csv('new_file.csv', sep=',')

        &quot;&quot;&quot;
        if file is None:
            buffer = BytesIO()
            self._df.to_csv(buffer, has_headers, ord(sep))
            return str(buffer.getvalue(), encoding=&quot;utf-8&quot;)

        if isinstance(file, Path):
            file = str(file)

        self._df.to_csv(file, has_headers, ord(sep))
        return None

    def to_ipc(
        self,
        file: Union[BinaryIO, BytesIO, str, Path],
        compression: str = &quot;uncompressed&quot;,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write to Arrow IPC binary stream, or a feather file.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        &quot;&quot;&quot;
        if isinstance(file, Path):
            file = str(file)

        self._df.to_ipc(file, compression)

    def to_dicts(self) -&gt; tp.List[Dict[str, Any]]:
        pydf = self._df
        names = self.columns

        return [
            {k: v for k, v in zip(names, pydf.row_tuple(i))}
            for i in range(0, self.height)
        ]

    def transpose(
        self,
        include_header: bool = False,
        header_name: str = &quot;column&quot;,
        column_names: Optional[Union[tp.Iterator[str], tp.Sequence[str]]] = None,
    ) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Transpose a DataFrame over the diagonal.

        Parameters
        ----------
        include_header:
            If set, the column names will be added as first column.
        header_name:
            If `include_header` is set, this determines the name of the column that will be inserted
        column_names:
            Optional generator/iterator that yields column names. Will be used to replace the columns in the DataFrame.

        Notes
        -----
        This is a very expensive operation. Perhaps you can do it differently.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [1, 2, 3]})
        &gt;&gt;&gt; df.transpose(include_header=True)
        shape: (2, 4)
        ┌────────┬──────────┬──────────┬──────────┐
        │ column ┆ column_0 ┆ column_1 ┆ column_2 │
        │ ---    ┆ ---      ┆ ---      ┆ ---      │
        │ str    ┆ i64      ┆ i64      ┆ i64      │
        ╞════════╪══════════╪══════════╪══════════╡
        │ a      ┆ 1        ┆ 2        ┆ 3        │
        ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ b      ┆ 1        ┆ 2        ┆ 3        │
        └────────┴──────────┴──────────┴──────────┘

        # replace the auto generated column names with a list
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt; # include the header as a separate column
        &gt;&gt;&gt; df.transpose(include_header=True, header_name=&quot;foo&quot;, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 4)
        ┌─────┬─────┬─────┬─────┐
        │ foo ┆ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╪═════╡
        │ a   ┆ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┴─────┘

        &gt;&gt;&gt; # replace the auto generated column with column names from a generator function
        &gt;&gt;&gt; def name_generator():
        &gt;&gt;&gt;     base_name = &quot;my_column_&quot;
        &gt;&gt;&gt;     count = 0
        &gt;&gt;&gt;     while True:
        &gt;&gt;&gt;         yield f&quot;{base_name}{count}&quot;
        &gt;&gt;&gt;         count += 1
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=name_generator())
        shape: (2, 3)
        ┌─────────────┬─────────────┬─────────────┐
        │ my_column_0 ┆ my_column_1 ┆ my_column_2 │
        │ ---         ┆ ---         ┆ ---         │
        │ i64         ┆ i64         ┆ i64         │
        ╞═════════════╪═════════════╪═════════════╡
        │ 1           ┆ 2           ┆ 3           │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 1           ┆ 2           ┆ 3           │
        └─────────────┴─────────────┴─────────────┘

        &quot;&quot;&quot;
        df = wrap_df(self._df.transpose(include_header, header_name))
        if column_names is not None:
            names = []
            n = df.width
            if include_header:
                names.append(header_name)
                n -= 1

            column_names = iter(column_names)
            for _ in range(n):
                names.append(next(column_names))
            df.columns = names
        return df

    def to_parquet(
        self,
        file: Union[str, Path, BytesIO],
        compression: Optional[str] = &quot;snappy&quot;,
        use_pyarrow: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write the DataFrame disk in parquet format.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot; (not supported by pyarrow)
                - &quot;snappy&quot;
                - &quot;gzip&quot;
                - &quot;lzo&quot;
                - &quot;brotli&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        use_pyarrow
            Use C++ parquet implementation vs rust parquet implementation.
            At the moment C++ supports more features.

        **kwargs are passed to pyarrow.parquet.write_table
        &quot;&quot;&quot;
        if compression is None:
            compression = &quot;uncompressed&quot;
        if isinstance(file, Path):
            file = str(file)

        if use_pyarrow:
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required when using 'to_parquet(..., use_pyarrow=True)'.&quot;
                )

            tbl = self.to_arrow()

            data = {}

            for i, column in enumerate(tbl):
                # extract the name before casting
                if column._name is None:
                    name = f&quot;column_{i}&quot;
                else:
                    name = column._name

                data[name] = column
            tbl = pa.table(data)

            pa.parquet.write_table(
                table=tbl, where=file, compression=compression, **kwargs
            )
        else:
            self._df.to_parquet(file, compression)

    def to_numpy(self) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert DataFrame to a 2d numpy array.
        This operation clones data.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; numpy_array = df.to_numpy()
        &gt;&gt;&gt; type(numpy_array)
        numpy.ndarray

        &quot;&quot;&quot;
        return np.vstack([self.to_series(i).to_numpy() for i in range(self.width)]).T

    def __getstate__(self):  # type: ignore
        return self.get_columns()

    def __setstate__(self, state):  # type: ignore
        self._df = DataFrame(state)._df

    def __mul__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.mul(other._s))

    def __truediv__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.div(other._s))

    def __add__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.add(other._s))

    def __sub__(self, other: Any) -&gt; &quot;DataFrame&quot;:
        other = _prepare_other_arg(other)
        return wrap_df(self._df.sub(other._s))

    def __str__(self) -&gt; str:
        return self._df.as_str()

    def __repr__(self) -&gt; str:
        return self.__str__()

    def __getattr__(self, item: Any) -&gt; &quot;PySeries&quot;:
        &quot;&quot;&quot;
        Access columns as attribute.
        &quot;&quot;&quot;
        try:
            return pli.wrap_s(self._df.column(item))
        except RuntimeError:
            raise AttributeError(f&quot;{item} not found&quot;)

    def __iter__(self) -&gt; Iterator[Any]:
        return self.get_columns().__iter__()

    def find_idx_by_name(self, name: str) -&gt; int:
        &quot;&quot;&quot;
        Find the index of a column by name.

        Parameters
        ----------
        name
            Name of the column to find.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.find_idx_by_name(&quot;ham&quot;))
        2

        &quot;&quot;&quot;
        return self._df.find_idx_by_name(name)

    def _pos_idx(self, idx: int, dim: int) -&gt; int:
        if idx &gt;= 0:
            return idx
        else:
            return self.shape[dim] + idx

    def __getitem__(self, item: Any) -&gt; Any:
        &quot;&quot;&quot;
        Does quite a lot. Read the comments.
        &quot;&quot;&quot;
        if hasattr(item, &quot;_pyexpr&quot;):
            return self.select(item)
        if isinstance(item, np.ndarray):
            item = pli.Series(&quot;&quot;, item)
        # select rows and columns at once
        # every 2d selection, i.e. tuple is row column order, just like numpy
        if isinstance(item, tuple):
            row_selection, col_selection = item

            # df[:, unknown]
            if isinstance(row_selection, slice):

                # multiple slices
                # df[:, :]
                if isinstance(col_selection, slice):
                    # slice can be
                    # by index
                    #   [1:8]
                    # or by column name
                    #   [&quot;foo&quot;:&quot;bar&quot;]
                    # first we make sure that the slice is by index
                    start = col_selection.start
                    stop = col_selection.stop
                    if isinstance(col_selection.start, str):
                        start = self.find_idx_by_name(col_selection.start)
                    if isinstance(col_selection.stop, str):
                        stop = self.find_idx_by_name(col_selection.stop) + 1

                    col_selection = slice(start, stop, col_selection.step)

                    df = self.__getitem__(self.columns[col_selection])
                    return df[row_selection]

                # slice and boolean mask
                # df[:2, [True, False, True]]
                if isinstance(col_selection, (Sequence, pli.Series)):
                    if (
                        isinstance(col_selection[0], bool)
                        or isinstance(col_selection, pli.Series)
                        and col_selection.dtype() == Boolean
                    ):
                        df = self.__getitem__(row_selection)
                        select = []
                        for col, valid in zip(df.columns, col_selection):
                            if valid:
                                select.append(col)
                        return df.select(select)

                # single slice
                # df[:, unknown]
                series = self.__getitem__(col_selection)
                # s[:]
                pli.wrap_s(series[row_selection])

            # df[2, :] (select row as df)
            if isinstance(row_selection, int):
                if isinstance(col_selection, (slice, list, np.ndarray)):
                    df = self[:, col_selection]
                    return df.slice(row_selection, 1)
                # df[2, &quot;a&quot;]
                if isinstance(col_selection, str):
                    return self[col_selection][row_selection]

            # column selection can be &quot;a&quot; and [&quot;a&quot;, &quot;b&quot;]
            if isinstance(col_selection, str):
                col_selection = [col_selection]

            # df[:, 1]
            if isinstance(col_selection, int):
                series = self.to_series(col_selection)
                return series[row_selection]

            if isinstance(col_selection, list):
                # df[:, [1, 2]]
                # select by column indexes
                if isinstance(col_selection[0], int):
                    series = [self.to_series(i) for i in col_selection]
                    df = DataFrame(series)
                    return df[row_selection]
            df = self.__getitem__(col_selection)
            return df.__getitem__(row_selection)

        # select single column
        # df[&quot;foo&quot;]
        if isinstance(item, str):
            return pli.wrap_s(self._df.column(item))

        # df[idx]
        if isinstance(item, int):
            return self.slice(self._pos_idx(item, dim=0), 1)

        # df[range(n)]
        if isinstance(item, range):
            step: Optional[int]
            # maybe we can slice instead of take by indices
            if item.step != 1:
                step = item.step
            else:
                step = None
            slc = slice(item.start, item.stop, step)
            return self[slc]

        # df[:]
        if isinstance(item, slice):
            # special case df[::-1]
            if item.start is None and item.stop is None and item.step == -1:
                return self.select(pli.col(&quot;*&quot;).reverse())  # type: ignore

            if getattr(item, &quot;end&quot;, False):
                raise ValueError(&quot;A slice with steps larger than 1 is not supported.&quot;)
            if item.start is None:
                start = 0
            else:
                start = item.start
            if item.stop is None:
                stop = self.height
            else:
                stop = item.stop

            length = stop - start
            if item.step is None:
                # df[start:stop]
                return self.slice(start, length)
            else:
                # df[start:stop:step]
                return self.select(
                    pli.col(&quot;*&quot;).slice(start, length).take_every(item.step)  # type: ignore
                )

        # select multiple columns
        # df[&quot;foo&quot;, &quot;bar&quot;]
        if isinstance(item, Sequence):
            if isinstance(item[0], str):
                return wrap_df(self._df.select(item))
            elif isinstance(item[0], pli.Expr):
                return self.select(item)

        # select rows by mask or index
        # df[[1, 2, 3]]
        # df[true, false, true]
        if isinstance(item, np.ndarray):
            if item.dtype == int:
                return wrap_df(self._df.take(item))
            if isinstance(item[0], str):
                return wrap_df(self._df.select(item))
        if isinstance(item, (pli.Series, Sequence)):
            if isinstance(item, Sequence):
                # only bool or integers allowed
                if type(item[0]) == bool:
                    item = pli.Series(&quot;&quot;, item)
                else:
                    return wrap_df(
                        self._df.take([self._pos_idx(i, dim=0) for i in item])
                    )
            dtype = item.dtype
            if dtype == Boolean:
                return wrap_df(self._df.filter(item.inner()))
            if dtype == UInt32:
                return wrap_df(self._df.take_with_series(item.inner()))

    def __setitem__(self, key: Union[str, int, Tuple[Any, Any]], value: Any) -&gt; None:
        # df[&quot;foo&quot;] = series
        if isinstance(key, str):
            try:
                self.replace(key, pli.Series(key, value))
            except Exception:
                self.hstack([pli.Series(key, value)], in_place=True)
        # df[idx] = series
        elif isinstance(key, int):
            assert isinstance(value, pli.Series)
            self.replace_at_idx(key, value)
        # df[[&quot;C&quot;, &quot;D&quot;]]
        elif isinstance(key, list):
            value = np.array(value)
            if len(value.shape) != 2:
                raise ValueError(&quot;can only set multiple columns with 2D matrix&quot;)
            if value.shape[1] != len(key):
                raise ValueError(
                    &quot;matrix columns should be equal to list use to determine column names&quot;
                )
            for (i, name) in enumerate(key):
                self[name] = value[:, i]

        # df[a, b]
        elif isinstance(key, tuple):
            row_selection, col_selection = key

            # get series column selection
            if isinstance(col_selection, str):
                s = self.__getitem__(col_selection)
            elif isinstance(col_selection, int):
                s = self[:, col_selection]
            else:
                raise ValueError(f&quot;column selection not understood: {col_selection}&quot;)

            # dispatch to __setitem__ of Series to do modification
            s[row_selection] = value

            # now find the location to place series
            # df[idx]
            if isinstance(col_selection, int):
                self.replace_at_idx(col_selection, s)
            # df[&quot;foo&quot;]
            elif isinstance(col_selection, str):
                self.replace(col_selection, s)
        else:
            raise NotImplementedError

    def __len__(self) -&gt; int:
        return self.height

    def _repr_html_(self) -&gt; str:
        &quot;&quot;&quot;
        Used by jupyter notebooks to get a html table.

        Output rows and columns can be modified by setting the following ENVIRONMENT variables:

        * POLARS_FMT_MAX_COLS: set the number of columns
        * POLARS_FMT_MAX_ROWS: set the number of rows
        &quot;&quot;&quot;
        max_cols = int(os.environ.get(&quot;POLARS_FMT_MAX_COLS&quot;, default=75))
        max_rows = int(os.environ.get(&quot;POLARS_FMT_MAX_ROWS&quot;, default=25))
        return &quot;\n&quot;.join(NotebookFormatter(self, max_cols, max_rows).render())

    def to_series(self, index: int = 0) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column as Series at index location.

        Parameters
        ----------
        index
            Location of selection.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_series(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(index))

    def rename(self, mapping: Dict[str, str]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rename column names.

        Parameters
        ----------
        mapping
            Key value pairs that map from old name to new name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df.rename({&quot;foo&quot;: &quot;apple&quot;})
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 1     ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2     ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3     ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        df = self.clone()
        for k, v in mapping.items():
            df._df.rename(k, v)
        return df

    def insert_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Insert a Series at a certain column index. This operation is in place.

        Parameters
        ----------
        index
            Column to insert the new `Series` column.
        series
            `Series` to insert.
        &quot;&quot;&quot;
        self._df.insert_at_idx(index, series._s)

    def filter(self, predicate: &quot;pli.Expr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Filter the rows in the DataFrame based on a predicate expression.

        Parameters
        ----------
        predicate
            Expression that evaluates to a boolean Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; # Filter on one condition
        &gt;&gt;&gt; df.filter(pl.col(&quot;foo&quot;) &lt; 3)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ b   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt;  # Filter on multiple conditions
        &gt;&gt;&gt; df.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;))
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .filter(predicate)
            .collect(no_optimization=True, string_cache=False)
        )

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &quot;&quot;&quot;
        Get the shape of the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.shape
        shape: (5, 1)

        &quot;&quot;&quot;
        return self._df.shape()

    @property
    def height(self) -&gt; int:
        &quot;&quot;&quot;
        Get the height of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.height
        5

        &quot;&quot;&quot;
        return self._df.height()

    @property
    def width(self) -&gt; int:
        &quot;&quot;&quot;
        Get the width of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.width
        1
        &quot;&quot;&quot;
        return self._df.width()

    @property
    def columns(self) -&gt; tp.List[str]:
        &quot;&quot;&quot;
        Get or set column names.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
            &quot;foo&quot;: [1, 2, 3],
            &quot;bar&quot;: [6, 7, 8],
            &quot;ham&quot;: ['a', 'b', 'c']
            })
        &gt;&gt;&gt; df.columns
        ['foo', 'bar', 'ham']
        &gt;&gt;&gt; # Set column names
        &gt;&gt;&gt; df.columns = ['apple', 'banana', 'orange']
        shape: (3, 3)
        ╭───────┬────────┬────────╮
        │ apple ┆ banana ┆ orange │
        │ ---   ┆ ---    ┆ ---    │
        │ i64   ┆ i64    ┆ str    │
        ╞═══════╪════════╪════════╡
        │ 1     ┆ 6      ┆ &quot;a&quot;    │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2     ┆ 7      ┆ &quot;b&quot;    │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 3     ┆ 8      ┆ &quot;c&quot;    │
        ╰───────┴────────┴────────╯

        &quot;&quot;&quot;
        return self._df.columns()

    @columns.setter
    def columns(self, columns: Sequence[str]) -&gt; None:
        &quot;&quot;&quot;
        Change the column names of the `DataFrame`.

        Parameters
        ----------
        columns
            A list with new names for the `DataFrame`.
            The length of the list should be equal to the width of the `DataFrame`.
        &quot;&quot;&quot;
        self._df.set_column_names(columns)

    @property
    def dtypes(self) -&gt; tp.List[Type[DataType]]:
        &quot;&quot;&quot;
        Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.dtypes
        [polars.datatypes.Int64, polars.datatypes.Float64, polars.datatypes.Utf8]
        &gt;&gt;&gt; df
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return [DTYPES[idx] for idx in self._df.dtypes()]

    def describe(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     'a': [1.0, 2.8, 3.0],
        &gt;&gt;&gt;     'b': [4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [True, False, True]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.describe()
        shape: (5, 4)
        ╭──────────┬───────┬─────┬──────╮
        │ describe ┆ a     ┆ b   ┆ c    │
        │ ---      ┆ ---   ┆ --- ┆ ---  │
        │ str      ┆ f64   ┆ f64 ┆ f64  │
        ╞══════════╪═══════╪═════╪══════╡
        │ &quot;mean&quot;   ┆ 2.267 ┆ 5   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;std&quot;    ┆ 1.102 ┆ 1   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;min&quot;    ┆ 1     ┆ 4   ┆ 0.0  │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;max&quot;    ┆ 3     ┆ 6   ┆ 1    │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;median&quot; ┆ 2.8   ┆ 5   ┆ null │
        ╰──────────┴───────┴─────┴──────╯

        &quot;&quot;&quot;

        def describe_cast(self: &quot;DataFrame&quot;) -&gt; &quot;DataFrame&quot;:
            columns = []
            for s in self:
                if s.is_numeric() or s.is_boolean():
                    columns.append(s.cast(float))
                else:
                    columns.append(s)
            return DataFrame(columns)

        summary = pli.concat(
            [
                describe_cast(self.mean()),  # type: ignore
                describe_cast(self.std()),
                describe_cast(self.min()),  # type: ignore
                describe_cast(self.max()),  # type: ignore
                describe_cast(self.median()),
            ]
        )
        summary.insert_at_idx(  # type: ignore
            0, pli.Series(&quot;describe&quot;, [&quot;mean&quot;, &quot;std&quot;, &quot;min&quot;, &quot;max&quot;, &quot;median&quot;])
        )
        return summary  # type: ignore

    def replace_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column at an index location.

        Parameters
        ----------
        index
            Column index.
        series
            Series that will replace the column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.replace_at_idx(0, x)
        shape: (3, 3)
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 10    ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 20    ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 30    ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        self._df.replace_at_idx(index, series._s)

    def sort(
        self,
        by: Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]],
        reverse: Union[bool, tp.List[bool]] = False,
        in_place: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sort the DataFrame by column.

        Parameters
        ----------
        by
            By which column to sort. Only accepts string.
        reverse
            Reverse/descending sort.
        in_place
            Perform operation in-place.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sort('foo', reverse=True)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ╰─────┴─────┴─────╯

        **Sort by multiple columns.**
        For multiple columns we can also use expression syntax.

        &gt;&gt;&gt; df.sort([pl.col(&quot;foo&quot;), pl.col(&quot;bar&quot;) ** 2], reverse=[True, False])

        &quot;&quot;&quot;
        if type(by) is list or isinstance(by, pli.Expr):
            df = (
                self.lazy()
                .sort(by, reverse)
                .collect(no_optimization=True, string_cache=False)
            )
            if in_place:
                self._df = df._df
                return self
            return df
        if in_place:
            self._df.sort_in_place(by, reverse)
            return self
        else:
            return wrap_df(self._df.sort(by, reverse))

    def frame_equal(self, other: &quot;DataFrame&quot;, null_equal: bool = True) -&gt; bool:
        &quot;&quot;&quot;
        Check if DataFrame is equal to other.

        Parameters
        ----------
        other
            DataFrame to compare with.
        null_equal
            Consider null values as equal.

        Examples
        --------
        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 2, 1],
        &gt;&gt;&gt;     &quot;bar&quot;: [8.0, 7.0, 6.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'b', 'a']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.frame_equal(df1)
        True
        &gt;&gt;&gt; df1.frame_equal(df2)
        False

        &quot;&quot;&quot;
        return self._df.frame_equal(other._df, null_equal)

    def replace(self, column: str, new_col: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column by a new Series.

        Parameters
        ----------
        column
            Column to replace.
        new_col
            New column to insert.
        &quot;&quot;&quot;
        self._df.replace(column, new_col.inner())

    def slice(self, offset: int, length: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Slice this DataFrame over the rows direction.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.slice(1, 2)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        if length &lt; 0:
            length = self.height - offset + length
        return wrap_df(self._df.slice(offset, length))

    def limit(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        See Also `DataFrame.head`

        Parameters
        ----------
        length
            Amount of rows to take.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.limit(2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return self.head(length)

    def head(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.head(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.head(length))

    def tail(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get last N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.tail(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 5   ┆ 10  ┆ &quot;e&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.tail(length))

    def drop_nulls(self, subset: Optional[tp.List[str]] = None) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame where the null values are dropped.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, None, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.drop_nulls()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        This method only drops nulls row-wise if any single value of the row is null.

        Below are some example snippets that show how you could drop null values based on other
        conditions

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {
        &gt;&gt;&gt;        &quot;a&quot;: [None, None, None, None],
        &gt;&gt;&gt;        &quot;b&quot;: [1, 2, None, 1],
        &gt;&gt;&gt;        &quot;c&quot;: [1, None, None, 1],
        &gt;&gt;&gt;    }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df
        shape: (4, 3)
        ┌──────┬──────┬──────┐
        │ a    ┆ b    ┆ c    │
        │ ---  ┆ ---  ┆ ---  │
        │ f64  ┆ i64  ┆ i64  │
        ╞══════╪══════╪══════╡
        │ null ┆ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1    ┆ 1    │
        └──────┴──────┴──────┘

        &gt;&gt;&gt; # drop a row only if all values are null
        &gt;&gt;&gt; df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
        shape: (3, 3)
        ┌──────┬─────┬──────┐
        │ a    ┆ b   ┆ c    │
        │ ---  ┆ --- ┆ ---  │
        │ f64  ┆ i64 ┆ i64  │
        ╞══════╪═════╪══════╡
        │ null ┆ 1   ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2   ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1   ┆ 1    │
        └──────┴─────┴──────┘

        &gt;&gt;&gt; # drop a column if all values are null
        &gt;&gt;&gt; df[:, [not (s.null_count() == df.height) for s in df]]
        shape: (4, 2)
        ┌──────┬──────┐
        │ b    ┆ c    │
        │ ---  ┆ ---  │
        │ i64  ┆ i64  │
        ╞══════╪══════╡
        │ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 1    │
        └──────┴──────┘

        &quot;&quot;&quot;
        if subset is not None and isinstance(subset, str):
            subset = [subset]
        return wrap_df(self._df.drop_nulls(subset))

    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:
        &quot;&quot;&quot;
        Apply a function on Self.

        Parameters
        ----------
        func
            Callable.
        args
            Arguments.
        kwargs
            Keyword arguments.
        &quot;&quot;&quot;
        return func(self, *args, **kwargs)

    def with_row_count(self, name: str = &quot;row_nr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add a column at index 0 that counts the rows.

        Parameters
        ----------
        name
            Name of the column to add.
        &quot;&quot;&quot;
        return wrap_df(self._df.with_row_count(name))

    def groupby(
        self,
        by: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]],
        maintain_order: bool = False,
    ) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a groupby operation.

        Parameters
        ----------
        by
            Column(s) to group by.
        maintain_order
            Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
            Note that this only works in expression aggregations.

        Examples
        --------
        Below we group by column `&quot;a&quot;`, and we sum column `&quot;b&quot;`.

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;],
        &gt;&gt;&gt;     &quot;b&quot;: [1, 2, 3, 4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [6, 5, 4, 3, 2, 1],
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; assert (
        &gt;&gt;&gt;     df.groupby(&quot;a&quot;)[&quot;b&quot;]
        &gt;&gt;&gt;     .sum()
        &gt;&gt;&gt;     .sort(by_column=&quot;a&quot;)
        &gt;&gt;&gt;     .frame_equal(DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;: [4, 11, 6]})))

        We can also loop over the grouped `DataFrame`

        &gt;&gt;&gt; for sub_df in df.groupby(&quot;a&quot;):
        &gt;&gt;&gt;    print(sub_df)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;b&quot; ┆ 2   ┆ 5   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 4   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 5   ┆ 2   │
        ╰─────┴─────┴─────╯
        shape: (1, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;c&quot; ┆ 6   ┆ 1   │
        ╰─────┴─────┴─────╯
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;a&quot; ┆ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot; ┆ 3   ┆ 4   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(by, str):
            by = [by]
        return GroupBy(
            self._df, by, maintain_order=maintain_order, downsample=False  # type: ignore
        )

    def downsample(self, by: Union[str, tp.List[str]], rule: str, n: int) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a downsampling groupby operation.

        Parameters
        ----------
        by
            Column that will be used as key in the groupby operation.
            This should be a datetime/date column.
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-02&quot;, &quot;2020-01-03&quot;,&quot;2020-01-04&quot;,&quot;2020-01-05&quot;,&quot;2020-01-06&quot;],
        &gt;&gt;&gt;         &quot;B&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0],
        &gt;&gt;&gt;         &quot;C&quot;: [3.0, 6.0, 9.0, 2.0, 13.0, 8.0],
        &gt;&gt;&gt;         &quot;D&quot;: [12.0, 5.0, 9.0, 2.0, 11.0, 2.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df['A'] = df['A'].str.strptime(pl.Date, &quot;%Y-%m-%d&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; df.downsample(&quot;A&quot;, rule=&quot;day&quot;, n=3).agg(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;B&quot;: &quot;max&quot;,
        &gt;&gt;&gt;         &quot;C&quot;: &quot;min&quot;,
        &gt;&gt;&gt;         &quot;D&quot;: &quot;last&quot;
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        shape: (3, 4)
        ┌──────────────┬───────┬───────┬────────┐
        │ A            ┆ B_max ┆ C_min ┆ D_last │
        │ ---          ┆ ---   ┆ ---   ┆ ---    │
        │ date(days)   ┆ f64   ┆ f64   ┆ f64    │
        ╞══════════════╪═══════╪═══════╪════════╡
        │ 2019-12-31   ┆ 8     ┆ 3     ┆ 5      │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-03   ┆ 16    ┆ 2     ┆ 11     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-06   ┆ 10    ┆ 8     ┆ 2      │
        └──────────────┴───────┴───────┴────────┘

        &quot;&quot;&quot;
        return GroupBy(
            self._df,
            by,
            maintain_order=False,
            downsample=True,
            rule=rule,
            downsample_n=n,
        )

    def upsample(self, by: str, interval: timedelta) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Upsample a DataFrame at a regular frequency.

        Parameters
        ----------
        by
            Column that will be used as key in the upsampling operation.
            This should be a datetime column.
        interval
            Interval periods.
        &quot;&quot;&quot;
        if self[by].dtype != Datetime:
            raise ValueError(
                f&quot;Column {by} should be of type datetime. Got {self[by].dtype}&quot;
            )
        bounds = self.select(
            [pli.col(by).min().alias(&quot;low&quot;), pli.col(by).max().alias(&quot;high&quot;)]
        )
        low = bounds[&quot;low&quot;].dt[0]
        high = bounds[&quot;high&quot;].dt[0]
        upsampled = pli.date_range(low, high, interval, name=by)
        return DataFrame(upsampled).join(self, on=by, how=&quot;left&quot;)  # type: ignore

    def join(
        self,
        df: &quot;DataFrame&quot;,
        left_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        right_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        on: Optional[Union[str, tp.List[str]]] = None,
        how: str = &quot;inner&quot;,
        suffix: str = &quot;_right&quot;,
        asof_by: Optional[Union[str, tp.List[str]]] = None,
        asof_by_left: Optional[Union[str, tp.List[str]]] = None,
        asof_by_right: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        SQL like joins.

        Parameters
        ----------
        df
            DataFrame to join with.
        left_on
            Name(s) of the left join column(s).
        right_on
            Name(s) of the right join column(s).
        on
            Name(s) of the join columns in both DataFrames.
        how
            Join strategy
                - &quot;inner&quot;
                - &quot;left&quot;
                - &quot;outer&quot;
                - &quot;asof&quot;
                - &quot;cross&quot;
        suffix
            Suffix to append to columns with a duplicate name.
        asof_by
            join on these columns before doing asof join
        asof_by_left
            join on these columns before doing asof join
        asof_by_right
            join on these columns before doing asof join
        Returns
        -------
            Joined DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; other_df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;apple&quot;: ['x', 'y', 'z'],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.join(other_df, on='ham')
        shape: (2, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ f64 ┆ str ┆ str   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ╰─────┴─────┴─────┴───────╯

        &gt;&gt;&gt; df.join(other_df, on='ham', how='outer')
        shape: (4, 4)
        ╭──────┬──────┬─────┬───────╮
        │ foo  ┆ bar  ┆ ham ┆ apple │
        │ ---  ┆ ---  ┆ --- ┆ ---   │
        │ i64  ┆ f64  ┆ str ┆ str   │
        ╞══════╪══════╪═════╪═══════╡
        │ 1    ┆ 6    ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ null ┆ null ┆ &quot;d&quot; ┆ &quot;z&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot; ┆ null  │
        ╰──────┴──────┴─────┴───────╯

        Asof join
        =========
        This is similar to a left-join except that we match on nearest key rather than equal keys.
        The keys must be sorted to perform an asof join

        &quot;&quot;&quot;
        if how == &quot;cross&quot;:
            return wrap_df(self._df.join(df._df, [], [], how, suffix))

        left_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(left_on, (str, pli.Expr)):
            left_on_ = [left_on]  # type: ignore[assignment]
        else:
            left_on_ = left_on

        right_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(right_on, (str, pli.Expr)):
            right_on_ = [right_on]  # type: ignore[assignment]
        else:
            right_on_ = right_on

        if isinstance(on, str):
            left_on_ = [on]
            right_on_ = [on]
        elif isinstance(on, list):
            left_on_ = on
            right_on_ = on

        if left_on_ is None or right_on_ is None:
            raise ValueError(&quot;You should pass the column to join on as an argument.&quot;)

        if (
            isinstance(left_on_[0], pli.Expr)
            or isinstance(right_on_[0], pli.Expr)
            or asof_by_left is not None
            or asof_by_right is not None
            or asof_by is not None
        ):
            return (
                self.lazy()
                .join(
                    df.lazy(),
                    left_on,
                    right_on,
                    on=on,
                    how=how,
                    suffix=suffix,
                    asof_by_right=asof_by_right,
                    asof_by_left=asof_by_left,
                    asof_by=asof_by,
                )
                .collect(no_optimization=True)
            )
        else:
            return wrap_df(self._df.join(df._df, left_on_, right_on_, how, suffix))

    def apply(
        self,
        f: Callable[[Tuple[Any]], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.

        Beware, this is slow.

        Parameters
        ----------
        f
            Custom function/ lambda function.
        return_dtype
            Output type of the operation. If none given, Polars tries to infer the type.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.apply(f, return_dtype))

    def with_column(self, column: Union[&quot;pli.Series&quot;, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column added or replaced.

        Parameters
        ----------
        column
            Series, where the name of the Series refers to the column in the DataFrame.
        &quot;&quot;&quot;
        if isinstance(column, pli.Expr):
            return self.with_columns([column])
        else:
            return wrap_df(self._df.with_column(column._s))

    def with_column_renamed(self, existing_name: str, new_name: str) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column renamed.

        Parameters
        ----------
        existing_name
        new_name
        &quot;&quot;&quot;
        return (
            self.lazy()
            .with_column_renamed(existing_name, new_name)
            .collect(no_optimization=True, string_cache=False)
        )

    def hstack(
        self, columns: Union[tp.List[&quot;pli.Series&quot;], &quot;DataFrame&quot;], in_place: bool = False
    ) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Return a new DataFrame grown horizontally by stacking multiple Series to it.

        Parameters
        ----------
        columns
            Series to stack.
        in_place
            Modify in place.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.hstack([x])
        shape: (3, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ i64 ┆ str ┆ i64   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ 10    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ 20    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; ┆ 30    │
        ╰─────┴─────┴─────┴───────╯

        &quot;&quot;&quot;
        if not isinstance(columns, list):
            columns = columns.get_columns()
        if in_place:
            self._df.hstack_mut([s.inner() for s in columns])
            return None
        else:
            return wrap_df(self._df.hstack([s.inner() for s in columns]))

    def vstack(self, df: &quot;DataFrame&quot;, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Grow this DataFrame vertically by stacking a DataFrame to it.

        Parameters
        ----------
        df
            DataFrame to stack.
        in_place
            Modify in place

        Examples
        --------

        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 4],
        &gt;&gt;&gt;     &quot;bar&quot;: [8 , 9],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.vstack(df2)
        shape: (4, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if in_place:
            self._df.vstack_mut(df._df)
            return None
        else:
            return wrap_df(self._df.vstack(df._df))

    def drop(self, name: Union[str, tp.List[str]]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Remove column from DataFrame and return as new.

        Parameters
        ----------
        name
            Column(s) to drop.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop('ham')
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ f64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(name, list):
            df = self.clone()

            for name in name:
                df._df.drop_in_place(name)
            return df

        return wrap_df(self._df.drop(name))

    def drop_in_place(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Drop in place.

        Parameters
        ----------
        name
            Column to drop.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop_in_place(&quot;ham&quot;)
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ i64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.drop_in_place(name))

    def select_at_idx(self, idx: int) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column at index location.

        Parameters
        ----------
        idx
            Location of selection.

        .. deprecated:: 0.10.20

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select_at_idx(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(idx))

    def clone(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Very cheap deep clone.
        &quot;&quot;&quot;
        return wrap_df(self._df.clone())

    def __copy__(self) -&gt; &quot;DataFrame&quot;:
        return self.clone()

    def __deepcopy__(self, memodict={}) -&gt; &quot;DataFrame&quot;:  # type: ignore
        return self.clone()

    def get_columns(self) -&gt; tp.List[&quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Get the DataFrame as a List of Series.
        &quot;&quot;&quot;
        return list(map(lambda s: pli.wrap_s(s), self._df.get_columns()))

    def get_column(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a single column as Series by name.
        &quot;&quot;&quot;
        return self[name]

    def fill_null(self, strategy: Union[str, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a filling strategy or an Expression evaluation.

        Parameters
        ----------
        strategy
            One of:
            - &quot;backward&quot;
            - &quot;forward&quot;
            - &quot;mean&quot;
            - &quot;min'
            - &quot;max&quot;
            - &quot;zero&quot;
            - &quot;one&quot;
            Or an expression.

        Returns
        -------
            DataFrame with None replaced with the filling strategy.
        &quot;&quot;&quot;
        if isinstance(strategy, pli.Expr):
            return self.lazy().fill_null(strategy).collect(no_optimization=True)
        if not isinstance(strategy, str):
            return self.fill_null(pli.lit(strategy))
        return wrap_df(self._df.fill_null(strategy))

    def fill_nan(self, fill_value: Union[&quot;pli.Expr&quot;, int, float]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a an Expression evaluation.

        Warnings
        --------
        NOTE that floating point NaN (No a Number) are not missing values!
        to replace missing values, use `fill_null`.

        Parameters
        ----------
        fill_value
            value to fill NaN with

        Returns
        -------
            DataFrame with NaN replaced with fill_value
        &quot;&quot;&quot;
        return self.lazy().fill_nan(fill_value).collect(no_optimization=True)

    def explode(
        self, columns: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Explode `DataFrame` to long format by exploding a column with Lists.

        Parameters
        ----------
        columns
            Column of LargeList type.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬────────────╮
        │ letters ┆ nrs        │
        │ ---     ┆ ---        │
        │ str     ┆ list [i64] │
        ╞═════════╪════════════╡
        │ &quot;c&quot;     ┆ [1, 2]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [1, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [4, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [5, 5, 5]  │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [6]        │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ [2, 1, 2]  │
        ╰─────────┴────────────╯
        &gt;&gt;&gt; df.explode(&quot;nrs&quot;)
        shape: (13, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ ...     ┆ ... │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return self.lazy().explode(columns).collect(no_optimization=True)

    def melt(
        self, id_vars: Union[tp.List[str], str], value_vars: Union[tp.List[str], str]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Unpivot DataFrame to long format.

        Parameters
        ----------
        id_vars
            Columns to use as identifier variables.

        value_vars
            Values to use as identifier variables.

        Returns
        -------

        &quot;&quot;&quot;
        if isinstance(value_vars, str):
            value_vars = [value_vars]
        if isinstance(id_vars, str):
            id_vars = [id_vars]
        return wrap_df(self._df.melt(id_vars, value_vars))

    def shift(self, periods: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift(periods=1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 6    ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        └──────┴──────┴──────┘
        &gt;&gt;&gt; df.shift(periods=-1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        └──────┴──────┴──────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.shift(periods))

    def shift_and_fill(
        self, periods: int, fill_value: Union[int, str, float]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            fill None values with this value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift_and_fill(periods=1, fill_value=0)
        shape: (3, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 0   ┆ 0   ┆ &quot;0&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .shift_and_fill(periods, fill_value)
            .collect(no_optimization=True, string_cache=False)
        )

    def is_duplicated(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all duplicated rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_duplicated())

    def is_unique(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all unique rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_unique())

    def lazy(self) -&gt; &quot;pli.LazyFrame&quot;:
        &quot;&quot;&quot;
        Start a lazy query from this point. This returns a `LazyFrame` object.

        Operations on a `LazyFrame` are not executed until this is requested by either calling:

        * `.fetch()` (run on a small number of rows)
        * `.collect()` (run on all data)
        * `.describe_plan()` (print unoptimized query plan)
        * `.describe_optimized_plan()` (print optimized query plan)
        * `.show_graph()` (show (un)optimized query plan) as graphiz graph)

        Lazy operations are advised because they allow for query optimization and more parallelization.
        &quot;&quot;&quot;
        return pli.wrap_ldf(self._df.lazy())

    def select(
        self,
        exprs: Union[
            str,
            &quot;pli.Expr&quot;,
            Sequence[Union[str, &quot;pli.Expr&quot;]],
            Sequence[bool],
            Sequence[int],
            Sequence[float],
        ],
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Select columns from this DataFrame.

        Parameters
        ----------
        exprs
            Column or columns to select.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select('foo')
        shape: (3, 1)
        ┌─────┐
        │ foo │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        └─────┘

        &quot;&quot;&quot;
        return (
            self.lazy().select(exprs).collect(no_optimization=True, string_cache=False)  # type: ignore
        )

    def with_columns(
        self, exprs: Union[&quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite multiple columns in a DataFrame.

        Parameters
        ----------
        exprs
            List of Expressions that evaluate to columns.
        &quot;&quot;&quot;
        if not isinstance(exprs, list):
            exprs = [exprs]
        return (
            self.lazy()
            .with_columns(exprs)
            .collect(no_optimization=True, string_cache=False)
        )

    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get number of chunks used by the ChunkedArrays of this DataFrame.
        &quot;&quot;&quot;
        return self._df.n_chunks()

    def max(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their maximum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.max()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 3   ┆ 8   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.max())
        if axis == 1:
            return pli.wrap_s(self._df.hmax())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def min(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their minimum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.min()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 6   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.min())
        if axis == 1:
            return pli.wrap_s(self._df.hmin())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def sum(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their sum value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sum()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 6   ┆ 21  ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.sum())
        if axis == 1:
            return pli.wrap_s(self._df.hsum(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def mean(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their mean value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.mean()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.mean())
        if axis == 1:
            return pli.wrap_s(self._df.hmean(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)

    def std(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their standard deviation value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.std()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.std())

    def var(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their variance value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.var()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.var())

    def median(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their median value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.median()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.median())

    def quantile(self, quantile: float) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their quantile value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.quantile(0.5)
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.quantile(quantile))

    def to_dummies(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get one hot encoded dummy variables.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_dummies()
        shape: (3, 9)
        ╭───────┬───────┬───────┬───────┬─────┬───────┬───────┬───────┬───────╮
        │ foo_1 ┆ foo_2 ┆ foo_3 ┆ bar_6 ┆ ... ┆ bar_8 ┆ ham_a ┆ ham_b ┆ ham_c │
        │ ---   ┆ ---   ┆ ---   ┆ ---   ┆     ┆ ---   ┆ ---   ┆ ---   ┆ ---   │
        │ u8    ┆ u8    ┆ u8    ┆ u8    ┆     ┆ u8    ┆ u8    ┆ u8    ┆ u8    │
        ╞═══════╪═══════╪═══════╪═══════╪═════╪═══════╪═══════╪═══════╪═══════╡
        │ 1     ┆ 0     ┆ 0     ┆ 1     ┆ ... ┆ 0     ┆ 1     ┆ 0     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 1     ┆ 0     ┆ 0     ┆ ... ┆ 0     ┆ 0     ┆ 1     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 0     ┆ 1     ┆ 0     ┆ ... ┆ 1     ┆ 0     ┆ 0     ┆ 1     │
        ╰───────┴───────┴───────┴───────┴─────┴───────┴───────┴───────┴───────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.to_dummies())

    def drop_duplicates(
        self,
        maintain_order: bool = True,
        subset: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Drop duplicate rows from this DataFrame.
        Note that this fails if there is a column of type `List` in the DataFrame.
        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_df(self._df.drop_duplicates(maintain_order, subset))

    def rechunk(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rechunk the data in this DataFrame to a contiguous allocation.

        This will make sure all subsequent operations have optimal and predictable performance.
        &quot;&quot;&quot;
        return wrap_df(self._df.rechunk())

    def null_count(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Create a new DataFrame that shows the null counts per column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, None, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, None],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.null_count()
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ u32 ┆ u32 ┆ u32 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 1   ┆ 0   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.null_count())

    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sample from this DataFrame by setting either `n` or `frac`.

        Parameters
        ----------
        n
            Number of samples &lt; self.len() .
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            Sample with replacement.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sample(n=2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if n is not None:
            return wrap_df(self._df.sample_n(n, with_replacement))
        return wrap_df(self._df.sample_frac(frac, with_replacement))

    def fold(
        self, operation: Callable[[&quot;pli.Series&quot;, &quot;pli.Series&quot;], &quot;pli.Series&quot;]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a horizontal reduction on a DataFrame. This can be used to effectively
        determine aggregations on a row level, and can be applied to any DataType that
        can be supercasted (casted to a similar parent type).

        An example of the supercast rules when applying an arithmetic operation on two DataTypes are for instance:

        Int8 + Utf8 = Utf8
        Float32 + Int64 = Float32
        Float32 + Float64 = Float64

        Examples
        --------
        &gt;&gt;&gt; # A horizontal sum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: 'a' [f64]
        [
            4
            5
            9
        ]

        &gt;&gt;&gt; # A horizontal minimum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1.zip_with(s1 &lt; s2, s2))
        Series: 'a' [f64]
        [
            1
            1
            3
        ]

        &gt;&gt;&gt; # A horizontal string concattenation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, 2],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: '' [f64]
        [
            &quot;foo11&quot;
            &quot;bar22
            &quot;233&quot;
        ]

        Parameters
        ----------
        operation
            function that takes two `Series` and returns a `Series`.

        &quot;&quot;&quot;
        if self.width == 1:
            return self.to_series(0)
        df = self
        acc = operation(df.to_series(0), df.to_series(1))

        for i in range(2, df.width):
            acc = operation(acc, df.to_series(i))
        return acc

    def row(self, index: int) -&gt; Tuple[Any]:
        &quot;&quot;&quot;
        Get a row as tuple.

        Parameters
        ----------
        index
            Row index.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.row(2)
        (3, 8, 'c')

        &quot;&quot;&quot;
        return self._df.row_tuple(index)

    def rows(self) -&gt; tp.List[Tuple]:
        &quot;&quot;&quot;
        Convert columnar data to rows as python tuples.
        &quot;&quot;&quot;
        return self._df.row_tuples()

    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._df.shrink_to_fit()
            return None
        else:
            df = self.clone()
            df._df.shrink_to_fit()
            return df

    def hash_rows(
        self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash and combine the rows in this DataFrame.

        Hash value is UInt64

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.hash(k0=42)
        shape: (3,)
        Series: '' [u64]
        [
                1208206736888326229
                8040480609798856146
                18282897888575762835
        ]
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.hash_rows(k0, k1, k2, k3))

    def interpolate(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return self.select(pli.col(&quot;*&quot;).interpolate())  # type: ignore

    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if the dataframe is empty
        &quot;&quot;&quot;
        return self.height == 0
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-python">DataFrame(data: OptionalUnion[Dict[str, SequenceAny], SequenceAny, np.ndarray, pa.Table, pd.DataFrame, pli.Series], 
    columns: OptionalSequencestr, 
    orient: Optionalstr,)
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(
        self,
        data: Optional[
            Union[
                Dict[str, Sequence[Any]],
                Sequence[Any],
                np.ndarray,
                &quot;pa.Table&quot;,
                &quot;pd.DataFrame&quot;,
                &quot;pli.Series&quot;,
            ]
        ] = None,
        columns: Optional[Sequence[str]] = None,
        orient: Optional[str] = None,
    ):
        if data is None:
            self._df = dict_to_pydf({}, columns=columns)

        elif isinstance(data, dict):
            self._df = dict_to_pydf(data, columns=columns)

        elif isinstance(data, np.ndarray):
            self._df = numpy_to_pydf(data, columns=columns, orient=orient)

        elif _PYARROW_AVAILABLE and isinstance(data, pa.Table):
            self._df = arrow_to_pydf(data, columns=columns)

        elif isinstance(data, Sequence) and not isinstance(data, str):
            self._df = sequence_to_pydf(data, columns=columns, orient=orient)

        elif isinstance(data, pli.Series):
            self._df = series_to_pydf(data, columns=columns)

        elif _PANDAS_AVAILABLE and isinstance(data, pd.DataFrame):
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required for converting a pandas DataFrame to a polars DataFrame.&quot;
                )
            self._df = pandas_to_pydf(data, columns=columns)

        else:
            raise ValueError(&quot;DataFrame constructor not called properly.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_csv"><a class="header" href="#polarsinternalsframedataframeread_csv"><code>polars.internals.frame.DataFrame.read_csv</code></a></h3>
<pre><code class="language-python">read_csv(file: Union[str, BinaryIO, bytes], 
    infer_schema_length: Optionalint, 
    batch_size: int, 
    has_headers: bool, 
    ignore_errors: bool, 
    stop_after_n_rows: Optionalint, 
    skip_rows: int, 
    projection: Optionaltp.List[int], 
    sep: str, 
    columns: Optionaltp.List[str], 
    rechunk: bool, 
    encoding: str, 
    n_threads: Optionalint, 
    dtype: Union[Dict[str, TypeDataType], tp.List[TypeDataType], None], 
    low_memory: bool, 
    comment_char: Optionalstr, 
    quote_char: Optionalstr, 
    null_values: OptionalUnion[str, tp.List[str], Dict[str, str]], 
    parse_dates: bool,) -&gt; DataFrame:
</code></pre>
<p>Read a CSV file into a Dataframe.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>file</code>]: Path to a file or a file like object. Any valid filepath can be used. Example: <code>file.csv</code>.</p>
</li>
<li>
<p>[<code>infer_schema_length</code>]: Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
If set to <code>None</code>, a full table scan will be done (slow).</p>
</li>
<li>
<p>[<code>batch_size</code>]: Number of lines to read into the buffer at once. Modify this to change performance.</p>
</li>
<li>
<p>[<code>has_headers</code>]: Indicate if first row of dataset is header or not. If set to False first row will be set to <code>column_x</code>,
<code>x</code> being an enumeration over every column in the dataset.</p>
</li>
<li>
<p>[<code>ignore_errors</code>]: Try to keep reading lines if some lines yield errors.</p>
</li>
<li>
<p>[<code>stop_after_n_rows</code>]: After n rows are read from the CSV, it stops reading.
During multi-threaded parsing, an upper bound of <code>n</code> rows
cannot be guaranteed.</p>
</li>
<li>
<p>[<code>skip_rows</code>]: Start reading after <code>skip_rows</code>.</p>
</li>
<li>
<p>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</p>
</li>
<li>
<p>[<code>sep</code>]: Character to use as delimiter in the file.</p>
</li>
<li>
<p>[<code>columns</code>]: Columns to select.</p>
</li>
<li>
<p>[<code>rechunk</code>]: Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.</p>
</li>
<li>
<p>[<code>encoding</code>]: Allowed encodings: <code>utf8</code>, <code>utf8-lossy</code>. Lossy means that invalid utf8 values are replaced with <code>�</code> character.</p>
</li>
<li>
<p>[<code>n_threads</code>]: Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.</p>
</li>
<li>
<p>[<code>dtype</code>]: Overwrite the dtypes during inference.</p>
</li>
<li>
<p>[<code>low_memory</code>]: Reduce memory usage in expense of performance.</p>
</li>
<li>
<p>[<code>comment_char</code>]: character that indicates the start of a comment line, for instance '#'.</p>
</li>
<li>
<p>[<code>quote_char</code>]: single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
of quotes off.</p>
</li>
<li>
<p>[<code>null_values</code>]: Values to interpret as null values. You can provide a:</p>
<ul>
<li>str -&gt; all values encountered equal to this string will be null</li>
<li>tp.List[str] -&gt; A null value per column.</li>
<li>Dict[str, str] -&gt; A dictionary that maps column name to a null value string.</li>
</ul>
</li>
<li>
<p>[<code>parse_dates</code>]: Whether to attempt to parse dates or not</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.read_csv('file.csv', sep=';', stop_after_n_rows=25)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_csv(
        file: Union[str, BinaryIO, bytes],
        infer_schema_length: Optional[int] = 100,
        batch_size: int = 64,
        has_headers: bool = True,
        ignore_errors: bool = False,
        stop_after_n_rows: Optional[int] = None,
        skip_rows: int = 0,
        projection: Optional[tp.List[int]] = None,
        sep: str = &quot;,&quot;,
        columns: Optional[tp.List[str]] = None,
        rechunk: bool = True,
        encoding: str = &quot;utf8&quot;,
        n_threads: Optional[int] = None,
        dtype: Union[Dict[str, Type[DataType]], tp.List[Type[DataType]], None] = None,
        low_memory: bool = False,
        comment_char: Optional[str] = None,
        quote_char: Optional[str] = r'&quot;',
        null_values: Optional[Union[str, tp.List[str], Dict[str, str]]] = None,
        parse_dates: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read a CSV file into a Dataframe.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used. Example: `file.csv`.
        infer_schema_length
            Maximum number of lines to read to infer schema. If set to 0, all columns will be read as pl.Utf8.
            If set to `None`, a full table scan will be done (slow).
        batch_size
            Number of lines to read into the buffer at once. Modify this to change performance.
        has_headers
            Indicate if first row of dataset is header or not. If set to False first row will be set to `column_x`,
            `x` being an enumeration over every column in the dataset.
        ignore_errors
            Try to keep reading lines if some lines yield errors.
        stop_after_n_rows
            After n rows are read from the CSV, it stops reading.
            During multi-threaded parsing, an upper bound of `n` rows
            cannot be guaranteed.
        skip_rows
            Start reading after `skip_rows`.
        projection
            Indices of columns to select. Note that column indices start at zero.
        sep
            Character to use as delimiter in the file.
        columns
            Columns to select.
        rechunk
            Make sure that all columns are contiguous in memory by aggregating the chunks into a single array.
        encoding
            Allowed encodings: `utf8`, `utf8-lossy`. Lossy means that invalid utf8 values are replaced with `�` character.
        n_threads
            Number of threads to use in csv parsing. Defaults to the number of physical cpu's of your system.
        dtype
            Overwrite the dtypes during inference.
        low_memory
            Reduce memory usage in expense of performance.
        comment_char
            character that indicates the start of a comment line, for instance '#'.
        quote_char
            single byte character that is used for csv quoting, default = ''. Set to None to turn special handling and escaping
            of quotes off.
        null_values
            Values to interpret as null values. You can provide a:

            - str -&gt; all values encountered equal to this string will be null
            - tp.List[str] -&gt; A null value per column.
            - Dict[str, str] -&gt; A dictionary that maps column name to a null value string.
        parse_dates
            Whether to attempt to parse dates or not

        Returns
        -------
        DataFrame

        Examples
        --------

        &gt;&gt;&gt; df = pl.read_csv('file.csv', sep=';', stop_after_n_rows=25)

        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)

        path: Optional[str]
        if isinstance(file, str):
            path = file
        else:
            path = None
            if isinstance(file, BytesIO):
                file = file.getvalue()
            if isinstance(file, StringIO):
                file = file.getvalue().encode()

        dtype_list: Optional[tp.List[Tuple[str, Type[DataType]]]] = None
        dtype_slice: Optional[tp.List[Type[DataType]]] = None
        if dtype is not None:
            if isinstance(dtype, dict):
                dtype_list = []
                for k, v in dtype.items():
                    dtype_list.append((k, py_type_to_dtype(v)))
            elif isinstance(dtype, list):
                dtype_slice = dtype
            else:
                raise ValueError(&quot;dtype arg should be list or dict&quot;)

        processed_null_values = _process_null_values(null_values)

        self._df = PyDataFrame.read_csv(
            file,
            infer_schema_length,
            batch_size,
            has_headers,
            ignore_errors,
            stop_after_n_rows,
            skip_rows,
            projection,
            sep,
            rechunk,
            columns,
            encoding,
            n_threads,
            path,
            dtype_list,
            dtype_slice,
            low_memory,
            comment_char,
            quote_char,
            processed_null_values,
            parse_dates,
        )
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_parquet"><a class="header" href="#polarsinternalsframedataframeread_parquet"><code>polars.internals.frame.DataFrame.read_parquet</code></a></h3>
<pre><code class="language-python">read_parquet(file: Union[str, BinaryIO], 
    columns: Optionaltp.List[str], 
    projection: Optionaltp.List[int], 
    stop_after_n_rows: Optionalint,) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from a parquet file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object. Any valid filepath can be used.</li>
<li>[<code>columns</code>]: Columns to select.</li>
<li>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</li>
<li>[<code>stop_after_n_rows</code>]: Only read specified number of rows of the dataset. After <code>n</code> stops reading.</li>
</ul>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_parquet(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from a parquet file.

        Parameters
        ----------
        file
            Path to a file or a file like object. Any valid filepath can be used.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_parquet(
            file, columns, projection, stop_after_n_rows
        )
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_ipc"><a class="header" href="#polarsinternalsframedataframeread_ipc"><code>polars.internals.frame.DataFrame.read_ipc</code></a></h3>
<pre><code class="language-python">read_ipc(file: Union[str, BinaryIO], 
    columns: Optionaltp.List[str], 
    projection: Optionaltp.List[int], 
    stop_after_n_rows: Optionalint,) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object.</li>
<li>[<code>columns</code>]: Columns to select.</li>
<li>[<code>projection</code>]: Indices of columns to select. Note that column indices start at zero.</li>
<li>[<code>stop_after_n_rows</code>]: Only read specified number of rows of the dataset. After <code>n</code> stops reading.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_ipc(
        file: Union[str, BinaryIO],
        columns: Optional[tp.List[str]] = None,
        projection: Optional[tp.List[int]] = None,
        stop_after_n_rows: Optional[int] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from Arrow IPC stream format. This is also called the feather format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        columns
            Columns to select.
        projection
            Indices of columns to select. Note that column indices start at zero.
        stop_after_n_rows
            Only read specified number of rows of the dataset. After `n` stops reading.

        Returns
        -------
        DataFrame
        &quot;&quot;&quot;
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_ipc(file, columns, projection, stop_after_n_rows)
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeread_json"><a class="header" href="#polarsinternalsframedataframeread_json"><code>polars.internals.frame.DataFrame.read_json</code></a></h3>
<pre><code class="language-python">read_json(file: Union[str, BytesIO]) -&gt; DataFrame:
</code></pre>
<p>Read into a DataFrame from JSON format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Path to a file or a file like object.</li>
</ul>
<p><strong>Decoration</strong> via <code>@staticmethod</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def read_json(file: Union[str, BytesIO]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Read into a DataFrame from JSON format.

        Parameters
        ----------
        file
            Path to a file or a file like object.
        &quot;&quot;&quot;
        if not isinstance(file, str):
            file = file.read().decode(&quot;utf8&quot;)
        self = DataFrame.__new__(DataFrame)
        self._df = PyDataFrame.read_json(file)
        return self
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_arrow"><a class="header" href="#polarsinternalsframedataframeto_arrow"><code>polars.internals.frame.DataFrame.to_arrow</code></a></h3>
<pre><code class="language-python">to_arrow() -&gt; pa.Table:
</code></pre>
<p>Collect the underlying arrow arrays in an Arrow Table.
This operation is mostly zero copy.</p>
<p>Data types that do copy:
- CategoricalType</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_arrow(self) -&gt; &quot;pa.Table&quot;:
        &quot;&quot;&quot;
        Collect the underlying arrow arrays in an Arrow Table.
        This operation is mostly zero copy.

        Data types that do copy:
            - CategoricalType
        &quot;&quot;&quot;
        if not _PYARROW_AVAILABLE:
            raise ImportError(
                &quot;'pyarrow' is required for converting a polars DataFrame to an Arrow Table.&quot;
            )
        record_batches = self._df.to_arrow()
        return pa.Table.from_batches(record_batches)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_dict"><a class="header" href="#polarsinternalsframedataframeto_dict"><code>polars.internals.frame.DataFrame.to_dict</code></a></h3>
<pre><code class="language-python">to_dict(as_series: bool,) -&gt; Union[Dict[str, pli.Series], Dict[str, tp.List[Any]]]:
</code></pre>
<p>Convert DataFrame to a dictionary mapping column name to values.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>as_series</code>]: True -&gt; Values are series
False -&gt; Values are List[Any]</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;A&quot;: [1, 2, 3, 4, 5],
&quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
&quot;B&quot;: [5, 4, 3, 2, 1],
&quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
&quot;optional&quot;: [28, 300, None, 2, -30],
})
shape: (5, 5)
┌─────┬──────────┬─────┬──────────┬──────────┐
│ A   ┆ fruits   ┆ B   ┆ cars     ┆ optional │
│ --- ┆ ---      ┆ --- ┆ ---      ┆ ---      │
│ i64 ┆ str      ┆ i64 ┆ str      ┆ i64      │
╞═════╪══════════╪═════╪══════════╪══════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 28       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 300      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ null     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ -30      │
└─────┴──────────┴─────┴──────────┴──────────┘
df.to_dict(as_series=False)
{'A': [1, 2, 3, 4, 5],
'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'],
'B': [5, 4, 3, 2, 1],
'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'],
'optional': [28, 300, None, 2, -30]}
df.to_dict(as_series=True)
{'A': shape: (5,)
Series: 'A' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li></li>
<li>5
],
'fruits': shape: (5,)
...
Series: 'optional' [i64]
[</li>
<li></li>
<li>-30
]}</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dict(
        self, as_series: bool = True
    ) -&gt; Union[Dict[str, &quot;pli.Series&quot;], Dict[str, tp.List[Any]]]:
        &quot;&quot;&quot;
        Convert DataFrame to a dictionary mapping column name to values.

        Parameters
        ----------
        as_series
            True -&gt; Values are series
            False -&gt; Values are List[Any]

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;      &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;      &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;      &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;      &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt;      &quot;optional&quot;: [28, 300, None, 2, -30],
        &gt;&gt;&gt; })
        shape: (5, 5)
        ┌─────┬──────────┬─────┬──────────┬──────────┐
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ optional │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64      │
        ╞═════╪══════════╪═════╪══════════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 28       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 300      │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ null     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ -30      │
        └─────┴──────────┴─────┴──────────┴──────────┘
        &gt;&gt;&gt; df.to_dict(as_series=False)
        {'A': [1, 2, 3, 4, 5],
        'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'],
        'B': [5, 4, 3, 2, 1],
        'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'],
        'optional': [28, 300, None, 2, -30]}
        &gt;&gt;&gt; df.to_dict(as_series=True)
        {'A': shape: (5,)
         Series: 'A' [i64]
         [
            1
            2
            3
            4
            5
         ],
         'fruits': shape: (5,)
         ...
         Series: 'optional' [i64]
         [
            28
            300
            null
            2
            -30
         ]}

        &quot;&quot;&quot;
        if as_series:
            return {s.name: s for s in self}
        else:
            return {s.name: s.to_list() for s in self}
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_json"><a class="header" href="#polarsinternalsframedataframeto_json"><code>polars.internals.frame.DataFrame.to_json</code></a></h3>
<pre><code class="language-python">to_json(file: OptionalUnion[BytesIO, str, Path], 
    pretty: bool, 
    to_string: bool,) -&gt; Optionalstr:
</code></pre>
<p>Serialize to JSON representation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: Write to this file instead of returning an string.</li>
<li>[<code>pretty</code>]: Pretty serialize json.</li>
<li>[<code>to_string</code>]: Ignore file argument and return a string.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_json(
        self,
        file: Optional[Union[BytesIO, str, Path]] = None,
        pretty: bool = False,
        to_string: bool = False,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Serialize to JSON representation.

        Parameters
        ----------
        file
            Write to this file instead of returning an string.
        pretty
            Pretty serialize json.
        to_string
            Ignore file argument and return a string.
        &quot;&quot;&quot;
        if to_string or file is None:
            file = BytesIO()
            self._df.to_json(file, pretty)
            file.seek(0)
            return file.read().decode(&quot;utf8&quot;)
        else:
            self._df.to_json(file, pretty)
            return None
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_pandas"><a class="header" href="#polarsinternalsframedataframeto_pandas"><code>polars.internals.frame.DataFrame.to_pandas</code></a></h3>
<pre><code class="language-python">to_pandas(*args, **kwargs) -&gt; pd.DataFrame:
</code></pre>
<p>Cast to a Pandas DataFrame. This requires that Pandas is installed.
This operation clones data.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><a href="Arguments."><code>args</code></a>: Arguments will be sent to pyarrow.Table.to_pandas.</li>
<li>[<code>date_as_object</code>]: Cast dates to objects. If False, convert to datetime64[ns] dtype.</li>
<li>[<code>kwargs</code>]: Arguments will be sent to pyarrow.Table.to_pandas.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>import pandas
df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
pandas_df = df.to_pandas()
type(pandas_df)
pandas.core.frame.DataFrame</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_pandas(
        self, *args: Any, date_as_object: bool = False, **kwargs: Any
    ) -&gt; &quot;pd.DataFrame&quot;:  # noqa: F821
        &quot;&quot;&quot;
        Cast to a Pandas DataFrame. This requires that Pandas is installed.
        This operation clones data.

        Parameters
        ----------
        args
            Arguments will be sent to pyarrow.Table.to_pandas.
        date_as_object
            Cast dates to objects. If False, convert to datetime64[ns] dtype.
        kwargs
            Arguments will be sent to pyarrow.Table.to_pandas.

        Examples
        --------

        &gt;&gt;&gt; import pandas
        &gt;&gt;&gt; df = pl.DataFrame({
            &quot;foo&quot;: [1, 2, 3],
            &quot;bar&quot;: [6, 7, 8],
            &quot;ham&quot;: ['a', 'b', 'c']
            })
        &gt;&gt;&gt; pandas_df = df.to_pandas()
        &gt;&gt;&gt; type(pandas_df)
        pandas.core.frame.DataFrame
        &quot;&quot;&quot;
        return self.to_arrow().to_pandas(*args, date_as_object=date_as_object, **kwargs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_csv"><a class="header" href="#polarsinternalsframedataframeto_csv"><code>polars.internals.frame.DataFrame.to_csv</code></a></h3>
<pre><code class="language-python">to_csv(file: OptionalUnion[TextIO, BytesIO, str, Path], 
    has_headers: bool, 
    sep: str,) -&gt; Optionalstr:
</code></pre>
<p>Write Dataframe to comma-separated values file (csv).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: File path to which the file should be written.</li>
<li>[<code>has_headers</code>]: Whether or not to include header in the CSV output.</li>
<li>[<code>sep</code>]: Separate CSV fields with this symbol.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3, 4, 5],
&quot;bar&quot;: [6, 7, 8, 9, 10],
&quot;ham&quot;: ['a', 'b', 'c', 'd','e']
})
df.to_csv('new_file.csv', sep=',')</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_csv(
        self,
        file: Optional[Union[TextIO, BytesIO, str, Path]] = None,
        has_headers: bool = True,
        sep: str = &quot;,&quot;,
    ) -&gt; Optional[str]:
        &quot;&quot;&quot;
        Write Dataframe to comma-separated values file (csv).

        Parameters
        ---
        file
            File path to which the file should be written.
        has_headers
            Whether or not to include header in the CSV output.
        sep
            Separate CSV fields with this symbol.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_csv('new_file.csv', sep=',')

        &quot;&quot;&quot;
        if file is None:
            buffer = BytesIO()
            self._df.to_csv(buffer, has_headers, ord(sep))
            return str(buffer.getvalue(), encoding=&quot;utf-8&quot;)

        if isinstance(file, Path):
            file = str(file)

        self._df.to_csv(file, has_headers, ord(sep))
        return None
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_ipc"><a class="header" href="#polarsinternalsframedataframeto_ipc"><code>polars.internals.frame.DataFrame.to_ipc</code></a></h3>
<pre><code class="language-python">to_ipc(file: Union[BinaryIO, BytesIO, str, Path], 
    compression: str,) -&gt; None:
</code></pre>
<p>Write to Arrow IPC binary stream, or a feather file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: File path to which the file should be written.</li>
<li>[<code>compression</code>]: Compression method. Choose one of:
- &quot;uncompressed&quot;
- &quot;lz4&quot;
- &quot;zstd&quot;</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_ipc(
        self,
        file: Union[BinaryIO, BytesIO, str, Path],
        compression: str = &quot;uncompressed&quot;,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write to Arrow IPC binary stream, or a feather file.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        &quot;&quot;&quot;
        if isinstance(file, Path):
            file = str(file)

        self._df.to_ipc(file, compression)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_dicts"><a class="header" href="#polarsinternalsframedataframeto_dicts"><code>polars.internals.frame.DataFrame.to_dicts</code></a></h3>
<pre><code class="language-python">to_dicts() -&gt; tp.List[Dict[str, Any]]:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dicts(self) -&gt; tp.List[Dict[str, Any]]:
        pydf = self._df
        names = self.columns

        return [
            {k: v for k, v in zip(names, pydf.row_tuple(i))}
            for i in range(0, self.height)
        ]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframetranspose"><a class="header" href="#polarsinternalsframedataframetranspose"><code>polars.internals.frame.DataFrame.transpose</code></a></h3>
<pre><code class="language-python">transpose(include_header: bool, 
    header_name: str, 
    column_names: OptionalUnion[tp.Iteratorstr, tp.Sequencestr],) -&gt; pli.DataFrame:
</code></pre>
<p>Transpose a DataFrame over the diagonal.</p>
<p><strong>Parameters:</strong></p>
<p>include_header:
If set, the column names will be added as first column.
header_name:
If <code>include_header</code> is set, this determines the name of the column that will be inserted
column_names:
Optional generator/iterator that yields column names. Will be used to replace the columns in the DataFrame.</p>
<p><strong>Notes:</strong></p>
<p>This is a very expensive operation. Perhaps you can do it differently.</p>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [1, 2, 3]})
df.transpose(include_header=True)
shape: (2, 4)
┌────────┬──────────┬──────────┬──────────┐
│ column ┆ column_0 ┆ column_1 ┆ column_2 │
│ ---    ┆ ---      ┆ ---      ┆ ---      │
│ str    ┆ i64      ┆ i64      ┆ i64      │
╞════════╪══════════╪══════════╪══════════╡
│ a      ┆ 1        ┆ 2        ┆ 3        │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ b      ┆ 1        ┆ 2        ┆ 3        │
└────────┴──────────┴──────────┴──────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>replace:</strong>
the auto generated column names with a list
&gt;&gt;&gt; df.transpose(include_header=False, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
shape: (2, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ 2   ┆ 3   │
└─────┴─────┴─────┘</p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="include-the-header-as-a-separate-column"><a class="header" href="#include-the-header-as-a-separate-column">include the header as a separate column</a></h1>
<p>df.transpose(include_header=True, header_name=&quot;foo&quot;, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
shape: (2, 4)
┌─────┬─────┬─────┬─────┐
│ foo ┆ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╪═════╡
│ a   ┆ 1   ┆ 2   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ b   ┆ 1   ┆ 2   ┆ 3   │
└─────┴─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="replace-the-auto-generated-column-with-column-names-from-a-generator-function"><a class="header" href="#replace-the-auto-generated-column-with-column-names-from-a-generator-function">replace the auto generated column with column names from a generator function</a></h1>
<p>def name_generator():
base_name = &quot;my_column_&quot;
count = 0
while True:
yield f&quot;{base_name}{count}&quot;
count += 1
df.transpose(include_header=False, column_names=name_generator())
shape: (2, 3)
┌─────────────┬─────────────┬─────────────┐
│ my_column_0 ┆ my_column_1 ┆ my_column_2 │
│ ---         ┆ ---         ┆ ---         │
│ i64         ┆ i64         ┆ i64         │
╞═════════════╪═════════════╪═════════════╡
│ 1           ┆ 2           ┆ 3           │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1           ┆ 2           ┆ 3           │
└─────────────┴─────────────┴─────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def transpose(
        self,
        include_header: bool = False,
        header_name: str = &quot;column&quot;,
        column_names: Optional[Union[tp.Iterator[str], tp.Sequence[str]]] = None,
    ) -&gt; &quot;pli.DataFrame&quot;:
        &quot;&quot;&quot;
        Transpose a DataFrame over the diagonal.

        Parameters
        ----------
        include_header:
            If set, the column names will be added as first column.
        header_name:
            If `include_header` is set, this determines the name of the column that will be inserted
        column_names:
            Optional generator/iterator that yields column names. Will be used to replace the columns in the DataFrame.

        Notes
        -----
        This is a very expensive operation. Perhaps you can do it differently.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [1, 2, 3]})
        &gt;&gt;&gt; df.transpose(include_header=True)
        shape: (2, 4)
        ┌────────┬──────────┬──────────┬──────────┐
        │ column ┆ column_0 ┆ column_1 ┆ column_2 │
        │ ---    ┆ ---      ┆ ---      ┆ ---      │
        │ str    ┆ i64      ┆ i64      ┆ i64      │
        ╞════════╪══════════╪══════════╪══════════╡
        │ a      ┆ 1        ┆ 2        ┆ 3        │
        ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ b      ┆ 1        ┆ 2        ┆ 3        │
        └────────┴──────────┴──────────┴──────────┘

        # replace the auto generated column names with a list
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt; # include the header as a separate column
        &gt;&gt;&gt; df.transpose(include_header=True, header_name=&quot;foo&quot;, column_names=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])
        shape: (2, 4)
        ┌─────┬─────┬─────┬─────┐
        │ foo ┆ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╪═════╡
        │ a   ┆ 1   ┆ 2   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 1   ┆ 2   ┆ 3   │
        └─────┴─────┴─────┴─────┘

        &gt;&gt;&gt; # replace the auto generated column with column names from a generator function
        &gt;&gt;&gt; def name_generator():
        &gt;&gt;&gt;     base_name = &quot;my_column_&quot;
        &gt;&gt;&gt;     count = 0
        &gt;&gt;&gt;     while True:
        &gt;&gt;&gt;         yield f&quot;{base_name}{count}&quot;
        &gt;&gt;&gt;         count += 1
        &gt;&gt;&gt; df.transpose(include_header=False, column_names=name_generator())
        shape: (2, 3)
        ┌─────────────┬─────────────┬─────────────┐
        │ my_column_0 ┆ my_column_1 ┆ my_column_2 │
        │ ---         ┆ ---         ┆ ---         │
        │ i64         ┆ i64         ┆ i64         │
        ╞═════════════╪═════════════╪═════════════╡
        │ 1           ┆ 2           ┆ 3           │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 1           ┆ 2           ┆ 3           │
        └─────────────┴─────────────┴─────────────┘

        &quot;&quot;&quot;
        df = wrap_df(self._df.transpose(include_header, header_name))
        if column_names is not None:
            names = []
            n = df.width
            if include_header:
                names.append(header_name)
                n -= 1

            column_names = iter(column_names)
            for _ in range(n):
                names.append(next(column_names))
            df.columns = names
        return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_parquet"><a class="header" href="#polarsinternalsframedataframeto_parquet"><code>polars.internals.frame.DataFrame.to_parquet</code></a></h3>
<pre><code class="language-python">to_parquet(file: Union[str, Path, BytesIO], 
    compression: Optionalstr, 
    use_pyarrow: bool, 
    **kwargs,) -&gt; None:
</code></pre>
<p>Write the DataFrame disk in parquet format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>file</code>]: File path to which the file should be written.</li>
<li>[<code>compression</code>]: Compression method. Choose one of:
- &quot;uncompressed&quot; (not supported by pyarrow)
- &quot;snappy&quot;
- &quot;gzip&quot;
- &quot;lzo&quot;
- &quot;brotli&quot;
- &quot;lz4&quot;
- &quot;zstd&quot;</li>
<li>[<code>use_pyarrow</code>]: Use C++ parquet implementation vs rust parquet implementation.
At the moment C++ supports more features.</li>
</ul>
<p>**kwargs are passed to pyarrow.parquet.write_table</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_parquet(
        self,
        file: Union[str, Path, BytesIO],
        compression: Optional[str] = &quot;snappy&quot;,
        use_pyarrow: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        &quot;&quot;&quot;
        Write the DataFrame disk in parquet format.

        Parameters
        ----------
        file
            File path to which the file should be written.
        compression
            Compression method. Choose one of:
                - &quot;uncompressed&quot; (not supported by pyarrow)
                - &quot;snappy&quot;
                - &quot;gzip&quot;
                - &quot;lzo&quot;
                - &quot;brotli&quot;
                - &quot;lz4&quot;
                - &quot;zstd&quot;
        use_pyarrow
            Use C++ parquet implementation vs rust parquet implementation.
            At the moment C++ supports more features.

        **kwargs are passed to pyarrow.parquet.write_table
        &quot;&quot;&quot;
        if compression is None:
            compression = &quot;uncompressed&quot;
        if isinstance(file, Path):
            file = str(file)

        if use_pyarrow:
            if not _PYARROW_AVAILABLE:
                raise ImportError(
                    &quot;'pyarrow' is required when using 'to_parquet(..., use_pyarrow=True)'.&quot;
                )

            tbl = self.to_arrow()

            data = {}

            for i, column in enumerate(tbl):
                # extract the name before casting
                if column._name is None:
                    name = f&quot;column_{i}&quot;
                else:
                    name = column._name

                data[name] = column
            tbl = pa.table(data)

            pa.parquet.write_table(
                table=tbl, where=file, compression=compression, **kwargs
            )
        else:
            self._df.to_parquet(file, compression)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_numpy"><a class="header" href="#polarsinternalsframedataframeto_numpy"><code>polars.internals.frame.DataFrame.to_numpy</code></a></h3>
<pre><code class="language-python">to_numpy() -&gt; np.ndarray:
</code></pre>
<p>Convert DataFrame to a 2d numpy array.
This operation clones data.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
numpy_array = df.to_numpy()
type(numpy_array)
numpy.ndarray</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_numpy(self) -&gt; np.ndarray:
        &quot;&quot;&quot;
        Convert DataFrame to a 2d numpy array.
        This operation clones data.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; numpy_array = df.to_numpy()
        &gt;&gt;&gt; type(numpy_array)
        numpy.ndarray

        &quot;&quot;&quot;
        return np.vstack([self.to_series(i).to_numpy() for i in range(self.width)]).T
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefind_idx_by_name"><a class="header" href="#polarsinternalsframedataframefind_idx_by_name"><code>polars.internals.frame.DataFrame.find_idx_by_name</code></a></h3>
<pre><code class="language-python">find_idx_by_name(name: str) -&gt; int:
</code></pre>
<p>Find the index of a column by name.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Name of the column to find.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.find_idx_by_name(&quot;ham&quot;))
2</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def find_idx_by_name(self, name: str) -&gt; int:
        &quot;&quot;&quot;
        Find the index of a column by name.

        Parameters
        ----------
        name
            Name of the column to find.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.find_idx_by_name(&quot;ham&quot;))
        2

        &quot;&quot;&quot;
        return self._df.find_idx_by_name(name)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_series"><a class="header" href="#polarsinternalsframedataframeto_series"><code>polars.internals.frame.DataFrame.to_series</code></a></h3>
<pre><code class="language-python">to_series(index: int) -&gt; pli.Series:
</code></pre>
<p>Select column as Series at index location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Location of selection.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.to_series(1))
shape: (3,)
Series: 'bar' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  8
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_series(self, index: int = 0) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column as Series at index location.

        Parameters
        ----------
        index
            Location of selection.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_series(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(index))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerename"><a class="header" href="#polarsinternalsframedataframerename"><code>polars.internals.frame.DataFrame.rename</code></a></h3>
<pre><code class="language-python">rename(mapping: Dict[str, str]) -&gt; DataFrame:
</code></pre>
<p>Rename column names.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>mapping</code>]: Key value pairs that map from old name to new name.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.rename({&quot;foo&quot;: &quot;apple&quot;})
╭───────┬─────┬─────╮
│ apple ┆ bar ┆ ham │
│ ---   ┆ --- ┆ --- │
│ i64   ┆ i64 ┆ str │
╞═══════╪═════╪═════╡
│ 1     ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2     ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3     ┆ 8   ┆ &quot;c&quot; │
╰───────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rename(self, mapping: Dict[str, str]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rename column names.

        Parameters
        ----------
        mapping
            Key value pairs that map from old name to new name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df.rename({&quot;foo&quot;: &quot;apple&quot;})
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 1     ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2     ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3     ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        df = self.clone()
        for k, v in mapping.items():
            df._df.rename(k, v)
        return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeinsert_at_idx"><a class="header" href="#polarsinternalsframedataframeinsert_at_idx"><code>polars.internals.frame.DataFrame.insert_at_idx</code></a></h3>
<pre><code class="language-python">insert_at_idx(index: int, series: pli.Series) -&gt; None:
</code></pre>
<p>Insert a Series at a certain column index. This operation is in place.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Column to insert the new <code>Series</code> column.</li>
<li>[<code>series</code>]: <code>Series</code> to insert.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def insert_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Insert a Series at a certain column index. This operation is in place.

        Parameters
        ----------
        index
            Column to insert the new `Series` column.
        series
            `Series` to insert.
        &quot;&quot;&quot;
        self._df.insert_at_idx(index, series._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefilter"><a class="header" href="#polarsinternalsframedataframefilter"><code>polars.internals.frame.DataFrame.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: pli.Expr) -&gt; DataFrame:
</code></pre>
<p>Filter the rows in the DataFrame based on a predicate expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Expression that evaluates to a boolean Series.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})</p>
<h1 id="filter-on-one-condition"><a class="header" href="#filter-on-one-condition">Filter on one condition</a></h1>
<p>df.filter(pl.col(&quot;foo&quot;) &lt; 3)
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ b   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="filter-on-multiple-conditions"><a class="header" href="#filter-on-multiple-conditions">Filter on multiple conditions</a></h1>
<p>df.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;))
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ a   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: &quot;pli.Expr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Filter the rows in the DataFrame based on a predicate expression.

        Parameters
        ----------
        predicate
            Expression that evaluates to a boolean Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt; })
        &gt;&gt;&gt; # Filter on one condition
        &gt;&gt;&gt; df.filter(pl.col(&quot;foo&quot;) &lt; 3)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ b   │
        └─────┴─────┴─────┘

        &gt;&gt;&gt;  # Filter on multiple conditions
        &gt;&gt;&gt; df.filter((pl.col(&quot;foo&quot;) &lt; 3) &amp; (pl.col(&quot;ham&quot;) == &quot;a&quot;))
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ a   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .filter(predicate)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshape"><a class="header" href="#polarsinternalsframedataframeshape"><code>polars.internals.frame.DataFrame.shape</code></a></h3>
<pre><code class="language-python">shape() -&gt; Tuple[int, int]:
</code></pre>
<p>Get the shape of the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
df.shape
shape: (5, 1)</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shape(self) -&gt; Tuple[int, int]:
        &quot;&quot;&quot;
        Get the shape of the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.shape
        shape: (5, 1)

        &quot;&quot;&quot;
        return self._df.shape()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeheight"><a class="header" href="#polarsinternalsframedataframeheight"><code>polars.internals.frame.DataFrame.height</code></a></h3>
<pre><code class="language-python">height() -&gt; int:
</code></pre>
<p>Get the height of the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
df.height
5</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def height(self) -&gt; int:
        &quot;&quot;&quot;
        Get the height of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.height
        5

        &quot;&quot;&quot;
        return self._df.height()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewidth"><a class="header" href="#polarsinternalsframedataframewidth"><code>polars.internals.frame.DataFrame.width</code></a></h3>
<pre><code class="language-python">width() -&gt; int:
</code></pre>
<p>Get the width of the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
df.width
1</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def width(self) -&gt; int:
        &quot;&quot;&quot;
        Get the width of the DataFrame.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3, 4, 5]})
        &gt;&gt;&gt; df.width
        1
        &quot;&quot;&quot;
        return self._df.width()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframecolumns"><a class="header" href="#polarsinternalsframedataframecolumns"><code>polars.internals.frame.DataFrame.columns</code></a></h3>
<pre><code class="language-python">columns(columns: Sequencestr) -&gt; None:
</code></pre>
<p>Change the column names of the <code>DataFrame</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: A list with new names for the <code>DataFrame</code>.
The length of the list should be equal to the width of the <code>DataFrame</code>.</li>
</ul>
<p><strong>Decoration</strong> via <code>@columns.setter</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def columns(self, columns: Sequence[str]) -&gt; None:
        &quot;&quot;&quot;
        Change the column names of the `DataFrame`.

        Parameters
        ----------
        columns
            A list with new names for the `DataFrame`.
            The length of the list should be equal to the width of the `DataFrame`.
        &quot;&quot;&quot;
        self._df.set_column_names(columns)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedtypes"><a class="header" href="#polarsinternalsframedataframedtypes"><code>polars.internals.frame.DataFrame.dtypes</code></a></h3>
<pre><code class="language-python">dtypes() -&gt; tp.List[TypeDataType]:
</code></pre>
<p>Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.dtypes
[polars.datatypes.Int64, polars.datatypes.Float64, polars.datatypes.Utf8]
df
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dtypes(self) -&gt; tp.List[Type[DataType]]:
        &quot;&quot;&quot;
        Get dtypes of columns in DataFrame. Dtypes can also be found in column headers when printing the DataFrame.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.dtypes
        [polars.datatypes.Int64, polars.datatypes.Float64, polars.datatypes.Utf8]
        &gt;&gt;&gt; df
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return [DTYPES[idx] for idx in self._df.dtypes()]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedescribe"><a class="header" href="#polarsinternalsframedataframedescribe"><code>polars.internals.frame.DataFrame.describe</code></a></h3>
<pre><code class="language-python">describe() -&gt; DataFrame:
</code></pre>
<p>Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
'a': [1.0, 2.8, 3.0],
'b': [4, 5, 6],
&quot;c&quot;: [True, False, True]
})
df.describe()
shape: (5, 4)
╭──────────┬───────┬─────┬──────╮
│ describe ┆ a     ┆ b   ┆ c    │
│ ---      ┆ ---   ┆ --- ┆ ---  │
│ str      ┆ f64   ┆ f64 ┆ f64  │
╞══════════╪═══════╪═════╪══════╡
│ &quot;mean&quot;   ┆ 2.267 ┆ 5   ┆ null │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;std&quot;    ┆ 1.102 ┆ 1   ┆ null │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;min&quot;    ┆ 1     ┆ 4   ┆ 0.0  │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;max&quot;    ┆ 3     ┆ 6   ┆ 1    │
├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ &quot;median&quot; ┆ 2.8   ┆ 5   ┆ null │
╰──────────┴───────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def describe(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Summary statistics for a DataFrame. Only summarizes numeric datatypes at the moment and returns nulls for non numeric datatypes.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     'a': [1.0, 2.8, 3.0],
        &gt;&gt;&gt;     'b': [4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [True, False, True]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.describe()
        shape: (5, 4)
        ╭──────────┬───────┬─────┬──────╮
        │ describe ┆ a     ┆ b   ┆ c    │
        │ ---      ┆ ---   ┆ --- ┆ ---  │
        │ str      ┆ f64   ┆ f64 ┆ f64  │
        ╞══════════╪═══════╪═════╪══════╡
        │ &quot;mean&quot;   ┆ 2.267 ┆ 5   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;std&quot;    ┆ 1.102 ┆ 1   ┆ null │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;min&quot;    ┆ 1     ┆ 4   ┆ 0.0  │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;max&quot;    ┆ 3     ┆ 6   ┆ 1    │
        ├╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ &quot;median&quot; ┆ 2.8   ┆ 5   ┆ null │
        ╰──────────┴───────┴─────┴──────╯

        &quot;&quot;&quot;

        def describe_cast(self: &quot;DataFrame&quot;) -&gt; &quot;DataFrame&quot;:
            columns = []
            for s in self:
                if s.is_numeric() or s.is_boolean():
                    columns.append(s.cast(float))
                else:
                    columns.append(s)
            return DataFrame(columns)

        summary = pli.concat(
            [
                describe_cast(self.mean()),  # type: ignore
                describe_cast(self.std()),
                describe_cast(self.min()),  # type: ignore
                describe_cast(self.max()),  # type: ignore
                describe_cast(self.median()),
            ]
        )
        summary.insert_at_idx(  # type: ignore
            0, pli.Series(&quot;describe&quot;, [&quot;mean&quot;, &quot;std&quot;, &quot;min&quot;, &quot;max&quot;, &quot;median&quot;])
        )
        return summary  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedescribedescribe_cast"><a class="header" href="#polarsinternalsframedataframedescribedescribe_cast"><code>polars.internals.frame.DataFrame.describe.describe_cast</code></a></h3>
<pre><code class="language-python">describe_cast(: DataFrame) -&gt; DataFrame:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def describe_cast(self: &quot;DataFrame&quot;) -&gt; &quot;DataFrame&quot;:
            columns = []
            for s in self:
                if s.is_numeric() or s.is_boolean():
                    columns.append(s.cast(float))
                else:
                    columns.append(s)
            return DataFrame(columns)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframereplace_at_idx"><a class="header" href="#polarsinternalsframedataframereplace_at_idx"><code>polars.internals.frame.DataFrame.replace_at_idx</code></a></h3>
<pre><code class="language-python">replace_at_idx(index: int, series: pli.Series) -&gt; None:
</code></pre>
<p>Replace a column at an index location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Column index.</li>
<li>[<code>series</code>]: Series that will replace the column.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
x = pl.Series(&quot;apple&quot;, [10, 20, 30])
df.replace_at_idx(0, x)
shape: (3, 3)
╭───────┬─────┬─────╮
│ apple ┆ bar ┆ ham │
│ ---   ┆ --- ┆ --- │
│ i64   ┆ i64 ┆ str │
╞═══════╪═════╪═════╡
│ 10    ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 20    ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 30    ┆ 8   ┆ &quot;c&quot; │
╰───────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace_at_idx(self, index: int, series: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column at an index location.

        Parameters
        ----------
        index
            Column index.
        series
            Series that will replace the column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.replace_at_idx(0, x)
        shape: (3, 3)
        ╭───────┬─────┬─────╮
        │ apple ┆ bar ┆ ham │
        │ ---   ┆ --- ┆ --- │
        │ i64   ┆ i64 ┆ str │
        ╞═══════╪═════╪═════╡
        │ 10    ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 20    ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 30    ┆ 8   ┆ &quot;c&quot; │
        ╰───────┴─────┴─────╯

        &quot;&quot;&quot;
        self._df.replace_at_idx(index, series._s)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframesort"><a class="header" href="#polarsinternalsframedataframesort"><code>polars.internals.frame.DataFrame.sort</code></a></h3>
<pre><code class="language-python">sort(by: Union[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    reverse: Union[bool, tp.List[bool]], 
    in_place: bool,) -&gt; DataFrame:
</code></pre>
<p>Sort the DataFrame by column.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: By which column to sort. Only accepts string.</li>
<li>[<code>reverse</code>]: Reverse/descending sort.</li>
<li>[<code>in_place</code>]: Perform operation in-place.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.sort('foo', reverse=True)
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ f64 ┆ str │
╞═════╪═════╪═════╡
│ 3   ┆ 8   ┆ &quot;c&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ 6   ┆ &quot;a&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Sort by multiple columns.</strong>
For multiple columns we can also use expression syntax.</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.sort([pl.col(&quot;foo&quot;), pl.col(&quot;bar&quot;) ** 2], reverse=[True, False])</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(
        self,
        by: Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]],
        reverse: Union[bool, tp.List[bool]] = False,
        in_place: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sort the DataFrame by column.

        Parameters
        ----------
        by
            By which column to sort. Only accepts string.
        reverse
            Reverse/descending sort.
        in_place
            Perform operation in-place.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sort('foo', reverse=True)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ f64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ╰─────┴─────┴─────╯

        **Sort by multiple columns.**
        For multiple columns we can also use expression syntax.

        &gt;&gt;&gt; df.sort([pl.col(&quot;foo&quot;), pl.col(&quot;bar&quot;) ** 2], reverse=[True, False])

        &quot;&quot;&quot;
        if type(by) is list or isinstance(by, pli.Expr):
            df = (
                self.lazy()
                .sort(by, reverse)
                .collect(no_optimization=True, string_cache=False)
            )
            if in_place:
                self._df = df._df
                return self
            return df
        if in_place:
            self._df.sort_in_place(by, reverse)
            return self
        else:
            return wrap_df(self._df.sort(by, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeframe_equal"><a class="header" href="#polarsinternalsframedataframeframe_equal"><code>polars.internals.frame.DataFrame.frame_equal</code></a></h3>
<pre><code class="language-python">frame_equal(other: DataFrame, 
    null_equal: bool,) -&gt; bool:
</code></pre>
<p>Check if DataFrame is equal to other.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: DataFrame to compare with.</li>
<li>[<code>null_equal</code>]: Consider null values as equal.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df1 = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df2 = pl.DataFrame({
&quot;foo&quot;: [3, 2, 1],
&quot;bar&quot;: [8.0, 7.0, 6.0],
&quot;ham&quot;: ['c', 'b', 'a']
})
df1.frame_equal(df1)
True
df1.frame_equal(df2)
False</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def frame_equal(self, other: &quot;DataFrame&quot;, null_equal: bool = True) -&gt; bool:
        &quot;&quot;&quot;
        Check if DataFrame is equal to other.

        Parameters
        ----------
        other
            DataFrame to compare with.
        null_equal
            Consider null values as equal.

        Examples
        --------
        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 2, 1],
        &gt;&gt;&gt;     &quot;bar&quot;: [8.0, 7.0, 6.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'b', 'a']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.frame_equal(df1)
        True
        &gt;&gt;&gt; df1.frame_equal(df2)
        False

        &quot;&quot;&quot;
        return self._df.frame_equal(other._df, null_equal)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframereplace"><a class="header" href="#polarsinternalsframedataframereplace"><code>polars.internals.frame.DataFrame.replace</code></a></h3>
<pre><code class="language-python">replace(column: str, new_col: pli.Series) -&gt; None:
</code></pre>
<p>Replace a column by a new Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Column to replace.</li>
<li>[<code>new_col</code>]: New column to insert.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def replace(self, column: str, new_col: &quot;pli.Series&quot;) -&gt; None:
        &quot;&quot;&quot;
        Replace a column by a new Series.

        Parameters
        ----------
        column
            Column to replace.
        new_col
            New column to insert.
        &quot;&quot;&quot;
        self._df.replace(column, new_col.inner())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeslice"><a class="header" href="#polarsinternalsframedataframeslice"><code>polars.internals.frame.DataFrame.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; DataFrame:
</code></pre>
<p>Slice this DataFrame over the rows direction.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Offset index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.slice(1, 2)
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Slice this DataFrame over the rows direction.

        Parameters
        ----------
        offset
            Offset index.
        length
            Length of the slice.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.slice(1, 2)
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        if length &lt; 0:
            length = self.height - offset + length
        return wrap_df(self._df.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframelimit"><a class="header" href="#polarsinternalsframedataframelimit"><code>polars.internals.frame.DataFrame.limit</code></a></h3>
<pre><code class="language-python">limit(length: int) -&gt; DataFrame:
</code></pre>
<p>Get first N rows as DataFrame.</p>
<p>See Also <code>DataFrame.head</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Amount of rows to take.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.limit(2)
shape: (2, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def limit(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        See Also `DataFrame.head`

        Parameters
        ----------
        length
            Amount of rows to take.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.limit(2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return self.head(length)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframehead"><a class="header" href="#polarsinternalsframedataframehead"><code>polars.internals.frame.DataFrame.head</code></a></h3>
<pre><code class="language-python">head(length: int) -&gt; DataFrame:
</code></pre>
<p>Get first N rows as DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the head.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3, 4, 5],
&quot;bar&quot;: [6, 7, 8, 9, 10],
&quot;ham&quot;: ['a', 'b', 'c', 'd','e']
})
df.head(3)
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get first N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the head.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.head(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.head(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframetail"><a class="header" href="#polarsinternalsframedataframetail"><code>polars.internals.frame.DataFrame.tail</code></a></h3>
<pre><code class="language-python">tail(length: int) -&gt; DataFrame:
</code></pre>
<p>Get last N rows as DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>length</code>]: Length of the tail.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3, 4, 5],
&quot;bar&quot;: [6, 7, 8, 9, 10],
&quot;ham&quot;: ['a', 'b', 'c', 'd','e']
})
df.tail(3)
shape: (3, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 3   ┆ 8   ┆ &quot;c&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 9   ┆ &quot;d&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 5   ┆ 10  ┆ &quot;e&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, length: int = 5) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get last N rows as DataFrame.

        Parameters
        ----------
        length
            Length of the tail.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8, 9, 10],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c', 'd','e']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.tail(3)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 5   ┆ 10  ┆ &quot;e&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.tail(length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop_nulls"><a class="header" href="#polarsinternalsframedataframedrop_nulls"><code>polars.internals.frame.DataFrame.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls(subset: Optionaltp.List[str]) -&gt; DataFrame:
</code></pre>
<p>Return a new DataFrame where the null values are dropped.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, None, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.drop_nulls()
shape: (2, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>This method only drops nulls row-wise if any single value of the row is null.</p>
<p>Below are some example snippets that show how you could drop null values based on other
conditions</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;a&quot;: [None, None, None, None],
&quot;b&quot;: [1, 2, None, 1],
&quot;c&quot;: [1, None, None, 1],
}
)
df
shape: (4, 3)
┌──────┬──────┬──────┐
│ a    ┆ b    ┆ c    │
│ ---  ┆ ---  ┆ ---  │
│ f64  ┆ i64  ┆ i64  │
╞══════╪══════╪══════╡
│ null ┆ 1    ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 2    ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 1    ┆ 1    │
└──────┴──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="drop-a-row-only-if-all-values-are-null"><a class="header" href="#drop-a-row-only-if-all-values-are-null">drop a row only if all values are null</a></h1>
<p>df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
shape: (3, 3)
┌──────┬─────┬──────┐
│ a    ┆ b   ┆ c    │
│ ---  ┆ --- ┆ ---  │
│ f64  ┆ i64 ┆ i64  │
╞══════╪═════╪══════╡
│ null ┆ 1   ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 2   ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ 1   ┆ 1    │
└──────┴─────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<h1 id="drop-a-column-if-all-values-are-null"><a class="header" href="#drop-a-column-if-all-values-are-null">drop a column if all values are null</a></h1>
<p>df[:, [not (s.null_count() == df.height) for s in df]]
shape: (4, 2)
┌──────┬──────┐
│ b    ┆ c    │
│ ---  ┆ ---  │
│ i64  ┆ i64  │
╞══════╪══════╡
│ 1    ┆ 1    │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 1    ┆ 1    │
└──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self, subset: Optional[tp.List[str]] = None) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame where the null values are dropped.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, None, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.drop_nulls()
        shape: (2, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        └─────┴─────┴─────┘

        This method only drops nulls row-wise if any single value of the row is null.

        Below are some example snippets that show how you could drop null values based on other
        conditions

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {
        &gt;&gt;&gt;        &quot;a&quot;: [None, None, None, None],
        &gt;&gt;&gt;        &quot;b&quot;: [1, 2, None, 1],
        &gt;&gt;&gt;        &quot;c&quot;: [1, None, None, 1],
        &gt;&gt;&gt;    }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df
        shape: (4, 3)
        ┌──────┬──────┬──────┐
        │ a    ┆ b    ┆ c    │
        │ ---  ┆ ---  ┆ ---  │
        │ f64  ┆ i64  ┆ i64  │
        ╞══════╪══════╪══════╡
        │ null ┆ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1    ┆ 1    │
        └──────┴──────┴──────┘

        &gt;&gt;&gt; # drop a row only if all values are null
        &gt;&gt;&gt; df.filter(~pl.fold(acc=True, f=lambda acc, s: acc &amp; s.is_null(), exprs=pl.all()))
        shape: (3, 3)
        ┌──────┬─────┬──────┐
        │ a    ┆ b   ┆ c    │
        │ ---  ┆ --- ┆ ---  │
        │ f64  ┆ i64 ┆ i64  │
        ╞══════╪═════╪══════╡
        │ null ┆ 1   ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 2   ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ 1   ┆ 1    │
        └──────┴─────┴──────┘

        &gt;&gt;&gt; # drop a column if all values are null
        &gt;&gt;&gt; df[:, [not (s.null_count() == df.height) for s in df]]
        shape: (4, 2)
        ┌──────┬──────┐
        │ b    ┆ c    │
        │ ---  ┆ ---  │
        │ i64  ┆ i64  │
        ╞══════╪══════╡
        │ 1    ┆ 1    │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 1    │
        └──────┴──────┘

        &quot;&quot;&quot;
        if subset is not None and isinstance(subset, str):
            subset = [subset]
        return wrap_df(self._df.drop_nulls(subset))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframepipe"><a class="header" href="#polarsinternalsframedataframepipe"><code>polars.internals.frame.DataFrame.pipe</code></a></h3>
<pre><code class="language-python">pipe(func: Callable[, Any], *args, **kwargs) -&gt; Any:
</code></pre>
<p>Apply a function on Self.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li></li>
<li></li>
<li>[<code>kwargs</code>]: Keyword arguments.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pipe(self, func: Callable[..., Any], *args: Any, **kwargs: Any) -&gt; Any:
        &quot;&quot;&quot;
        Apply a function on Self.

        Parameters
        ----------
        func
            Callable.
        args
            Arguments.
        kwargs
            Keyword arguments.
        &quot;&quot;&quot;
        return func(self, *args, **kwargs)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_row_count"><a class="header" href="#polarsinternalsframedataframewith_row_count"><code>polars.internals.frame.DataFrame.with_row_count</code></a></h3>
<pre><code class="language-python">with_row_count(name: str) -&gt; DataFrame:
</code></pre>
<p>Add a column at index 0 that counts the rows.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Name of the column to add.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_row_count(self, name: str = &quot;row_nr&quot;) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add a column at index 0 that counts the rows.

        Parameters
        ----------
        name
            Name of the column to add.
        &quot;&quot;&quot;
        return wrap_df(self._df.with_row_count(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframegroupby"><a class="header" href="#polarsinternalsframedataframegroupby"><code>polars.internals.frame.DataFrame.groupby</code></a></h3>
<pre><code class="language-python">groupby(by: Union[str, pli.Expr, Sequencestr, Sequencepli.Expr], 
    maintain_order: bool,) -&gt; GroupBy:
</code></pre>
<p>Start a groupby operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Column(s) to group by.</li>
<li>[<code>maintain_order</code>]: Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
Note that this only works in expression aggregations.</li>
</ul>
<p><strong>Examples:</strong></p>
<p>Below we group by column <code>&quot;a&quot;</code>, and we sum column <code>&quot;b&quot;</code>.</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;],
&quot;b&quot;: [1, 2, 3, 4, 5, 6],
&quot;c&quot;: [6, 5, 4, 3, 2, 1],
})
assert (
df.groupby(&quot;a&quot;)[&quot;b&quot;]
.sum()
.sort(by_column=&quot;a&quot;)
.frame_equal(DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;: [4, 11, 6]})))</p>
</blockquote>
</blockquote>
</blockquote>
<p>We can also loop over the grouped <code>DataFrame</code></p>
<blockquote>
<blockquote>
<blockquote>
<p>for sub_df in df.groupby(&quot;a&quot;):
print(sub_df)
shape: (3, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ &quot;b&quot; ┆ 2   ┆ 5   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot; ┆ 4   ┆ 3   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot; ┆ 5   ┆ 2   │
╰─────┴─────┴─────╯
shape: (1, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ &quot;c&quot; ┆ 6   ┆ 1   │
╰─────┴─────┴─────╯
shape: (2, 3)
╭─────┬─────┬─────╮
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 │
╞═════╪═════╪═════╡
│ &quot;a&quot; ┆ 1   ┆ 6   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot; ┆ 3   ┆ 4   │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def groupby(
        self,
        by: Union[str, &quot;pli.Expr&quot;, Sequence[str], Sequence[&quot;pli.Expr&quot;]],
        maintain_order: bool = False,
    ) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a groupby operation.

        Parameters
        ----------
        by
            Column(s) to group by.
        maintain_order
            Make sure that the order of the groups remain consistent. This is more expensive than a default groupby.
            Note that this only works in expression aggregations.

        Examples
        --------
        Below we group by column `&quot;a&quot;`, and we sum column `&quot;b&quot;`.

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;],
        &gt;&gt;&gt;     &quot;b&quot;: [1, 2, 3, 4, 5, 6],
        &gt;&gt;&gt;     &quot;c&quot;: [6, 5, 4, 3, 2, 1],
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; assert (
        &gt;&gt;&gt;     df.groupby(&quot;a&quot;)[&quot;b&quot;]
        &gt;&gt;&gt;     .sum()
        &gt;&gt;&gt;     .sort(by_column=&quot;a&quot;)
        &gt;&gt;&gt;     .frame_equal(DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;: [4, 11, 6]})))

        We can also loop over the grouped `DataFrame`

        &gt;&gt;&gt; for sub_df in df.groupby(&quot;a&quot;):
        &gt;&gt;&gt;    print(sub_df)
        shape: (3, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;b&quot; ┆ 2   ┆ 5   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 4   ┆ 3   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot; ┆ 5   ┆ 2   │
        ╰─────┴─────┴─────╯
        shape: (1, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;c&quot; ┆ 6   ┆ 1   │
        ╰─────┴─────┴─────╯
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ a   ┆ b   ┆ c   │
        │ --- ┆ --- ┆ --- │
        │ str ┆ i64 ┆ i64 │
        ╞═════╪═════╪═════╡
        │ &quot;a&quot; ┆ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot; ┆ 3   ┆ 4   │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(by, str):
            by = [by]
        return GroupBy(
            self._df, by, maintain_order=maintain_order, downsample=False  # type: ignore
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedownsample"><a class="header" href="#polarsinternalsframedataframedownsample"><code>polars.internals.frame.DataFrame.downsample</code></a></h3>
<pre><code class="language-python">downsample(by: Union[str, tp.List[str]], 
    rule: str, 
    n: int,) -&gt; GroupBy:
</code></pre>
<p>Start a downsampling groupby operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>by</code>]: Column that will be used as key in the groupby operation.
This should be a datetime/date column.</p>
</li>
<li>
<p>[<code>rule</code>]: Units of the downscaling operation.</p>
<p>Any of:
- &quot;month&quot;
- &quot;week&quot;
- &quot;day&quot;
- &quot;hour&quot;
- &quot;minute&quot;
- &quot;second&quot;</p>
</li>
<li>
<p>[<code>n</code>]: Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.</p>
</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-02&quot;, &quot;2020-01-03&quot;,&quot;2020-01-04&quot;,&quot;2020-01-05&quot;,&quot;2020-01-06&quot;],
&quot;B&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0],
&quot;C&quot;: [3.0, 6.0, 9.0, 2.0, 13.0, 8.0],
&quot;D&quot;: [12.0, 5.0, 9.0, 2.0, 11.0, 2.0],
}
)
df['A'] = df['A'].str.strptime(pl.Date, &quot;%Y-%m-%d&quot;)</p>
<p>df.downsample(&quot;A&quot;, rule=&quot;day&quot;, n=3).agg(
{
&quot;B&quot;: &quot;max&quot;,
&quot;C&quot;: &quot;min&quot;,
&quot;D&quot;: &quot;last&quot;
}
)
shape: (3, 4)
┌──────────────┬───────┬───────┬────────┐
│ A            ┆ B_max ┆ C_min ┆ D_last │
│ ---          ┆ ---   ┆ ---   ┆ ---    │
│ date(days)   ┆ f64   ┆ f64   ┆ f64    │
╞══════════════╪═══════╪═══════╪════════╡
│ 2019-12-31   ┆ 8     ┆ 3     ┆ 5      │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2020-01-03   ┆ 16    ┆ 2     ┆ 11     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2020-01-06   ┆ 10    ┆ 8     ┆ 2      │
└──────────────┴───────┴───────┴────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def downsample(self, by: Union[str, tp.List[str]], rule: str, n: int) -&gt; &quot;GroupBy&quot;:
        &quot;&quot;&quot;
        Start a downsampling groupby operation.

        Parameters
        ----------
        by
            Column that will be used as key in the groupby operation.
            This should be a datetime/date column.
        rule
            Units of the downscaling operation.

            Any of:
                - &quot;month&quot;
                - &quot;week&quot;
                - &quot;day&quot;
                - &quot;hour&quot;
                - &quot;minute&quot;
                - &quot;second&quot;

        n
            Number of units (e.g. 5 &quot;day&quot;, 15 &quot;minute&quot;.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [&quot;2020-01-01&quot;, &quot;2020-01-02&quot;, &quot;2020-01-03&quot;,&quot;2020-01-04&quot;,&quot;2020-01-05&quot;,&quot;2020-01-06&quot;],
        &gt;&gt;&gt;         &quot;B&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0],
        &gt;&gt;&gt;         &quot;C&quot;: [3.0, 6.0, 9.0, 2.0, 13.0, 8.0],
        &gt;&gt;&gt;         &quot;D&quot;: [12.0, 5.0, 9.0, 2.0, 11.0, 2.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df['A'] = df['A'].str.strptime(pl.Date, &quot;%Y-%m-%d&quot;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; df.downsample(&quot;A&quot;, rule=&quot;day&quot;, n=3).agg(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;B&quot;: &quot;max&quot;,
        &gt;&gt;&gt;         &quot;C&quot;: &quot;min&quot;,
        &gt;&gt;&gt;         &quot;D&quot;: &quot;last&quot;
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        shape: (3, 4)
        ┌──────────────┬───────┬───────┬────────┐
        │ A            ┆ B_max ┆ C_min ┆ D_last │
        │ ---          ┆ ---   ┆ ---   ┆ ---    │
        │ date(days)   ┆ f64   ┆ f64   ┆ f64    │
        ╞══════════════╪═══════╪═══════╪════════╡
        │ 2019-12-31   ┆ 8     ┆ 3     ┆ 5      │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-03   ┆ 16    ┆ 2     ┆ 11     │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
        │ 2020-01-06   ┆ 10    ┆ 8     ┆ 2      │
        └──────────────┴───────┴───────┴────────┘

        &quot;&quot;&quot;
        return GroupBy(
            self._df,
            by,
            maintain_order=False,
            downsample=True,
            rule=rule,
            downsample_n=n,
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeupsample"><a class="header" href="#polarsinternalsframedataframeupsample"><code>polars.internals.frame.DataFrame.upsample</code></a></h3>
<pre><code class="language-python">upsample(by: str, interval: timedelta) -&gt; DataFrame:
</code></pre>
<p>Upsample a DataFrame at a regular frequency.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Column that will be used as key in the upsampling operation.
This should be a datetime column.</li>
<li>[<code>interval</code>]: Interval periods.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def upsample(self, by: str, interval: timedelta) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Upsample a DataFrame at a regular frequency.

        Parameters
        ----------
        by
            Column that will be used as key in the upsampling operation.
            This should be a datetime column.
        interval
            Interval periods.
        &quot;&quot;&quot;
        if self[by].dtype != Datetime:
            raise ValueError(
                f&quot;Column {by} should be of type datetime. Got {self[by].dtype}&quot;
            )
        bounds = self.select(
            [pli.col(by).min().alias(&quot;low&quot;), pli.col(by).max().alias(&quot;high&quot;)]
        )
        low = bounds[&quot;low&quot;].dt[0]
        high = bounds[&quot;high&quot;].dt[0]
        upsampled = pli.date_range(low, high, interval, name=by)
        return DataFrame(upsampled).join(self, on=by, how=&quot;left&quot;)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframejoin"><a class="header" href="#polarsinternalsframedataframejoin"><code>polars.internals.frame.DataFrame.join</code></a></h3>
<pre><code class="language-python">join(df: DataFrame, 
    left_on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    right_on: OptionalUnion[str, pli.Expr, tp.List[str], tp.List[pli.Expr]], 
    on: OptionalUnion[str, tp.List[str]], 
    how: str, 
    suffix: str, 
    asof_by: OptionalUnion[str, tp.List[str]], 
    asof_by_left: OptionalUnion[str, tp.List[str]], 
    asof_by_right: OptionalUnion[str, tp.List[str]],) -&gt; DataFrame:
</code></pre>
<p>SQL like joins.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>df</code>]: DataFrame to join with.</p>
</li>
<li>
<p>[<code>left_on</code>]: Name(s) of the left join column(s).</p>
</li>
<li>
<p>[<code>right_on</code>]: Name(s) of the right join column(s).</p>
</li>
<li>
<p>[<code>on</code>]: Name(s) of the join columns in both DataFrames.</p>
</li>
<li>
<p>[<code>how</code>]: Join strategy
- &quot;inner&quot;
- &quot;left&quot;
- &quot;outer&quot;
- &quot;asof&quot;
- &quot;cross&quot;</p>
</li>
<li>
<p>[<code>suffix</code>]: Suffix to append to columns with a duplicate name.</p>
</li>
<li>
<p>[<code>asof_by</code>]: join on these columns before doing asof join</p>
</li>
<li>
<p>[<code>asof_by_left</code>]: join on these columns before doing asof join</p>
</li>
<li>
<p>[<code>asof_by_right</code>]: join on these columns before doing asof join
<strong>Returns:</strong></p>
<p>Joined DataFrame</p>
</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
other_df = pl.DataFrame({
&quot;apple&quot;: ['x', 'y', 'z'],
&quot;ham&quot;: ['a', 'b', 'd']
})
df.join(other_df, on='ham')
shape: (2, 4)
╭─────┬─────┬─────┬───────╮
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ f64 ┆ str ┆ str   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6   ┆ &quot;a&quot; ┆ &quot;x&quot;   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; ┆ &quot;y&quot;   │
╰─────┴─────┴─────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>df.join(other_df, on='ham', how='outer')
shape: (4, 4)
╭──────┬──────┬─────┬───────╮
│ foo  ┆ bar  ┆ ham ┆ apple │
│ ---  ┆ ---  ┆ --- ┆ ---   │
│ i64  ┆ f64  ┆ str ┆ str   │
╞══════╪══════╪═════╪═══════╡
│ 1    ┆ 6    ┆ &quot;a&quot; ┆ &quot;x&quot;   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2    ┆ 7    ┆ &quot;b&quot; ┆ &quot;y&quot;   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ null ┆ null ┆ &quot;d&quot; ┆ &quot;z&quot;   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3    ┆ 8    ┆ &quot;c&quot; ┆ null  │
╰──────┴──────┴─────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="asof-join"><a class="header" href="#asof-join">Asof join</a></h1>
<p>This is similar to a left-join except that we match on nearest key rather than equal keys.
The keys must be sorted to perform an asof join</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def join(
        self,
        df: &quot;DataFrame&quot;,
        left_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        right_on: Optional[
            Union[str, &quot;pli.Expr&quot;, tp.List[str], tp.List[&quot;pli.Expr&quot;]]
        ] = None,
        on: Optional[Union[str, tp.List[str]]] = None,
        how: str = &quot;inner&quot;,
        suffix: str = &quot;_right&quot;,
        asof_by: Optional[Union[str, tp.List[str]]] = None,
        asof_by_left: Optional[Union[str, tp.List[str]]] = None,
        asof_by_right: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        SQL like joins.

        Parameters
        ----------
        df
            DataFrame to join with.
        left_on
            Name(s) of the left join column(s).
        right_on
            Name(s) of the right join column(s).
        on
            Name(s) of the join columns in both DataFrames.
        how
            Join strategy
                - &quot;inner&quot;
                - &quot;left&quot;
                - &quot;outer&quot;
                - &quot;asof&quot;
                - &quot;cross&quot;
        suffix
            Suffix to append to columns with a duplicate name.
        asof_by
            join on these columns before doing asof join
        asof_by_left
            join on these columns before doing asof join
        asof_by_right
            join on these columns before doing asof join
        Returns
        -------
            Joined DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; other_df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;apple&quot;: ['x', 'y', 'z'],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.join(other_df, on='ham')
        shape: (2, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ f64 ┆ str ┆ str   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ╰─────┴─────┴─────┴───────╯

        &gt;&gt;&gt; df.join(other_df, on='ham', how='outer')
        shape: (4, 4)
        ╭──────┬──────┬─────┬───────╮
        │ foo  ┆ bar  ┆ ham ┆ apple │
        │ ---  ┆ ---  ┆ --- ┆ ---   │
        │ i64  ┆ f64  ┆ str ┆ str   │
        ╞══════╪══════╪═════╪═══════╡
        │ 1    ┆ 6    ┆ &quot;a&quot; ┆ &quot;x&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot; ┆ &quot;y&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ null ┆ null ┆ &quot;d&quot; ┆ &quot;z&quot;   │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot; ┆ null  │
        ╰──────┴──────┴─────┴───────╯

        Asof join
        =========
        This is similar to a left-join except that we match on nearest key rather than equal keys.
        The keys must be sorted to perform an asof join

        &quot;&quot;&quot;
        if how == &quot;cross&quot;:
            return wrap_df(self._df.join(df._df, [], [], how, suffix))

        left_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(left_on, (str, pli.Expr)):
            left_on_ = [left_on]  # type: ignore[assignment]
        else:
            left_on_ = left_on

        right_on_: Union[tp.List[str], tp.List[pli.Expr], None]
        if isinstance(right_on, (str, pli.Expr)):
            right_on_ = [right_on]  # type: ignore[assignment]
        else:
            right_on_ = right_on

        if isinstance(on, str):
            left_on_ = [on]
            right_on_ = [on]
        elif isinstance(on, list):
            left_on_ = on
            right_on_ = on

        if left_on_ is None or right_on_ is None:
            raise ValueError(&quot;You should pass the column to join on as an argument.&quot;)

        if (
            isinstance(left_on_[0], pli.Expr)
            or isinstance(right_on_[0], pli.Expr)
            or asof_by_left is not None
            or asof_by_right is not None
            or asof_by is not None
        ):
            return (
                self.lazy()
                .join(
                    df.lazy(),
                    left_on,
                    right_on,
                    on=on,
                    how=how,
                    suffix=suffix,
                    asof_by_right=asof_by_right,
                    asof_by_left=asof_by_left,
                    asof_by=asof_by,
                )
                .collect(no_optimization=True)
            )
        else:
            return wrap_df(self._df.join(df._df, left_on_, right_on_, how, suffix))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeapply"><a class="header" href="#polarsinternalsframedataframeapply"><code>polars.internals.frame.DataFrame.apply</code></a></h3>
<pre><code class="language-python">apply(f: Callable[[TupleAny], Any], 
    return_dtype: OptionalTypeDataType,) -&gt; pli.Series:
</code></pre>
<p>Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.</p>
<p>Beware, this is slow.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Custom function/ lambda function.</li>
<li>[<code>return_dtype</code>]: Output type of the operation. If none given, Polars tries to infer the type.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        f: Callable[[Tuple[Any]], Any],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a custom function over the rows of the DataFrame. The rows are passed as tuple.

        Beware, this is slow.

        Parameters
        ----------
        f
            Custom function/ lambda function.
        return_dtype
            Output type of the operation. If none given, Polars tries to infer the type.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.apply(f, return_dtype))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_column"><a class="header" href="#polarsinternalsframedataframewith_column"><code>polars.internals.frame.DataFrame.with_column</code></a></h3>
<pre><code class="language-python">with_column(column: Union[pli.Series, pli.Expr],) -&gt; DataFrame:
</code></pre>
<p>Return a new DataFrame with the column added or replaced.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>column</code>]: Series, where the name of the Series refers to the column in the DataFrame.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_column(self, column: Union[&quot;pli.Series&quot;, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column added or replaced.

        Parameters
        ----------
        column
            Series, where the name of the Series refers to the column in the DataFrame.
        &quot;&quot;&quot;
        if isinstance(column, pli.Expr):
            return self.with_columns([column])
        else:
            return wrap_df(self._df.with_column(column._s))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_column_renamed"><a class="header" href="#polarsinternalsframedataframewith_column_renamed"><code>polars.internals.frame.DataFrame.with_column_renamed</code></a></h3>
<pre><code class="language-python">with_column_renamed(existing_name: str, 
    new_name: str,) -&gt; DataFrame:
</code></pre>
<p>Return a new DataFrame with the column renamed.</p>
<p><strong>Parameters:</strong></p>
<p>existing_name
new_name</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_column_renamed(self, existing_name: str, new_name: str) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Return a new DataFrame with the column renamed.

        Parameters
        ----------
        existing_name
        new_name
        &quot;&quot;&quot;
        return (
            self.lazy()
            .with_column_renamed(existing_name, new_name)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframehstack"><a class="header" href="#polarsinternalsframedataframehstack"><code>polars.internals.frame.DataFrame.hstack</code></a></h3>
<pre><code class="language-python">hstack(columns: Union[tp.List[pli.Series], DataFrame], 
    in_place: bool,) -&gt; OptionalDataFrame:
</code></pre>
<p>Return a new DataFrame grown horizontally by stacking multiple Series to it.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: Series to stack.</li>
<li>[<code>in_place</code>]: Modify in place.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
x = pl.Series(&quot;apple&quot;, [10, 20, 30])
df.hstack([x])
shape: (3, 4)
╭─────┬─────┬─────┬───────╮
│ foo ┆ bar ┆ ham ┆ apple │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ i64 ┆ str ┆ i64   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ 6   ┆ &quot;a&quot; ┆ 10    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; ┆ 20    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; ┆ 30    │
╰─────┴─────┴─────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hstack(
        self, columns: Union[tp.List[&quot;pli.Series&quot;], &quot;DataFrame&quot;], in_place: bool = False
    ) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Return a new DataFrame grown horizontally by stacking multiple Series to it.

        Parameters
        ----------
        columns
            Series to stack.
        in_place
            Modify in place.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; x = pl.Series(&quot;apple&quot;, [10, 20, 30])
        &gt;&gt;&gt; df.hstack([x])
        shape: (3, 4)
        ╭─────┬─────┬─────┬───────╮
        │ foo ┆ bar ┆ ham ┆ apple │
        │ --- ┆ --- ┆ --- ┆ ---   │
        │ i64 ┆ i64 ┆ str ┆ i64   │
        ╞═════╪═════╪═════╪═══════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; ┆ 10    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; ┆ 20    │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; ┆ 30    │
        ╰─────┴─────┴─────┴───────╯

        &quot;&quot;&quot;
        if not isinstance(columns, list):
            columns = columns.get_columns()
        if in_place:
            self._df.hstack_mut([s.inner() for s in columns])
            return None
        else:
            return wrap_df(self._df.hstack([s.inner() for s in columns]))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframevstack"><a class="header" href="#polarsinternalsframedataframevstack"><code>polars.internals.frame.DataFrame.vstack</code></a></h3>
<pre><code class="language-python">vstack(df: DataFrame, 
    in_place: bool,) -&gt; OptionalDataFrame:
</code></pre>
<p>Grow this DataFrame vertically by stacking a DataFrame to it.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>df</code>]: DataFrame to stack.</li>
<li>[<code>in_place</code>]: Modify in place</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df1 = pl.DataFrame({
&quot;foo&quot;: [1, 2],
&quot;bar&quot;: [6, 7],
&quot;ham&quot;: ['a', 'b']
})
df2 = pl.DataFrame({
&quot;foo&quot;: [3, 4],
&quot;bar&quot;: [8 , 9],
&quot;ham&quot;: ['c', 'd']
})
df1.vstack(df2)
shape: (4, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 4   ┆ 9   ┆ &quot;d&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def vstack(self, df: &quot;DataFrame&quot;, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Grow this DataFrame vertically by stacking a DataFrame to it.

        Parameters
        ----------
        df
            DataFrame to stack.
        in_place
            Modify in place

        Examples
        --------

        &gt;&gt;&gt; df1 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df2 = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [3, 4],
        &gt;&gt;&gt;     &quot;bar&quot;: [8 , 9],
        &gt;&gt;&gt;     &quot;ham&quot;: ['c', 'd']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df1.vstack(df2)
        shape: (4, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 4   ┆ 9   ┆ &quot;d&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if in_place:
            self._df.vstack_mut(df._df)
            return None
        else:
            return wrap_df(self._df.vstack(df._df))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop"><a class="header" href="#polarsinternalsframedataframedrop"><code>polars.internals.frame.DataFrame.drop</code></a></h3>
<pre><code class="language-python">drop(name: Union[str, tp.List[str]]) -&gt; DataFrame:
</code></pre>
<p>Remove column from DataFrame and return as new.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Column(s) to drop.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6.0, 7.0, 8.0],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.drop('ham')
shape: (3, 2)
╭─────┬─────╮
│ foo ┆ bar │
│ --- ┆ --- │
│ i64 ┆ f64 │
╞═════╪═════╡
│ 1   ┆ 6   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop(self, name: Union[str, tp.List[str]]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Remove column from DataFrame and return as new.

        Parameters
        ----------
        name
            Column(s) to drop.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6.0, 7.0, 8.0],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop('ham')
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ f64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        if isinstance(name, list):
            df = self.clone()

            for name in name:
                df._df.drop_in_place(name)
            return df

        return wrap_df(self._df.drop(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop_in_place"><a class="header" href="#polarsinternalsframedataframedrop_in_place"><code>polars.internals.frame.DataFrame.drop_in_place</code></a></h3>
<pre><code class="language-python">drop_in_place(name: str) -&gt; pli.Series:
</code></pre>
<p>Drop in place.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: Column to drop.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.drop_in_place(&quot;ham&quot;)
shape: (3, 2)
╭─────┬─────╮
│ foo ┆ bar │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 1   ┆ 6   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_in_place(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Drop in place.

        Parameters
        ----------
        name
            Column to drop.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;    &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;    &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;    })
        &gt;&gt;&gt; df.drop_in_place(&quot;ham&quot;)
        shape: (3, 2)
        ╭─────┬─────╮
        │ foo ┆ bar │
        │ --- ┆ --- │
        │ i64 ┆ i64 │
        ╞═════╪═════╡
        │ 1   ┆ 6   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   │
        ╰─────┴─────╯

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.drop_in_place(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeselect_at_idx"><a class="header" href="#polarsinternalsframedataframeselect_at_idx"><code>polars.internals.frame.DataFrame.select_at_idx</code></a></h3>
<pre><code class="language-python">select_at_idx(idx: int) -&gt; pli.Series:
</code></pre>
<p>Select column at index location.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>idx</code>]: Location of selection.</li>
</ul>
<p>.. deprecated:: 0.10.20</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.select_at_idx(1))
shape: (3,)
Series: 'bar' [i64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  8
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def select_at_idx(self, idx: int) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Select column at index location.

        Parameters
        ----------
        idx
            Location of selection.

        .. deprecated:: 0.10.20

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select_at_idx(1))
        shape: (3,)
        Series: 'bar' [i64]
        [
                6
                7
                8
        ]

        &quot;&quot;&quot;
        return pli.wrap_s(self._df.select_at_idx(idx))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeclone"><a class="header" href="#polarsinternalsframedataframeclone"><code>polars.internals.frame.DataFrame.clone</code></a></h3>
<pre><code class="language-python">clone() -&gt; DataFrame:
</code></pre>
<p>Very cheap deep clone.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clone(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Very cheap deep clone.
        &quot;&quot;&quot;
        return wrap_df(self._df.clone())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeget_columns"><a class="header" href="#polarsinternalsframedataframeget_columns"><code>polars.internals.frame.DataFrame.get_columns</code></a></h3>
<pre><code class="language-python">get_columns() -&gt; tp.List[pli.Series]:
</code></pre>
<p>Get the DataFrame as a List of Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def get_columns(self) -&gt; tp.List[&quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Get the DataFrame as a List of Series.
        &quot;&quot;&quot;
        return list(map(lambda s: pli.wrap_s(s), self._df.get_columns()))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeget_column"><a class="header" href="#polarsinternalsframedataframeget_column"><code>polars.internals.frame.DataFrame.get_column</code></a></h3>
<pre><code class="language-python">get_column(name: str) -&gt; pli.Series:
</code></pre>
<p>Get a single column as Series by name.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def get_column(self, name: str) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a single column as Series by name.
        &quot;&quot;&quot;
        return self[name]
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefill_null"><a class="header" href="#polarsinternalsframedataframefill_null"><code>polars.internals.frame.DataFrame.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(strategy: Union[str, pli.Expr]) -&gt; DataFrame:
</code></pre>
<p>Fill None/missing values by a filling strategy or an Expression evaluation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>strategy</code>]: One of:
<ul>
<li>&quot;backward&quot;</li>
<li>&quot;forward&quot;</li>
<li>&quot;mean&quot;</li>
<li>&quot;min'</li>
<li>&quot;max&quot;</li>
<li>&quot;zero&quot;</li>
<li>&quot;one&quot;
Or an expression.</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong></p>
<pre><code>DataFrame with None replaced with the filling strategy.
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, strategy: Union[str, &quot;pli.Expr&quot;]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a filling strategy or an Expression evaluation.

        Parameters
        ----------
        strategy
            One of:
            - &quot;backward&quot;
            - &quot;forward&quot;
            - &quot;mean&quot;
            - &quot;min'
            - &quot;max&quot;
            - &quot;zero&quot;
            - &quot;one&quot;
            Or an expression.

        Returns
        -------
            DataFrame with None replaced with the filling strategy.
        &quot;&quot;&quot;
        if isinstance(strategy, pli.Expr):
            return self.lazy().fill_null(strategy).collect(no_optimization=True)
        if not isinstance(strategy, str):
            return self.fill_null(pli.lit(strategy))
        return wrap_df(self._df.fill_null(strategy))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefill_nan"><a class="header" href="#polarsinternalsframedataframefill_nan"><code>polars.internals.frame.DataFrame.fill_nan</code></a></h3>
<pre><code class="language-python">fill_nan(fill_value: Union[pli.Expr, int, float],) -&gt; DataFrame:
</code></pre>
<p>Fill None/missing values by a an Expression evaluation.</p>
<p><strong>Warnings:</strong></p>
<p>NOTE that floating point NaN (No a Number) are not missing values!
to replace missing values, use <code>fill_null</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>fill_value</code>]: value to fill NaN with</li>
</ul>
<p><strong>Returns:</strong></p>
<pre><code>DataFrame with NaN replaced with fill_value
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_nan(self, fill_value: Union[&quot;pli.Expr&quot;, int, float]) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Fill None/missing values by a an Expression evaluation.

        Warnings
        --------
        NOTE that floating point NaN (No a Number) are not missing values!
        to replace missing values, use `fill_null`.

        Parameters
        ----------
        fill_value
            value to fill NaN with

        Returns
        -------
            DataFrame with NaN replaced with fill_value
        &quot;&quot;&quot;
        return self.lazy().fill_nan(fill_value).collect(no_optimization=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeexplode"><a class="header" href="#polarsinternalsframedataframeexplode"><code>polars.internals.frame.DataFrame.explode</code></a></h3>
<pre><code class="language-python">explode(columns: Union[str, tp.List[str], pli.Expr, tp.List[pli.Expr]],) -&gt; DataFrame:
</code></pre>
<p>Explode <code>DataFrame</code> to long format by exploding a column with Lists.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>columns</code>]: Column of LargeList type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>DataFrame</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
&quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
})
df
shape: (6, 2)
╭─────────┬────────────╮
│ letters ┆ nrs        │
│ ---     ┆ ---        │
│ str     ┆ list [i64] │
╞═════════╪════════════╡
│ &quot;c&quot;     ┆ [1, 2]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;c&quot;     ┆ [1, 3]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;a&quot;     ┆ [4, 3]     │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;c&quot;     ┆ [5, 5, 5]  │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;a&quot;     ┆ [6]        │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;b&quot;     ┆ [2, 1, 2]  │
╰─────────┴────────────╯
df.explode(&quot;nrs&quot;)
shape: (13, 2)
╭─────────┬─────╮
│ letters ┆ nrs │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 3   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ ...     ┆ ... │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;c&quot;     ┆ 5   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;a&quot;     ┆ 6   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 2   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 1   │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;b&quot;     ┆ 2   │
╰─────────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(
        self, columns: Union[str, tp.List[str], &quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Explode `DataFrame` to long format by exploding a column with Lists.

        Parameters
        ----------
        columns
            Column of LargeList type.

        Returns
        -------
        DataFrame

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;letters&quot;: [&quot;c&quot;, &quot;c&quot;, &quot;a&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;],
        &gt;&gt;&gt;     &quot;nrs&quot;: [[1, 2], [1, 3], [4, 3], [5, 5, 5], [6], [2, 1, 2]]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (6, 2)
        ╭─────────┬────────────╮
        │ letters ┆ nrs        │
        │ ---     ┆ ---        │
        │ str     ┆ list [i64] │
        ╞═════════╪════════════╡
        │ &quot;c&quot;     ┆ [1, 2]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [1, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [4, 3]     │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ [5, 5, 5]  │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ [6]        │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ [2, 1, 2]  │
        ╰─────────┴────────────╯
        &gt;&gt;&gt; df.explode(&quot;nrs&quot;)
        shape: (13, 2)
        ╭─────────┬─────╮
        │ letters ┆ nrs │
        │ ---     ┆ --- │
        │ str     ┆ i64 │
        ╞═════════╪═════╡
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 3   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ ...     ┆ ... │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;c&quot;     ┆ 5   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;a&quot;     ┆ 6   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 1   │
        ├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
        │ &quot;b&quot;     ┆ 2   │
        ╰─────────┴─────╯

        &quot;&quot;&quot;
        return self.lazy().explode(columns).collect(no_optimization=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemelt"><a class="header" href="#polarsinternalsframedataframemelt"><code>polars.internals.frame.DataFrame.melt</code></a></h3>
<pre><code class="language-python">melt(id_vars: Union[tp.List[str], str], 
    value_vars: Union[tp.List[str], str],) -&gt; DataFrame:
</code></pre>
<p>Unpivot DataFrame to long format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>
<p>[<code>id_vars</code>]: Columns to use as identifier variables.</p>
</li>
<li>
<p>[<code>value_vars</code>]: Values to use as identifier variables.</p>
</li>
</ul>
<p><strong>Returns:</strong></p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def melt(
        self, id_vars: Union[tp.List[str], str], value_vars: Union[tp.List[str], str]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Unpivot DataFrame to long format.

        Parameters
        ----------
        id_vars
            Columns to use as identifier variables.

        value_vars
            Values to use as identifier variables.

        Returns
        -------

        &quot;&quot;&quot;
        if isinstance(value_vars, str):
            value_vars = [value_vars]
        if isinstance(id_vars, str):
            id_vars = [id_vars]
        return wrap_df(self._df.melt(id_vars, value_vars))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshift"><a class="header" href="#polarsinternalsframedataframeshift"><code>polars.internals.frame.DataFrame.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; DataFrame:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.shift(periods=1)
shape: (3, 3)
┌──────┬──────┬──────┐
│ foo  ┆ bar  ┆ ham  │
│ ---  ┆ ---  ┆ ---  │
│ i64  ┆ i64  ┆ str  │
╞══════╪══════╪══════╡
│ null ┆ null ┆ null │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 1    ┆ 6    ┆ &quot;a&quot;  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ 7    ┆ &quot;b&quot;  │
└──────┴──────┴──────┘
df.shift(periods=-1)
shape: (3, 3)
┌──────┬──────┬──────┐
│ foo  ┆ bar  ┆ ham  │
│ ---  ┆ ---  ┆ ---  │
│ i64  ┆ i64  ┆ str  │
╞══════╪══════╪══════╡
│ 2    ┆ 7    ┆ &quot;b&quot;  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3    ┆ 8    ┆ &quot;c&quot;  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ null ┆ null │
└──────┴──────┴──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift(periods=1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ null ┆ null ┆ null │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 1    ┆ 6    ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        └──────┴──────┴──────┘
        &gt;&gt;&gt; df.shift(periods=-1)
        shape: (3, 3)
        ┌──────┬──────┬──────┐
        │ foo  ┆ bar  ┆ ham  │
        │ ---  ┆ ---  ┆ ---  │
        │ i64  ┆ i64  ┆ str  │
        ╞══════╪══════╪══════╡
        │ 2    ┆ 7    ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3    ┆ 8    ┆ &quot;c&quot;  │
        ├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ null ┆ null ┆ null │
        └──────┴──────┴──────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshift_and_fill"><a class="header" href="#polarsinternalsframedataframeshift_and_fill"><code>polars.internals.frame.DataFrame.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, 
    fill_value: Union[int, str, float],) -&gt; DataFrame:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: fill None values with this value.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.shift_and_fill(periods=1, fill_value=0)
shape: (3, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 0   ┆ 0   ┆ &quot;0&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ 7   ┆ &quot;b&quot; │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(
        self, periods: int, fill_value: Union[int, str, float]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            fill None values with this value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.shift_and_fill(periods=1, fill_value=0)
        shape: (3, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 0   ┆ 0   ┆ &quot;0&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 2   ┆ 7   ┆ &quot;b&quot; │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return (
            self.lazy()
            .shift_and_fill(periods, fill_value)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeis_duplicated"><a class="header" href="#polarsinternalsframedataframeis_duplicated"><code>polars.internals.frame.DataFrame.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; pli.Series:
</code></pre>
<p>Get a mask of all duplicated rows in this DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all duplicated rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeis_unique"><a class="header" href="#polarsinternalsframedataframeis_unique"><code>polars.internals.frame.DataFrame.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; pli.Series:
</code></pre>
<p>Get a mask of all unique rows in this DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Get a mask of all unique rows in this DataFrame.
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframelazy"><a class="header" href="#polarsinternalsframedataframelazy"><code>polars.internals.frame.DataFrame.lazy</code></a></h3>
<pre><code class="language-python">lazy() -&gt; pli.LazyFrame:
</code></pre>
<p>Start a lazy query from this point. This returns a <code>LazyFrame</code> object.</p>
<p>Operations on a <code>LazyFrame</code> are not executed until this is requested by either calling:</p>
<ul>
<li><code>.fetch()</code> (run on a small number of rows)</li>
<li><code>.collect()</code> (run on all data)</li>
<li><code>.describe_plan()</code> (print unoptimized query plan)</li>
<li><code>.describe_optimized_plan()</code> (print optimized query plan)</li>
<li><code>.show_graph()</code> (show (un)optimized query plan) as graphiz graph)</li>
</ul>
<p>Lazy operations are advised because they allow for query optimization and more parallelization.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lazy(self) -&gt; &quot;pli.LazyFrame&quot;:
        &quot;&quot;&quot;
        Start a lazy query from this point. This returns a `LazyFrame` object.

        Operations on a `LazyFrame` are not executed until this is requested by either calling:

        * `.fetch()` (run on a small number of rows)
        * `.collect()` (run on all data)
        * `.describe_plan()` (print unoptimized query plan)
        * `.describe_optimized_plan()` (print optimized query plan)
        * `.show_graph()` (show (un)optimized query plan) as graphiz graph)

        Lazy operations are advised because they allow for query optimization and more parallelization.
        &quot;&quot;&quot;
        return pli.wrap_ldf(self._df.lazy())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeselect"><a class="header" href="#polarsinternalsframedataframeselect"><code>polars.internals.frame.DataFrame.select</code></a></h3>
<pre><code class="language-python">select(exprs: Union[str, pli.Expr, SequenceUnion[str, pli.Expr], Sequencebool, Sequenceint, Sequencefloat],) -&gt; DataFrame:
</code></pre>
<p>Select columns from this DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: Column or columns to select.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.select('foo')
shape: (3, 1)
┌─────┐
│ foo │
│ --- │
│ i64 │
╞═════╡
│ 1   │
├╌╌╌╌╌┤
│ 2   │
├╌╌╌╌╌┤
│ 3   │
└─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def select(
        self,
        exprs: Union[
            str,
            &quot;pli.Expr&quot;,
            Sequence[Union[str, &quot;pli.Expr&quot;]],
            Sequence[bool],
            Sequence[int],
            Sequence[float],
        ],
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Select columns from this DataFrame.

        Parameters
        ----------
        exprs
            Column or columns to select.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.select('foo')
        shape: (3, 1)
        ┌─────┐
        │ foo │
        │ --- │
        │ i64 │
        ╞═════╡
        │ 1   │
        ├╌╌╌╌╌┤
        │ 2   │
        ├╌╌╌╌╌┤
        │ 3   │
        └─────┘

        &quot;&quot;&quot;
        return (
            self.lazy().select(exprs).collect(no_optimization=True, string_cache=False)  # type: ignore
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframewith_columns"><a class="header" href="#polarsinternalsframedataframewith_columns"><code>polars.internals.frame.DataFrame.with_columns</code></a></h3>
<pre><code class="language-python">with_columns(exprs: Union[pli.Expr, tp.List[pli.Expr]],) -&gt; DataFrame:
</code></pre>
<p>Add or overwrite multiple columns in a DataFrame.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>exprs</code>]: List of Expressions that evaluate to columns.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def with_columns(
        self, exprs: Union[&quot;pli.Expr&quot;, tp.List[&quot;pli.Expr&quot;]]
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Add or overwrite multiple columns in a DataFrame.

        Parameters
        ----------
        exprs
            List of Expressions that evaluate to columns.
        &quot;&quot;&quot;
        if not isinstance(exprs, list):
            exprs = [exprs]
        return (
            self.lazy()
            .with_columns(exprs)
            .collect(no_optimization=True, string_cache=False)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframen_chunks"><a class="header" href="#polarsinternalsframedataframen_chunks"><code>polars.internals.frame.DataFrame.n_chunks</code></a></h3>
<pre><code class="language-python">n_chunks() -&gt; int:
</code></pre>
<p>Get number of chunks used by the ChunkedArrays of this DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_chunks(self) -&gt; int:
        &quot;&quot;&quot;
        Get number of chunks used by the ChunkedArrays of this DataFrame.
        &quot;&quot;&quot;
        return self._df.n_chunks()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemax"><a class="header" href="#polarsinternalsframedataframemax"><code>polars.internals.frame.DataFrame.max</code></a></h3>
<pre><code class="language-python">max(axis: int) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their maximum value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.max()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 3   ┆ 8   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their maximum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.max()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 3   ┆ 8   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.max())
        if axis == 1:
            return pli.wrap_s(self._df.hmax())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemin"><a class="header" href="#polarsinternalsframedataframemin"><code>polars.internals.frame.DataFrame.min</code></a></h3>
<pre><code class="language-python">min(axis: int) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their minimum value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.min()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 6   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self, axis: int = 0) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their minimum value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.min()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 6   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.min())
        if axis == 1:
            return pli.wrap_s(self._df.hmin())
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframesum"><a class="header" href="#polarsinternalsframedataframesum"><code>polars.internals.frame.DataFrame.sum</code></a></h3>
<pre><code class="language-python">sum(axis: int, 
    null_strategy: str,) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their sum value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>axis</code>]: either 0 or 1</li>
<li>[<code>null_strategy</code>]: {'ignore', 'propagate'}
this argument is only used if axis == 1</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.sum()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 6   ┆ 21  ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their sum value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sum()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 6   ┆ 21  ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.sum())
        if axis == 1:
            return pli.wrap_s(self._df.hsum(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemean"><a class="header" href="#polarsinternalsframedataframemean"><code>polars.internals.frame.DataFrame.mean</code></a></h3>
<pre><code class="language-python">mean(axis: int, 
    null_strategy: str,) -&gt; Union[DataFrame, pli.Series]:
</code></pre>
<p>Aggregate the columns of this DataFrame to their mean value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>axis</code>]: either 0 or 1</li>
<li>[<code>null_strategy</code>]: {'ignore', 'propagate'}
this argument is only used if axis == 1</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.mean()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 2   ┆ 7   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(
        self, axis: int = 0, null_strategy: str = &quot;ignore&quot;
    ) -&gt; Union[&quot;DataFrame&quot;, &quot;pli.Series&quot;]:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their mean value.

        Parameters
        ----------
        axis
            either 0 or 1
        null_strategy
            {'ignore', 'propagate'}
            this argument is only used if axis == 1

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.mean()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        if axis == 0:
            return wrap_df(self._df.mean())
        if axis == 1:
            return pli.wrap_s(self._df.hmean(null_strategy))
        raise ValueError(&quot;Axis should be 0 or 1.&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframestd"><a class="header" href="#polarsinternalsframedataframestd"><code>polars.internals.frame.DataFrame.std</code></a></h3>
<pre><code class="language-python">std() -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their standard deviation value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.std()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 1   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their standard deviation value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.std()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.std())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframevar"><a class="header" href="#polarsinternalsframedataframevar"><code>polars.internals.frame.DataFrame.var</code></a></h3>
<pre><code class="language-python">var() -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their variance value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.var()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 1   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their variance value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.var()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.var())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframemedian"><a class="header" href="#polarsinternalsframedataframemedian"><code>polars.internals.frame.DataFrame.median</code></a></h3>
<pre><code class="language-python">median() -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their median value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.median()
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ f64 ┆ f64 ┆ str  │
╞═════╪═════╪══════╡
│ 1   ┆ 1   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their median value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.median()
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ f64 ┆ f64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 1   ┆ 1   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.median())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframequantile"><a class="header" href="#polarsinternalsframedataframequantile"><code>polars.internals.frame.DataFrame.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; DataFrame:
</code></pre>
<p>Aggregate the columns of this DataFrame to their quantile value.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.quantile(0.5)
shape: (1, 3)
╭─────┬─────┬──────╮
│ foo ┆ bar ┆ ham  │
│ --- ┆ --- ┆ ---  │
│ i64 ┆ i64 ┆ str  │
╞═════╪═════╪══════╡
│ 2   ┆ 7   ┆ null │
╰─────┴─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Aggregate the columns of this DataFrame to their quantile value.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.quantile(0.5)
        shape: (1, 3)
        ╭─────┬─────┬──────╮
        │ foo ┆ bar ┆ ham  │
        │ --- ┆ --- ┆ ---  │
        │ i64 ┆ i64 ┆ str  │
        ╞═════╪═════╪══════╡
        │ 2   ┆ 7   ┆ null │
        ╰─────┴─────┴──────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.quantile(quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeto_dummies"><a class="header" href="#polarsinternalsframedataframeto_dummies"><code>polars.internals.frame.DataFrame.to_dummies</code></a></h3>
<pre><code class="language-python">to_dummies() -&gt; DataFrame:
</code></pre>
<p>Get one hot encoded dummy variables.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.to_dummies()
shape: (3, 9)
╭───────┬───────┬───────┬───────┬─────┬───────┬───────┬───────┬───────╮
│ foo_1 ┆ foo_2 ┆ foo_3 ┆ bar_6 ┆ ... ┆ bar_8 ┆ ham_a ┆ ham_b ┆ ham_c │
│ ---   ┆ ---   ┆ ---   ┆ ---   ┆     ┆ ---   ┆ ---   ┆ ---   ┆ ---   │
│ u8    ┆ u8    ┆ u8    ┆ u8    ┆     ┆ u8    ┆ u8    ┆ u8    ┆ u8    │
╞═══════╪═══════╪═══════╪═══════╪═════╪═══════╪═══════╪═══════╪═══════╡
│ 1     ┆ 0     ┆ 0     ┆ 1     ┆ ... ┆ 0     ┆ 1     ┆ 0     ┆ 0     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 0     ┆ 1     ┆ 0     ┆ 0     ┆ ... ┆ 0     ┆ 0     ┆ 1     ┆ 0     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 0     ┆ 0     ┆ 1     ┆ 0     ┆ ... ┆ 1     ┆ 0     ┆ 0     ┆ 1     │
╰───────┴───────┴───────┴───────┴─────┴───────┴───────┴───────┴───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def to_dummies(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Get one hot encoded dummy variables.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.to_dummies()
        shape: (3, 9)
        ╭───────┬───────┬───────┬───────┬─────┬───────┬───────┬───────┬───────╮
        │ foo_1 ┆ foo_2 ┆ foo_3 ┆ bar_6 ┆ ... ┆ bar_8 ┆ ham_a ┆ ham_b ┆ ham_c │
        │ ---   ┆ ---   ┆ ---   ┆ ---   ┆     ┆ ---   ┆ ---   ┆ ---   ┆ ---   │
        │ u8    ┆ u8    ┆ u8    ┆ u8    ┆     ┆ u8    ┆ u8    ┆ u8    ┆ u8    │
        ╞═══════╪═══════╪═══════╪═══════╪═════╪═══════╪═══════╪═══════╪═══════╡
        │ 1     ┆ 0     ┆ 0     ┆ 1     ┆ ... ┆ 0     ┆ 1     ┆ 0     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 1     ┆ 0     ┆ 0     ┆ ... ┆ 0     ┆ 0     ┆ 1     ┆ 0     │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
        │ 0     ┆ 0     ┆ 1     ┆ 0     ┆ ... ┆ 1     ┆ 0     ┆ 0     ┆ 1     │
        ╰───────┴───────┴───────┴───────┴─────┴───────┴───────┴───────┴───────╯

        &quot;&quot;&quot;
        return wrap_df(self._df.to_dummies())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframedrop_duplicates"><a class="header" href="#polarsinternalsframedataframedrop_duplicates"><code>polars.internals.frame.DataFrame.drop_duplicates</code></a></h3>
<pre><code class="language-python">drop_duplicates(maintain_order: bool, 
    subset: OptionalUnion[str, tp.List[str]],) -&gt; DataFrame:
</code></pre>
<p>Drop duplicate rows from this DataFrame.
Note that this fails if there is a column of type <code>List</code> in the DataFrame.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_duplicates(
        self,
        maintain_order: bool = True,
        subset: Optional[Union[str, tp.List[str]]] = None,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Drop duplicate rows from this DataFrame.
        Note that this fails if there is a column of type `List` in the DataFrame.
        &quot;&quot;&quot;
        if subset is not None and not isinstance(subset, list):
            subset = [subset]
        return wrap_df(self._df.drop_duplicates(maintain_order, subset))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerechunk"><a class="header" href="#polarsinternalsframedataframerechunk"><code>polars.internals.frame.DataFrame.rechunk</code></a></h3>
<pre><code class="language-python">rechunk() -&gt; DataFrame:
</code></pre>
<p>Rechunk the data in this DataFrame to a contiguous allocation.</p>
<p>This will make sure all subsequent operations have optimal and predictable performance.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rechunk(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Rechunk the data in this DataFrame to a contiguous allocation.

        This will make sure all subsequent operations have optimal and predictable performance.
        &quot;&quot;&quot;
        return wrap_df(self._df.rechunk())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframenull_count"><a class="header" href="#polarsinternalsframedataframenull_count"><code>polars.internals.frame.DataFrame.null_count</code></a></h3>
<pre><code class="language-python">null_count() -&gt; DataFrame:
</code></pre>
<p>Create a new DataFrame that shows the null counts per column.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, None, 3],
&quot;bar&quot;: [6, 7, None],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.null_count()
shape: (1, 3)
┌─────┬─────┬─────┐
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ u32 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 0   │
└─────┴─────┴─────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def null_count(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Create a new DataFrame that shows the null counts per column.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, None, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, None],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.null_count()
        shape: (1, 3)
        ┌─────┬─────┬─────┐
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ u32 ┆ u32 ┆ u32 │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 1   ┆ 0   │
        └─────┴─────┴─────┘

        &quot;&quot;&quot;
        return wrap_df(self._df.null_count())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframesample"><a class="header" href="#polarsinternalsframedataframesample"><code>polars.internals.frame.DataFrame.sample</code></a></h3>
<pre><code class="language-python">sample(n: Optionalint, 
    frac: Optionalfloat, 
    with_replacement: bool,) -&gt; DataFrame:
</code></pre>
<p>Sample from this DataFrame by setting either <code>n</code> or <code>frac</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: Number of samples &lt; self.len() .</li>
<li>[<code>frac</code>]: Fraction between 0.0 and 1.0 .</li>
<li>[<code>with_replacement</code>]: Sample with replacement.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.sample(n=2)
shape: (2, 3)
╭─────┬─────┬─────╮
│ foo ┆ bar ┆ ham │
│ --- ┆ --- ┆ --- │
│ i64 ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ 1   ┆ 6   ┆ &quot;a&quot; │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ 8   ┆ &quot;c&quot; │
╰─────┴─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sample(
        self,
        n: Optional[int] = None,
        frac: Optional[float] = None,
        with_replacement: bool = False,
    ) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Sample from this DataFrame by setting either `n` or `frac`.

        Parameters
        ----------
        n
            Number of samples &lt; self.len() .
        frac
            Fraction between 0.0 and 1.0 .
        with_replacement
            Sample with replacement.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.sample(n=2)
        shape: (2, 3)
        ╭─────┬─────┬─────╮
        │ foo ┆ bar ┆ ham │
        │ --- ┆ --- ┆ --- │
        │ i64 ┆ i64 ┆ str │
        ╞═════╪═════╪═════╡
        │ 1   ┆ 6   ┆ &quot;a&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
        │ 3   ┆ 8   ┆ &quot;c&quot; │
        ╰─────┴─────┴─────╯

        &quot;&quot;&quot;
        if n is not None:
            return wrap_df(self._df.sample_n(n, with_replacement))
        return wrap_df(self._df.sample_frac(frac, with_replacement))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframefold"><a class="header" href="#polarsinternalsframedataframefold"><code>polars.internals.frame.DataFrame.fold</code></a></h3>
<pre><code class="language-python">fold(operation: Callable[[pli.Series, pli.Series], pli.Series],) -&gt; pli.Series:
</code></pre>
<p>Apply a horizontal reduction on a DataFrame. This can be used to effectively
determine aggregations on a row level, and can be applied to any DataType that
can be supercasted (casted to a similar parent type).</p>
<p>An example of the supercast rules when applying an arithmetic operation on two DataTypes are for instance:</p>
<p>Int8 + Utf8 = Utf8
Float32 + Int64 = Float32
Float32 + Float64 = Float64</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<h1 id="a-horizontal-sum-operation"><a class="header" href="#a-horizontal-sum-operation">A horizontal sum operation</a></h1>
<p>df = pl.DataFrame(
{&quot;a&quot;: [2, 1, 3],
&quot;b&quot;: [1, 2, 3],
&quot;c&quot;: [1.0, 2.0, 3.0]
})
df.fold(lambda s1, s2: s1 + s2)
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>9
]</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<h1 id="a-horizontal-minimum-operation"><a class="header" href="#a-horizontal-minimum-operation">A horizontal minimum operation</a></h1>
<p>df = pl.DataFrame(
{&quot;a&quot;: [2, 1, 3],
&quot;b&quot;: [1, 2, 3],
&quot;c&quot;: [1.0, 2.0, 3.0]
})
df.fold(lambda s1, s2: s1.zip_with(s1 &lt; s2, s2))
Series: 'a' [f64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>3
]</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<h1 id="a-horizontal-string-concattenation"><a class="header" href="#a-horizontal-string-concattenation">A horizontal string concattenation</a></h1>
<p>df = pl.DataFrame(
{&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, 2],
&quot;b&quot;: [1, 2, 3],
&quot;c&quot;: [1.0, 2.0, 3.0]
})
df.fold(lambda s1, s2: s1 + s2)
Series: '' [f64]
[
&quot;foo11&quot;
&quot;bar22
&quot;233&quot;
]</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>operation</code>]: function that takes two <code>Series</code> and returns a <code>Series</code>.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fold(
        self, operation: Callable[[&quot;pli.Series&quot;, &quot;pli.Series&quot;], &quot;pli.Series&quot;]
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Apply a horizontal reduction on a DataFrame. This can be used to effectively
        determine aggregations on a row level, and can be applied to any DataType that
        can be supercasted (casted to a similar parent type).

        An example of the supercast rules when applying an arithmetic operation on two DataTypes are for instance:

        Int8 + Utf8 = Utf8
        Float32 + Int64 = Float32
        Float32 + Float64 = Float64

        Examples
        --------
        &gt;&gt;&gt; # A horizontal sum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: 'a' [f64]
        [
            4
            5
            9
        ]

        &gt;&gt;&gt; # A horizontal minimum operation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [2, 1, 3],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1.zip_with(s1 &lt; s2, s2))
        Series: 'a' [f64]
        [
            1
            1
            3
        ]

        &gt;&gt;&gt; # A horizontal string concattenation
        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;    {&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, 2],
        &gt;&gt;&gt;    &quot;b&quot;: [1, 2, 3],
        &gt;&gt;&gt;    &quot;c&quot;: [1.0, 2.0, 3.0]
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.fold(lambda s1, s2: s1 + s2)
        Series: '' [f64]
        [
            &quot;foo11&quot;
            &quot;bar22
            &quot;233&quot;
        ]

        Parameters
        ----------
        operation
            function that takes two `Series` and returns a `Series`.

        &quot;&quot;&quot;
        if self.width == 1:
            return self.to_series(0)
        df = self
        acc = operation(df.to_series(0), df.to_series(1))

        for i in range(2, df.width):
            acc = operation(acc, df.to_series(i))
        return acc
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerow"><a class="header" href="#polarsinternalsframedataframerow"><code>polars.internals.frame.DataFrame.row</code></a></h3>
<pre><code class="language-python">row(index: int) -&gt; TupleAny:
</code></pre>
<p>Get a row as tuple.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: Row index.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.row(2)
(3, 8, 'c')</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def row(self, index: int) -&gt; Tuple[Any]:
        &quot;&quot;&quot;
        Get a row as tuple.

        Parameters
        ----------
        index
            Row index.

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.row(2)
        (3, 8, 'c')

        &quot;&quot;&quot;
        return self._df.row_tuple(index)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframerows"><a class="header" href="#polarsinternalsframedataframerows"><code>polars.internals.frame.DataFrame.rows</code></a></h3>
<pre><code class="language-python">rows() -&gt; tp.List[Tuple]:
</code></pre>
<p>Convert columnar data to rows as python tuples.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rows(self) -&gt; tp.List[Tuple]:
        &quot;&quot;&quot;
        Convert columnar data to rows as python tuples.
        &quot;&quot;&quot;
        return self._df.row_tuples()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeshrink_to_fit"><a class="header" href="#polarsinternalsframedataframeshrink_to_fit"><code>polars.internals.frame.DataFrame.shrink_to_fit</code></a></h3>
<pre><code class="language-python">shrink_to_fit(in_place: bool) -&gt; OptionalDataFrame:
</code></pre>
<p>Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shrink_to_fit(self, in_place: bool = False) -&gt; Optional[&quot;DataFrame&quot;]:
        &quot;&quot;&quot;
        Shrink memory usage of this DataFrame to fit the exact capacity needed to hold the data.
        &quot;&quot;&quot;
        if in_place:
            self._df.shrink_to_fit()
            return None
        else:
            df = self.clone()
            df._df.shrink_to_fit()
            return df
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframehash_rows"><a class="header" href="#polarsinternalsframedataframehash_rows"><code>polars.internals.frame.DataFrame.hash_rows</code></a></h3>
<pre><code class="language-python">hash_rows(k0: int, 
    k1: int, 
    k2: int, 
    k3: int,) -&gt; pli.Series:
</code></pre>
<p>Hash and combine the rows in this DataFrame.</p>
<p>Hash value is UInt64</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;foo&quot;: [1, 2, 3],
&quot;bar&quot;: [6, 7, 8],
&quot;ham&quot;: ['a', 'b', 'c']
})
df.hash(k0=42)
shape: (3,)
Series: '' [u64]
[</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>
<pre><code>  18282897888575762835
</code></pre>
</li>
</ul>
<p>]</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash_rows(
        self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3
    ) -&gt; &quot;pli.Series&quot;:
        &quot;&quot;&quot;
        Hash and combine the rows in this DataFrame.

        Hash value is UInt64

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter

        Examples
        --------
        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;foo&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;bar&quot;: [6, 7, 8],
        &gt;&gt;&gt;     &quot;ham&quot;: ['a', 'b', 'c']
        &gt;&gt;&gt;     })
        &gt;&gt;&gt; df.hash(k0=42)
        shape: (3,)
        Series: '' [u64]
        [
                1208206736888326229
                8040480609798856146
                18282897888575762835
        ]
        &quot;&quot;&quot;
        return pli.wrap_s(self._df.hash_rows(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeinterpolate"><a class="header" href="#polarsinternalsframedataframeinterpolate"><code>polars.internals.frame.DataFrame.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; DataFrame:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;DataFrame&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return self.select(pli.col(&quot;*&quot;).interpolate())  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsframedataframeis_empty"><a class="header" href="#polarsinternalsframedataframeis_empty"><code>polars.internals.frame.DataFrame.is_empty</code></a></h3>
<pre><code class="language-python">is_empty() -&gt; bool:
</code></pre>
<p>Check if the dataframe is empty</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_empty(self) -&gt; bool:
        &quot;&quot;&quot;
        Check if the dataframe is empty
        &quot;&quot;&quot;
        return self.height == 0
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../polars/internals/frame.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../../polars/internals/frame/GroupBy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../polars/internals/frame.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../../polars/internals/frame/GroupBy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../../theme/js/index.js"></script>
        

        

    </body>
</html>
