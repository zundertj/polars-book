<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Expr - Polars - Python Reference Guide</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../../../favicon.svg">
        
        
        <link rel="shortcut icon" href="../../../favicon.png">
        
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        
        <link rel="stylesheet" href="../../../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../../../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../../../theme/css/style.css">
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../../polars.html">polars</a></li><li class="chapter-item "><a href="../../../polars/cfg.html">cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/cfg/Config.html">Config</a></li></ol></li><li class="chapter-item "><a href="../../../polars/convert.html">convert</a></li><li class="chapter-item "><a href="../../../polars/datatypes.html">datatypes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/datatypes/DataType.html">DataType</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int8.html">Int8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int16.html">Int16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int32.html">Int32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Int64.html">Int64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt8.html">UInt8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt16.html">UInt16</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt32.html">UInt32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/UInt64.html">UInt64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float32.html">Float32</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Float64.html">Float64</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Boolean.html">Boolean</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Utf8.html">Utf8</a></li><li class="chapter-item "><a href="../../../polars/datatypes/List.html">List</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Date.html">Date</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Datetime.html">Datetime</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Time.html">Time</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Object.html">Object</a></li><li class="chapter-item "><a href="../../../polars/datatypes/Categorical.html">Categorical</a></li></ol></li><li class="chapter-item "><a href="../../../polars/datatypes_constructor.html">datatypes_constructor</a></li><li class="chapter-item expanded "><a href="../../../polars/internals.html">internals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/construction.html">construction</a></li><li class="chapter-item expanded "><a href="../../../polars/internals/expr.html">expr</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../polars/internals/expr/Expr.html" class="active">Expr</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprListNameSpace.html">ExprListNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprStringNameSpace.html">ExprStringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/expr/ExprDateTimeNameSpace.html">ExprDateTimeNameSpace</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/frame.html">frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/frame/DataFrame.html">DataFrame</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/GroupBy.html">GroupBy</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/PivotOps.html">PivotOps</a></li><li class="chapter-item "><a href="../../../polars/internals/frame/GBSelection.html">GBSelection</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/functions.html">functions</a></li><li class="chapter-item "><a href="../../../polars/internals/lazy_frame.html">lazy_frame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/lazy_frame/LazyFrame.html">LazyFrame</a></li><li class="chapter-item "><a href="../../../polars/internals/lazy_frame/LazyGroupBy.html">LazyGroupBy</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/lazy_functions.html">lazy_functions</a></li><li class="chapter-item "><a href="../../../polars/internals/series.html">series</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/series/Series.html">Series</a></li><li class="chapter-item "><a href="../../../polars/internals/series/StringNameSpace.html">StringNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/ListNameSpace.html">ListNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/DateTimeNameSpace.html">DateTimeNameSpace</a></li><li class="chapter-item "><a href="../../../polars/internals/series/SeriesIter.html">SeriesIter</a></li></ol></li><li class="chapter-item "><a href="../../../polars/internals/whenthen.html">whenthen</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/internals/whenthen/WhenThenThen.html">WhenThenThen</a></li><li class="chapter-item "><a href="../../../polars/internals/whenthen/WhenThen.html">WhenThen</a></li><li class="chapter-item "><a href="../../../polars/internals/whenthen/When.html">When</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../../polars/io.html">io</a></li><li class="chapter-item "><a href="../../../polars/string_cache.html">string_cache</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../../polars/string_cache/StringCache.html">StringCache</a></li></ol></li><li class="chapter-item "><a href="../../../polars/testing.html">testing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - Python Reference Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="polarsinternalsexprexpr"><a class="header" href="#polarsinternalsexprexpr"><code>polars.internals.expr.Expr</code></a></h1>
<p>Expressions that can be used in various contexts.</p>
<p><strong>Methods:</strong></p>
<ul>
<li><a href="#polarsinternalsexprexpreq"><code>eq()</code></a>: </li>
<li><a href="#polarsinternalsexprexprneq"><code>neq()</code></a>: </li>
<li><a href="#polarsinternalsexprexprgt"><code>gt()</code></a>: </li>
<li><a href="#polarsinternalsexprexprgt_eq"><code>gt_eq()</code></a>: </li>
<li><a href="#polarsinternalsexprexprlt_eq"><code>lt_eq()</code></a>: </li>
<li><a href="#polarsinternalsexprexprlt"><code>lt()</code></a>: </li>
<li><a href="#polarsinternalsexprexpr__array_ufunc__function"><code>function()</code></a>: </li>
<li><a href="#polarsinternalsexprexprsqrt"><code>sqrt()</code></a>: Compute the square root of the elements</li>
<li><a href="#polarsinternalsexprexpralias"><code>alias()</code></a>: Rename the output of an expression.</li>
<li><a href="#polarsinternalsexprexprexclude"><code>exclude()</code></a>: Exclude certain columns from a wildcard/regex selection.</li>
<li><a href="#polarsinternalsexprexprkeep_name"><code>keep_name()</code></a>: Keep the original root name of the expression.</li>
<li><a href="#polarsinternalsexprexprprefix"><code>prefix()</code></a>: Add a prefix the to root column name of the expression.</li>
<li><a href="#polarsinternalsexprexprsuffix"><code>suffix()</code></a>: Add a suffix the to root column name of the expression.</li>
<li><a href="#polarsinternalsexprexpris_not"><code>is_not()</code></a>: Negate a boolean expression.</li>
<li><a href="#polarsinternalsexprexpris_null"><code>is_null()</code></a>: Create a boolean expression returning <code>True</code> where the expression contains null values.</li>
<li><a href="#polarsinternalsexprexpris_not_null"><code>is_not_null()</code></a>: Create a boolean expression returning <code>True</code> where the expression does not contain null values.</li>
<li><a href="#polarsinternalsexprexpris_finite"><code>is_finite()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are finite.</li>
<li><a href="#polarsinternalsexprexpris_infinite"><code>is_infinite()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are infinite.</li>
<li><a href="#polarsinternalsexprexpris_nan"><code>is_nan()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are NaN (Not A Number).</li>
<li><a href="#polarsinternalsexprexpris_not_nan"><code>is_not_nan()</code></a>: Create a boolean expression returning <code>True</code> where the expression values are not NaN (Not A Number).</li>
<li><a href="#polarsinternalsexprexpragg_groups"><code>agg_groups()</code></a>: Get the group indexes of the group by operation.</li>
<li><a href="#polarsinternalsexprexprcount"><code>count()</code></a>: Count the number of values in this expression</li>
<li><a href="#polarsinternalsexprexprlen"><code>len()</code></a>: Alias for count</li>
<li><a href="#polarsinternalsexprexprslice"><code>slice()</code></a>: Slice the Series.</li>
<li><a href="#polarsinternalsexprexprdrop_nulls"><code>drop_nulls()</code></a>: Syntactic sugar for:</li>
<li><a href="#polarsinternalsexprexprcumsum"><code>cumsum()</code></a>: Get an array with the cumulative sum computed at every element.</li>
<li><a href="#polarsinternalsexprexprcumprod"><code>cumprod()</code></a>: Get an array with the cumulative product computed at every element.</li>
<li><a href="#polarsinternalsexprexprcummin"><code>cummin()</code></a>: Get an array with the cumulative min computed at every element.</li>
<li><a href="#polarsinternalsexprexprcummax"><code>cummax()</code></a>: Get an array with the cumulative max computed at every element.</li>
<li><a href="#polarsinternalsexprexprfloor"><code>floor()</code></a>: Floor underlying floating point array to the lowest integers smaller or equal to the float value.</li>
<li><a href="#polarsinternalsexprexprround"><code>round()</code></a>: Round underlying floating point data by <code>decimals</code> digits.</li>
<li><a href="#polarsinternalsexprexprdot"><code>dot()</code></a>: Compute the dot/inner product between two Expressions</li>
<li><a href="#polarsinternalsexprexprmode"><code>mode()</code></a>: Compute the most occurring value(s). Can return multiple Values</li>
<li><a href="#polarsinternalsexprexprcast"><code>cast()</code></a>: Cast between data types.</li>
<li><a href="#polarsinternalsexprexprsort"><code>sort()</code></a>: Sort this column. In projection/ selection context the whole column is sorted.</li>
<li><a href="#polarsinternalsexprexprarg_sort"><code>arg_sort()</code></a>: Get the index values that would sort this column.</li>
<li><a href="#polarsinternalsexprexprarg_max"><code>arg_max()</code></a>: Get the index of the maximal value.</li>
<li><a href="#polarsinternalsexprexprarg_min"><code>arg_min()</code></a>: Get the index of the minimal value.</li>
<li><a href="#polarsinternalsexprexprsort_by"><code>sort_by()</code></a>: Sort this column by the ordering of another column, or multiple other columns.</li>
<li><a href="#polarsinternalsexprexprtake"><code>take()</code></a>: Take values by index.</li>
<li><a href="#polarsinternalsexprexprshift"><code>shift()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="#polarsinternalsexprexprshift_and_fill"><code>shift_and_fill()</code></a>: Shift the values by a given period and fill the parts that will be empty due to this operation</li>
<li><a href="#polarsinternalsexprexprfill_null"><code>fill_null()</code></a>: Fill none value with a fill value or strategy</li>
<li><a href="#polarsinternalsexprexprfill_nan"><code>fill_nan()</code></a>: Fill none value with a fill value</li>
<li><a href="#polarsinternalsexprexprforward_fill"><code>forward_fill()</code></a>: Fill missing values with the latest seen values</li>
<li><a href="#polarsinternalsexprexprbackward_fill"><code>backward_fill()</code></a>: Fill missing values with the next to be seen values</li>
<li><a href="#polarsinternalsexprexprreverse"><code>reverse()</code></a>: Reverse the selection.</li>
<li><a href="#polarsinternalsexprexprstd"><code>std()</code></a>: Get standard deviation.</li>
<li><a href="#polarsinternalsexprexprvar"><code>var()</code></a>: Get variance.</li>
<li><a href="#polarsinternalsexprexprmax"><code>max()</code></a>: Get maximum value.</li>
<li><a href="#polarsinternalsexprexprmin"><code>min()</code></a>: Get minimum value.</li>
<li><a href="#polarsinternalsexprexprsum"><code>sum()</code></a>: Get sum value.</li>
<li><a href="#polarsinternalsexprexprmean"><code>mean()</code></a>: Get mean value.</li>
<li><a href="#polarsinternalsexprexprmedian"><code>median()</code></a>: Get median value.</li>
<li><a href="#polarsinternalsexprexprn_unique"><code>n_unique()</code></a>: Count unique values.</li>
<li><a href="#polarsinternalsexprexprarg_unique"><code>arg_unique()</code></a>: Get index of first unique value.</li>
<li><a href="#polarsinternalsexprexprunique"><code>unique()</code></a>: Get unique values.</li>
<li><a href="#polarsinternalsexprexprfirst"><code>first()</code></a>: Get the first value.</li>
<li><a href="#polarsinternalsexprexprlast"><code>last()</code></a>: Get the last value.</li>
<li><a href="#polarsinternalsexprexprlist"><code>list()</code></a>: Aggregate to list.</li>
<li><a href="#polarsinternalsexprexprover"><code>over()</code></a>: Apply window function over a subgroup.</li>
<li><a href="#polarsinternalsexprexpris_unique"><code>is_unique()</code></a>: Get mask of unique values.</li>
<li><a href="#polarsinternalsexprexpris_first"><code>is_first()</code></a>: Get a mask of the first unique value.</li>
<li><a href="#polarsinternalsexprexpris_duplicated"><code>is_duplicated()</code></a>: Get mask of duplicated values.</li>
<li><a href="#polarsinternalsexprexprquantile"><code>quantile()</code></a>: Get quantile value.</li>
<li><a href="#polarsinternalsexprexprfilter"><code>filter()</code></a>: Filter a single column.</li>
<li><a href="#polarsinternalsexprexprwhere"><code>where()</code></a>: Alias for filter</li>
<li><a href="#polarsinternalsexprexprmap"><code>map()</code></a>: Apply a custom python function. This function must produce a <code>Series</code>. Any other value will be stored as</li>
<li><a href="#polarsinternalsexprexprapply"><code>apply()</code></a>: Apply a custom function in a GroupBy or Projection context.</li>
<li><a href="#polarsinternalsexprexprapplywrap_f"><code>wrap_f()</code></a>: </li>
<li><a href="#polarsinternalsexprexprflatten"><code>flatten()</code></a>: Alias for explode.</li>
<li><a href="#polarsinternalsexprexprexplode"><code>explode()</code></a>: Explode a list or utf8 Series. This means that every item is expanded to a new row.</li>
<li><a href="#polarsinternalsexprexprtake_every"><code>take_every()</code></a>: Take every nth value in the Series and return as a new Series.</li>
<li><a href="#polarsinternalsexprexprhead"><code>head()</code></a>: Take the first n values.</li>
<li><a href="#polarsinternalsexprexprtail"><code>tail()</code></a>: Take the last n values.</li>
<li><a href="#polarsinternalsexprexprpow"><code>pow()</code></a>: Raise expression to the power of exponent.</li>
<li><a href="#polarsinternalsexprexpris_in"><code>is_in()</code></a>: Check if elements of this Series are in the right Series, or List values of the right Series.</li>
<li><a href="#polarsinternalsexprexprrepeat_by"><code>repeat_by()</code></a>: Repeat the elements in this Series <code>n</code> times by dictated by the number given by <code>by</code>.</li>
<li><a href="#polarsinternalsexprexpris_between"><code>is_between()</code></a>: Check if this expression is between start and end.</li>
<li><a href="#polarsinternalsexprexprdt"><code>dt()</code></a>: Create an object namespace of all datetime related methods.</li>
<li><a href="#polarsinternalsexprexprstr"><code>str()</code></a>: Create an object namespace of all string related methods.</li>
<li><a href="#polarsinternalsexprexprarr"><code>arr()</code></a>: Create an object namespace of all datetime related methods.</li>
<li><a href="#polarsinternalsexprexprhash"><code>hash()</code></a>: Hash the Series.</li>
<li><a href="#polarsinternalsexprexprreinterpret"><code>reinterpret()</code></a>: Reinterpret the underlying bits as a signed/unsigned integer.</li>
<li><a href="#polarsinternalsexprexprinspect"><code>inspect()</code></a>: Prints the value that this expression evaluates to and passes on the value.</li>
<li><a href="#polarsinternalsexprexprinspectinspect"><code>inspect()</code></a>: </li>
<li><a href="#polarsinternalsexprexprinterpolate"><code>interpolate()</code></a>: Interpolate intermediate values. The interpolation method is linear.</li>
<li><a href="#polarsinternalsexprexprrolling_min"><code>rolling_min()</code></a>: apply a rolling min (moving min) over the values in this array.</li>
<li><a href="#polarsinternalsexprexprrolling_max"><code>rolling_max()</code></a>: Apply a rolling max (moving max) over the values in this array.</li>
<li><a href="#polarsinternalsexprexprrolling_mean"><code>rolling_mean()</code></a>: Apply a rolling mean (moving mean) over the values in this array.</li>
<li><a href="#polarsinternalsexprexprrolling_sum"><code>rolling_sum()</code></a>: Apply a rolling sum (moving sum) over the values in this array.</li>
<li><a href="#polarsinternalsexprexprrolling_std"><code>rolling_std()</code></a>: Compute a rolling std dev</li>
<li><a href="#polarsinternalsexprexprrolling_var"><code>rolling_var()</code></a>: Compute a rolling variance.</li>
<li><a href="#polarsinternalsexprexprrolling_apply"><code>rolling_apply()</code></a>: Allows a custom rolling window function.</li>
<li><a href="#polarsinternalsexprexprrolling_median"><code>rolling_median()</code></a>: Compute a rolling median</li>
<li><a href="#polarsinternalsexprexprrolling_quantile"><code>rolling_quantile()</code></a>: Compute a rolling quantile</li>
<li><a href="#polarsinternalsexprexprrolling_skew"><code>rolling_skew()</code></a>: Compute a rolling skew</li>
<li><a href="#polarsinternalsexprexprabs"><code>abs()</code></a>: Take absolute values</li>
<li><a href="#polarsinternalsexprexprargsort"><code>argsort()</code></a>: Index location of the sorted variant of this Series.</li>
<li><a href="#polarsinternalsexprexprrank"><code>rank()</code></a>: Assign ranks to data, dealing with ties appropriately.</li>
<li><a href="#polarsinternalsexprexprdiff"><code>diff()</code></a>: Calculate the n-th discrete difference.</li>
<li><a href="#polarsinternalsexprexprskew"><code>skew()</code></a>: Compute the sample skewness of a data set.</li>
<li><a href="#polarsinternalsexprexprkurtosis"><code>kurtosis()</code></a>: Compute the kurtosis (Fisher or Pearson) of a dataset.</li>
<li><a href="#polarsinternalsexprexprclip"><code>clip()</code></a>: Clip (limit) the values in an array.</li>
<li><a href="#polarsinternalsexprexprlower_bound"><code>lower_bound()</code></a>: Returns a unit Series with the lowest value possible for the dtype of this expression.</li>
<li><a href="#polarsinternalsexprexprupper_bound"><code>upper_bound()</code></a>: Returns a unit Series with the highest value possible for the dtype of this expression.</li>
<li><a href="#polarsinternalsexprexprstr_concat"><code>str_concat()</code></a>: Vertically concat the values in the Series to a single string value.</li>
<li><a href="#polarsinternalsexprexprsin"><code>sin()</code></a>: Compute the element-wise value for Trigonometric sine on an array</li>
<li><a href="#polarsinternalsexprexprcos"><code>cos()</code></a>: Compute the element-wise value for Trigonometric cosine on an array</li>
<li><a href="#polarsinternalsexprexprtan"><code>tan()</code></a>: Compute the element-wise value for Trigonometric tangent on an array</li>
<li><a href="#polarsinternalsexprexprarcsin"><code>arcsin()</code></a>: Compute the element-wise value for Trigonometric sine on an array</li>
<li><a href="#polarsinternalsexprexprarccos"><code>arccos()</code></a>: Compute the element-wise value for Trigonometric cosine on an array</li>
<li><a href="#polarsinternalsexprexprarctan"><code>arctan()</code></a>: Compute the element-wise value for Trigonometric tangent on an array</li>
<li><a href="#polarsinternalsexprexprreshape"><code>reshape()</code></a>: Reshape this Expr to a flat series, shape: (len,)</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">class Expr:
    &quot;&quot;&quot;
    Expressions that can be used in various contexts.
    &quot;&quot;&quot;

    def __init__(self) -&gt; None:
        self._pyexpr: PyExpr

    @staticmethod
    def _from_pyexpr(pyexpr: &quot;PyExpr&quot;) -&gt; &quot;Expr&quot;:
        self = Expr.__new__(Expr)
        self._pyexpr = pyexpr
        return self

    def __to_pyexpr(self, other: Any) -&gt; &quot;PyExpr&quot;:
        return self.__to_expr(other)._pyexpr

    def __to_expr(self, other: Any) -&gt; &quot;Expr&quot;:
        if isinstance(other, Expr):
            return other
        return pli.lit(other)

    def __bool__(self) -&gt; &quot;Expr&quot;:
        raise ValueError(
            &quot;Since Expr are lazy, the truthiness of an Expr is ambiguous. \
            Hint: use '&amp;' or '|' to chain Expr together, not and/or.&quot;
        )

    def __invert__(self) -&gt; &quot;Expr&quot;:
        return self.is_not()

    def __xor__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._xor(self.__to_pyexpr(other)))

    def __rxor__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._xor(self.__to_pyexpr(other)))

    def __and__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._and(self.__to_pyexpr(other)))

    def __rand__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._and(self.__to_pyexpr(other)))

    def __or__(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr._or(self.__to_pyexpr(other)))

    def __ror__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other)._or(self._pyexpr))

    def __add__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr + self.__to_pyexpr(other))

    def __radd__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) + self._pyexpr)

    def __sub__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr - self.__to_pyexpr(other))

    def __rsub__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) - self._pyexpr)

    def __mul__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr * self.__to_pyexpr(other))

    def __rmul__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) * self._pyexpr)

    def __truediv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr / self.__to_pyexpr(other))

    def __rtruediv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) / self._pyexpr)

    def __floordiv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr // self.__to_pyexpr(other))

    def __rfloordiv__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) // self._pyexpr)

    def __mod__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr % self.__to_pyexpr(other))

    def __rmod__(self, other: Any) -&gt; &quot;Expr&quot;:
        return wrap_expr(self.__to_pyexpr(other) % self._pyexpr)

    def __pow__(self, power: float, modulo: None = None) -&gt; &quot;Expr&quot;:
        return self.pow(power)

    def __ge__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.gt_eq(self.__to_expr(other))

    def __le__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.lt_eq(self.__to_expr(other))

    def __eq__(self, other: Any) -&gt; &quot;Expr&quot;:  # type: ignore[override]
        return self.eq(self.__to_expr(other))

    def __ne__(self, other: Any) -&gt; &quot;Expr&quot;:  # type: ignore[override]
        return self.neq(self.__to_expr(other))

    def __lt__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.lt(self.__to_expr(other))

    def __gt__(self, other: Any) -&gt; &quot;Expr&quot;:
        return self.gt(self.__to_expr(other))

    def eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.eq(other._pyexpr))

    def neq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.neq(other._pyexpr))

    def gt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt(other._pyexpr))

    def gt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt_eq(other._pyexpr))

    def lt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt_eq(other._pyexpr))

    def lt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt(other._pyexpr))

    def __neg__(self) -&gt; &quot;Expr&quot;:
        return pli.lit(0) - self  # type: ignore

    def __array_ufunc__(
        self, ufunc: Callable[..., Any], method: str, *inputs: Any, **kwargs: Any
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Numpy universal functions.
        &quot;&quot;&quot;
        out_type = ufunc(np.array([1])).dtype
        if &quot;float&quot; in str(out_type):
            dtype = Float64  # type: ignore
        else:
            dtype = None  # type: ignore

        args = [inp for inp in inputs if not isinstance(inp, Expr)]

        def function(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return ufunc(s, *args, **kwargs)  # pragma: no cover

        if &quot;dtype&quot; in kwargs:
            dtype = kwargs[&quot;dtype&quot;]

        return self.map(function, return_dtype=dtype)

    def sqrt(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements
        &quot;&quot;&quot;
        return self ** 0.5

    def alias(self, name: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Rename the output of an expression.

        Parameters
        ----------
        name
            New name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (3, 2)
        ╭─────┬──────╮
        │ a   ┆ b    │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     col(&quot;a&quot;).alias(&quot;bar&quot;),
        &gt;&gt;&gt;     col(&quot;b&quot;).alias(&quot;foo&quot;)
        &gt;&gt;&gt; ])
        shape: (3, 2)
        ╭─────┬──────╮
        │ bar ┆ foo  │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.alias(name))

    def exclude(self, columns: Union[str, tp.List[str]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
         Exclude certain columns from a wildcard/regex selection.

         You may also use regexes int he exclude list. They must start with `^` and end with `$`.

         Parameters
         ----------
         columns
             Column(s) to exclude from selection

         Examples
         --------

         &gt;&gt;&gt; df = pl.DataFrame({
         &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
         &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
         &gt;&gt;&gt;     &quot;c&quot;: [None, 2, 1]
         &gt;&gt;&gt; })
         &gt;&gt;&gt; df
         shape: (3, 3)
         ╭─────┬──────┬──────╮
         │ a   ┆ b    ┆ c    │
         │ --- ┆ ---  ┆ ---  │
         │ i64 ┆ str  ┆ i64  │
         ╞═════╪══════╪══════╡
         │ 1   ┆ &quot;a&quot;  ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ &quot;b&quot;  ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ null ┆ 1    │
         ╰─────┴──────┴──────╯
         &gt;&gt;&gt; df.select(col(&quot;*&quot;).exclude(&quot;b&quot;))
        shape: (3, 2)
         ╭─────┬──────╮
         │ a   ┆ c    │
         │ --- ┆ ---  │
         │ i64 ┆ i64  │
         ╞═════╪══════╡
         │ 1   ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ 1    │
         ╰─────┴──────╯
        &quot;&quot;&quot;
        if isinstance(columns, str):
            columns = [columns]
        return wrap_expr(self._pyexpr.exclude(columns))

    def keep_name(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Keep the original root name of the expression.

        Examples
        --------

        A groupby aggregation often changes the name of a column.
        With `keep_name` we can keep the original name of the column

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt; &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt; &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b_agg_list │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯
        &gt;&gt;&gt; # keep the original column name
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list().keep_name())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b          │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯

        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.keep_name())

    def prefix(self, prefix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a prefix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().suffix(&quot;_reverse&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ A_reverse ┆ fruits_reverse ┆ B_reverse ┆ cars_reverse │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.prefix(prefix))

    def suffix(self, suffix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a suffix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().prefix(&quot;reverse_&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ reverse_A ┆ reverse_fruits ┆ reverse_B ┆ reverse_cars │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.suffix(suffix))

    def is_not(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Negate a boolean expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [True, False, False],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
        &gt;&gt;&gt; })
        shape: (3, 2)
        ╭───────┬──────╮
        │ a     ┆ b    │
        │ ---   ┆ ---  │
        │ bool  ┆ str  │
        ╞═══════╪══════╡
        │ true  ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ null │
        ╰───────┴──────╯
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).is_not())
        shape: (3, 1)
        ╭───────╮
        │ a     │
        │ ---   │
        │ bool  │
        ╞═══════╡
        │ false │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ╰───────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not())

    def is_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression contains null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_null())

    def is_not_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression does not contain null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_null())

    def is_finite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are finite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_finite())

    def is_infinite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are infinite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_infinite())

    def is_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_nan())

    def is_not_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are not NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_nan())

    def agg_groups(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the group indexes of the group by operation.
        Should be used in aggregation context only.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.agg_groups())

    def count(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count the number of values in this expression&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.count())

    def len(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for count
        Count the number of values in this expression
        &quot;&quot;&quot;
        return self.count()

    def slice(self, offset: int, length: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Slice the Series.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.slice(offset, length))

    def drop_nulls(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Syntactic sugar for:

        &gt;&gt;&gt; pl.col(&quot;foo&quot;).filter(pl.col(&quot;foo&quot;).is_not_null())
        &quot;&quot;&quot;
        return self.filter(self.is_not_null())

    def cumsum(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumsum(reverse))

    def cumprod(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumprod(reverse))

    def cummin(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummin(reverse))

    def cummax(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummax(reverse))

    def floor(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.floor())

    def round(self, decimals: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            Number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.round(decimals))

    def dot(self, other: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Expressions

        Parameters
        ----------
        other
            Expression to compute dot product with
        &quot;&quot;&quot;
        other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.dot(other._pyexpr))

    def mode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mode())

    def cast(self, dtype: Type[Any], strict: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow
        &quot;&quot;&quot;
        dtype = py_type_to_dtype(dtype)
        return wrap_expr(self._pyexpr.cast(dtype, strict))

    def sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column. In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sort(reverse))

    def arg_sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index values that would sort this column.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.

        Returns
        -------
        out
            Series of type UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_sort(reverse))

    def arg_max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_max())

    def arg_min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_min())

    def sort_by(
        self,
        by: Union[&quot;Expr&quot;, str, tp.List[Union[&quot;Expr&quot;, str]]],
        reverse: Union[bool, tp.List[bool]] = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column by the ordering of another column, or multiple other columns.
        In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        by
            The column(s) used for sorting.
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        if not isinstance(by, list):
            by = [by]
        if not isinstance(reverse, list):
            reverse = [reverse]
        by = _selection_to_pyexpr_list(by)

        return wrap_expr(self._pyexpr.sort_by(by, reverse))

    def take(
        self, index: Union[tp.List[int], &quot;Expr&quot;, &quot;pli.Series&quot;, np.ndarray]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        index
            An expression that leads to a UInt32 dtyped Series.

        Returns
        -------
        Values taken by index
        &quot;&quot;&quot;
        if isinstance(index, (list, np.ndarray)):
            index = pli.lit(pli.Series(&quot;&quot;, index, dtype=UInt32))  # type: ignore
        elif isinstance(index, pli.Series):
            index = pli.lit(index)  # type: ignore
        else:
            index = pli.expr_to_lit_or_expr(index, str_to_lit=False)  # type: ignore
        return pli.wrap_expr(self._pyexpr.take(index._pyexpr))  # type: ignore

    def shift(self, periods: int = 1) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift(periods))

    def shift_and_fill(self, periods: int, fill_value: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.shift_and_fill(periods, fill_value._pyexpr))

    def fill_null(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value or strategy

        fill_value
            Fill null strategy or a value
                   * &quot;backward&quot;
                   * &quot;forward&quot;
                   * &quot;min&quot;
                   * &quot;max&quot;
                   * &quot;mean&quot;
                   * &quot;one&quot;
                   * &quot;zero&quot;
        &quot;&quot;&quot;
        # we first must check if it is not an expr, as expr does not implement __bool__
        # and thus leads to a value error in the second comparisson.
        if not isinstance(fill_value, Expr) and fill_value in [
            &quot;backward&quot;,
            &quot;forward&quot;,
            &quot;min&quot;,
            &quot;max&quot;,
            &quot;mean&quot;,
            &quot;zero&quot;,
            &quot;one&quot;,
        ]:
            return wrap_expr(self._pyexpr.fill_null_with_strategy(fill_value))

        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_null(fill_value._pyexpr))

    def fill_nan(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_nan(fill_value._pyexpr))

    def forward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the latest seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.forward_fill())

    def backward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the next to be seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.backward_fill())

    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the selection.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reverse())

    def std(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get standard deviation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.std())

    def var(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get variance.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.var())

    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get maximum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.max())

    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get minimum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.min())

    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get sum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sum())

    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mean value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mean())

    def median(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get median value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.median())

    def n_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.n_unique())

    def arg_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get index of first unique value.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_unique())

    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.unique())

    def first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the first value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.first())

    def last(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the last value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.last())

    def list(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Aggregate to list.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.list())

    def over(self, expr: Union[str, &quot;Expr&quot;, tp.List[Union[&quot;Expr&quot;, str]]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply window function over a subgroup.
        This is similar to a groupby + aggregation + self join.
        Or similar to [window functions in Postgres](https://www.postgresql.org/docs/9.1/tutorial-window.html)

        Parameters
        ----------
        expr
            Column(s) to group by.

        Examples
        --------

        &gt;&gt;&gt; df = DataFrame({
        &gt;&gt;&gt;    &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
        &gt;&gt;&gt;    &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
        &gt;&gt;&gt;})
        &gt;&gt;&gt; (df.lazy()
        &gt;&gt;&gt;    .select([
        &gt;&gt;&gt;       pl.col(&quot;groups&quot;)
        &gt;&gt;&gt;       sum(&quot;values&quot;).over(&quot;groups&quot;)
        &gt;&gt;&gt;   ]).collect())
            ╭────────┬────────╮
            │ groups ┆ values │
            │ ---    ┆ ---    │
            │ i32    ┆ i32    │
            ╞════════╪════════╡
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ ...    ┆ ...    │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ╰────────┴────────╯

        &quot;&quot;&quot;

        pyexprs = _selection_to_pyexpr_list(expr)

        return wrap_expr(self._pyexpr.over(pyexprs))

    def is_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of unique values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_unique())

    def is_first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_first())

    def is_duplicated(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of duplicated values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_duplicated())

    def quantile(self, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get quantile value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.quantile(quantile))

    def filter(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Filter a single column.
        Mostly useful in in aggregation context. If you want to filter on a DataFrame level, use `LazyFrame.filter`.

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.filter(predicate._pyexpr))

    def where(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for filter

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return self.filter(predicate)

    def map(
        self,
        f: Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;],
        return_dtype: Optional[Type[DataType]] = None,
        agg_list: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom python function. This function must produce a `Series`. Any other value will be stored as
        null/missing. If you want to apply a function over single values, consider using `apply`.

        [read more in the book](https://pola-rs.github.io/polars-book/user-guide/howcani/apply/udfs.html)

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.
        agg_list

        &quot;&quot;&quot;
        if return_dtype is not None:
            return_dtype = py_type_to_dtype(return_dtype)
        return wrap_expr(self._pyexpr.map(f, return_dtype, agg_list))

    def apply(
        self,
        f: Union[Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;], Callable[[Any], Any]],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom function in a GroupBy or Projection context.

        Depending on the context it has the following behavior:

        ## Context

        * Select/Project
            expected type `f`: Callable[[Any], Any]
            Applies a python function over each individual value in the column.
        * GroupBy
            expected type `f`: Callable[[Series], Series]
            Applies a python function over each group.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
                   &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})
        &gt;&gt;&gt; df
         .lazy()
         .groupby(&quot;b&quot;)
         .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
         .collect()
        )
        shape: (3, 2)
        ╭─────┬─────╮
        │ b   ┆ a   │
        │ --- ┆ --- │
        │ str ┆ i64 │
        ╞═════╪═════╡
        │ a   ┆ 1   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 2   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ c   ┆ 2   │
        ╰─────┴─────╯

        &quot;&quot;&quot;

        # input x: Series of type list containing the group values
        def wrap_f(x: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)

        return self.map(wrap_f, agg_list=True)

    def flatten(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for explode.

        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.explode())

    def explode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.explode())

    def take_every(self, n: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as a new Series.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take_every(n))

    def head(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the first n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.head(n))

    def tail(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the last n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.tail(n))

    def pow(self, exponent: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Raise expression to the power of exponent.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.pow(exponent))

    def is_in(self, other: Union[&quot;Expr&quot;, tp.List[Any]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Parameters
        ----------
        other
            Series of primitive type or List type.

        Returns
        -------
        Expr that evaluates to a Boolean Series.
        &quot;&quot;&quot;
        if isinstance(other, list):
            other = pli.lit(pli.Series(other))
        else:
            other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.is_in(other._pyexpr))

    def repeat_by(self, by: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Repeat the elements in this Series `n` times by dictated by the number given by `by`.
        The elements are expanded into a `List`

        Parameters
        ----------
        by
            Numeric column that determines how often the values will be repeated.
            The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.

        Returns
        -------
        Series of type List
        &quot;&quot;&quot;
        by = expr_to_lit_or_expr(by, False)
        return wrap_expr(self._pyexpr.repeat_by(by._pyexpr))

    def is_between(
        self, start: Union[&quot;Expr&quot;, datetime], end: Union[&quot;Expr&quot;, datetime]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if this expression is between start and end.
        &quot;&quot;&quot;
        cast_to_datetime = False
        if isinstance(start, datetime):
            start = pli.lit(start)
            cast_to_datetime = True
        if isinstance(end, datetime):
            end = pli.lit(end)
            cast_to_datetime = True
        if cast_to_datetime:
            expr = self.cast(Datetime)
        else:
            expr = self
        return ((expr &gt; start) &amp; (expr &lt; end)).alias(&quot;is_between&quot;)

    @property
    def dt(self) -&gt; &quot;ExprDateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprDateTimeNameSpace(self)

    @property
    def str(self) -&gt; &quot;ExprStringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return ExprStringNameSpace(self)

    @property
    def arr(self) -&gt; &quot;ExprListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprListNameSpace(self)

    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `Datetime`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hash(k0, k1, k2, k3))

    def reinterpret(self, signed: bool) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reinterpret(signed))

    def inspect(self, fmt: str = &quot;{}&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Prints the value that this expression evaluates to and passes on the value.

        &gt;&gt;&gt; df.select(pl.col(&quot;foo&quot;).cumsum().inspect(&quot;value is: {}&quot;).alias(&quot;bar&quot;))
        &quot;&quot;&quot;

        def inspect(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            print(fmt.format(s))  # type: ignore
            return s

        return self.map(inspect, return_dtype=None, agg_list=True)

    def interpolate(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.interpolate())

    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_min(window_size, weights, min_periods, center)
        )

    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_max(window_size, weights, min_periods, center)
        )

    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0]
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_mean(window_size=2)
        &gt;&gt;&gt; ])
        shape: (6, 1)
        ┌──────┐
        │ A    │
        │ ---  │
        │ f64  │
        ╞══════╡
        │ null │
        ├╌╌╌╌╌╌┤
        │ 4.5  │
        ├╌╌╌╌╌╌┤
        │ 7    │
        ├╌╌╌╌╌╌┤
        │ 4    │
        ├╌╌╌╌╌╌┤
        │ 9    │
        ├╌╌╌╌╌╌┤
        │ 13   │
        └──────┘

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_mean(window_size, weights, min_periods, center)
        )

    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_sum(window_size, weights, min_periods, center)
        )

    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_std(window_size, weights, min_periods, center)
        )

    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_var(window_size, weights, min_periods, center)
        )

    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.

        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum

        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function


        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 2.0, 9.0, 2.0, 13.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_apply(3, lambda s: s.std())
        &gt;&gt;&gt; ])
        shape: (5, 1)
        ┌────────────────────┐
        │ A                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.358898943540674  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.041451884327381  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5.5677643628300215 │
        └────────────────────┘

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_apply(window_size, function))

    def rolling_median(self, window_size: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_median(window_size))

    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_quantile(window_size, quantile))

    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_skew(window_size, bias))

    def abs(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.abs())

    def argsort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.
        Parameters
        ----------
        reverse
            Reverse the ordering. Default is from low to high.
        &quot;&quot;&quot;
        return pli.argsort_by([self], [reverse])

    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rank(method))

    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.diff(n, null_behavior))

    def skew(self, bias: bool = True) -&gt; &quot;Expr&quot;:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.skew(bias))

    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.kurtosis(fisher, bias))

    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        min_val = pli.lit(min_val)  # type: ignore
        max_val = pli.lit(max_val)  # type: ignore

        return (
            pli.when(self &lt; min_val)  # type: ignore
            .then(min_val)
            .when(self &gt; max_val)
            .then(max_val)
            .otherwise(self)
        ).keep_name()

    def lower_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the lowest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lower_bound())

    def upper_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the highest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.upper_bound())

    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, None, 2]})
        &gt;&gt;&gt; df = df.select(pl.col(&quot;foo&quot;).str_concat(&quot;-&quot;))
        shape: (1, 1)
        ┌──────────┐
        │ foo      │
        │ ---      │
        │ str      │
        ╞══════════╡
        │ 1-null-2 │
        └──────────┘
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_concat(delimiter))

    def sin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).sin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.8414709848078965 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore

    def cos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).cos())
        shape: (1, 1)
        ┌─────┐
        │ a   │
        │ --- │
        │ f64 │
        ╞═════╡
        │ 1   │
        └─────┘
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore

    def tan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).tan())
        shape: (1, 1)
        ┌───────────────────┐
        │ a                 │
        │ ---               │
        │ f64               │
        ╞═══════════════════╡
        │ 1.557407724654902 │
        └───────────────────┘
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore

    def arcsin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arcsin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore

    def arccos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arccos())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore

    def arctan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arctan())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.7853981633974483 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore

    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reshape this Expr to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Expr
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<h2 id="constructor"><a class="header" href="#constructor">Constructor</a></h2>
<pre><code class="language-python">Expr()
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def __init__(self) -&gt; None:
        self._pyexpr: PyExpr
</code></pre>
<p>
</details>
</raw></p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p><div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpreq"><a class="header" href="#polarsinternalsexprexpreq"><code>polars.internals.expr.Expr.eq</code></a></h3>
<pre><code class="language-python">eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprneq"><a class="header" href="#polarsinternalsexprexprneq"><code>polars.internals.expr.Expr.neq</code></a></h3>
<pre><code class="language-python">neq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def neq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.neq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprgt"><a class="header" href="#polarsinternalsexprexprgt"><code>polars.internals.expr.Expr.gt</code></a></h3>
<pre><code class="language-python">gt(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def gt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprgt_eq"><a class="header" href="#polarsinternalsexprexprgt_eq"><code>polars.internals.expr.Expr.gt_eq</code></a></h3>
<pre><code class="language-python">gt_eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def gt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.gt_eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlt_eq"><a class="header" href="#polarsinternalsexprexprlt_eq"><code>polars.internals.expr.Expr.lt_eq</code></a></h3>
<pre><code class="language-python">lt_eq(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lt_eq(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt_eq(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlt"><a class="header" href="#polarsinternalsexprexprlt"><code>polars.internals.expr.Expr.lt</code></a></h3>
<pre><code class="language-python">lt(other: Expr) -&gt; Expr:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lt(self, other: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        return wrap_expr(self._pyexpr.lt(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpr__array_ufunc__function"><a class="header" href="#polarsinternalsexprexpr__array_ufunc__function"><code>polars.internals.expr.Expr.__array_ufunc__.function</code></a></h3>
<pre><code class="language-python">function(s: pli.Series) -&gt; pli.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def function(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return ufunc(s, *args, **kwargs)  # pragma: no cover
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsqrt"><a class="header" href="#polarsinternalsexprexprsqrt"><code>polars.internals.expr.Expr.sqrt</code></a></h3>
<pre><code class="language-python">sqrt() -&gt; Expr:
</code></pre>
<p>Compute the square root of the elements</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sqrt(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the square root of the elements
        &quot;&quot;&quot;
        return self ** 0.5
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpralias"><a class="header" href="#polarsinternalsexprexpralias"><code>polars.internals.expr.Expr.alias</code></a></h3>
<pre><code class="language-python">alias(name: str) -&gt; Expr:
</code></pre>
<p>Rename the output of an expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>name</code>]: New name.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
})
df
shape: (3, 2)
╭─────┬──────╮
│ a   ┆ b    │
│ --- ┆ ---  │
│ i64 ┆ str  │
╞═════╪══════╡
│ 1   ┆ &quot;a&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null │
╰─────┴──────╯
df.select([
col(&quot;a&quot;).alias(&quot;bar&quot;),
col(&quot;b&quot;).alias(&quot;foo&quot;)
])
shape: (3, 2)
╭─────┬──────╮
│ bar ┆ foo  │
│ --- ┆ ---  │
│ i64 ┆ str  │
╞═════╪══════╡
│ 1   ┆ &quot;a&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null │
╰─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def alias(self, name: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Rename the output of an expression.

        Parameters
        ----------
        name
            New name.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; df
        shape: (3, 2)
        ╭─────┬──────╮
        │ a   ┆ b    │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     col(&quot;a&quot;).alias(&quot;bar&quot;),
        &gt;&gt;&gt;     col(&quot;b&quot;).alias(&quot;foo&quot;)
        &gt;&gt;&gt; ])
        shape: (3, 2)
        ╭─────┬──────╮
        │ bar ┆ foo  │
        │ --- ┆ ---  │
        │ i64 ┆ str  │
        ╞═════╪══════╡
        │ 1   ┆ &quot;a&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 2   ┆ &quot;b&quot;  │
        ├╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ 3   ┆ null │
        ╰─────┴──────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.alias(name))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprexclude"><a class="header" href="#polarsinternalsexprexprexclude"><code>polars.internals.expr.Expr.exclude</code></a></h3>
<pre><code class="language-python">exclude(columns: Union[str, tp.List[str]]) -&gt; Expr:
</code></pre>
<p>Exclude certain columns from a wildcard/regex selection.</p>
<p>You may also use regexes int he exclude list. They must start with <code>^</code> and end with <code>$</code>.</p>
<h2 id="parameters"><a class="header" href="#parameters">Parameters</a></h2>
<ul>
<li>[<code> columns</code>]: Column(s) to exclude from selection</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
&quot;c&quot;: [None, 2, 1]
})
df
shape: (3, 3)
╭─────┬──────┬──────╮
│ a   ┆ b    ┆ c    │
│ --- ┆ ---  ┆ ---  │
│ i64 ┆ str  ┆ i64  │
╞═════╪══════╪══════╡
│ 1   ┆ &quot;a&quot;  ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ &quot;b&quot;  ┆ 2    │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ null ┆ 1    │
╰─────┴──────┴──────╯
df.select(col(&quot;*&quot;).exclude(&quot;b&quot;))
shape: (3, 2)
╭─────┬──────╮
│ a   ┆ c    │
│ --- ┆ ---  │
│ i64 ┆ i64  │
╞═════╪══════╡
│ 1   ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2   ┆ 2    │
├╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3   ┆ 1    │
╰─────┴──────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def exclude(self, columns: Union[str, tp.List[str]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
         Exclude certain columns from a wildcard/regex selection.

         You may also use regexes int he exclude list. They must start with `^` and end with `$`.

         Parameters
         ----------
         columns
             Column(s) to exclude from selection

         Examples
         --------

         &gt;&gt;&gt; df = pl.DataFrame({
         &gt;&gt;&gt;     &quot;a&quot;: [1, 2, 3],
         &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
         &gt;&gt;&gt;     &quot;c&quot;: [None, 2, 1]
         &gt;&gt;&gt; })
         &gt;&gt;&gt; df
         shape: (3, 3)
         ╭─────┬──────┬──────╮
         │ a   ┆ b    ┆ c    │
         │ --- ┆ ---  ┆ ---  │
         │ i64 ┆ str  ┆ i64  │
         ╞═════╪══════╪══════╡
         │ 1   ┆ &quot;a&quot;  ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ &quot;b&quot;  ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ null ┆ 1    │
         ╰─────┴──────┴──────╯
         &gt;&gt;&gt; df.select(col(&quot;*&quot;).exclude(&quot;b&quot;))
        shape: (3, 2)
         ╭─────┬──────╮
         │ a   ┆ c    │
         │ --- ┆ ---  │
         │ i64 ┆ i64  │
         ╞═════╪══════╡
         │ 1   ┆ null │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 2   ┆ 2    │
         ├╌╌╌╌╌┼╌╌╌╌╌╌┤
         │ 3   ┆ 1    │
         ╰─────┴──────╯
        &quot;&quot;&quot;
        if isinstance(columns, str):
            columns = [columns]
        return wrap_expr(self._pyexpr.exclude(columns))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprkeep_name"><a class="header" href="#polarsinternalsexprexprkeep_name"><code>polars.internals.expr.Expr.keep_name</code></a></h3>
<pre><code class="language-python">keep_name() -&gt; Expr:
</code></pre>
<p>Keep the original root name of the expression.</p>
<p><strong>Examples:</strong></p>
<p>A groupby aggregation often changes the name of a column.
With <code>keep_name</code> we can keep the original name of the column</p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [1, 2, 3],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
})
(df.groupby(&quot;a&quot;)
.agg(col(&quot;b&quot;).list())
.sort(by=&quot;a&quot;)
)
shape: (3, 2)
╭─────┬────────────╮
│ a   ┆ b_agg_list │
│ --- ┆ ---        │
│ i64 ┆ list [str] │
╞═════╪════════════╡
│ 1   ┆ [a]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ [b]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ [null]     │
╰─────┴────────────╯</p>
<h1 id="keep-the-original-column-name"><a class="header" href="#keep-the-original-column-name">keep the original column name</a></h1>
<p>(df.groupby(&quot;a&quot;)
.agg(col(&quot;b&quot;).list().keep_name())
.sort(by=&quot;a&quot;)
)
shape: (3, 2)
╭─────┬────────────╮
│ a   ┆ b          │
│ --- ┆ ---        │
│ i64 ┆ list [str] │
╞═════╪════════════╡
│ 1   ┆ [a]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ [b]        │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ [null]     │
╰─────┴────────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def keep_name(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Keep the original root name of the expression.

        Examples
        --------

        A groupby aggregation often changes the name of a column.
        With `keep_name` we can keep the original name of the column

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt; &quot;a&quot;: [1, 2, 3],
        &gt;&gt;&gt; &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None]
        &gt;&gt;&gt; })
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b_agg_list │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯
        &gt;&gt;&gt; # keep the original column name
        &gt;&gt;&gt; (df.groupby(&quot;a&quot;)
        &gt;&gt;&gt; .agg(col(&quot;b&quot;).list().keep_name())
        &gt;&gt;&gt; .sort(by=&quot;a&quot;)
        &gt;&gt;&gt; )
        shape: (3, 2)
        ╭─────┬────────────╮
        │ a   ┆ b          │
        │ --- ┆ ---        │
        │ i64 ┆ list [str] │
        ╞═════╪════════════╡
        │ 1   ┆ [a]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ [b]        │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ [null]     │
        ╰─────┴────────────╯

        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.keep_name())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprprefix"><a class="header" href="#polarsinternalsexprexprprefix"><code>polars.internals.expr.Expr.prefix</code></a></h3>
<pre><code class="language-python">prefix(prefix: str) -&gt; Expr:
</code></pre>
<p>Add a prefix the to root column name of the expression.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1, 2, 3, 4, 5],
&quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
&quot;B&quot;: [5, 4, 3, 2, 1],
&quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
})
shape: (5, 4)
╭─────┬──────────┬─────┬──────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     │
│ --- ┆ ---      ┆ --- ┆ ---      │
│ i64 ┆ str      ┆ i64 ┆ str      │
╞═════╪══════════╪═════╪══════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
╰─────┴──────────┴─────┴──────────╯
(df.select([
pl.all(),
pl.all().reverse().suffix(&quot;_reverse&quot;)
]))
shape: (5, 8)
╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     ┆ A_reverse ┆ fruits_reverse ┆ B_reverse ┆ cars_reverse │
│ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
│ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def prefix(self, prefix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a prefix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().suffix(&quot;_reverse&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ A_reverse ┆ fruits_reverse ┆ B_reverse ┆ cars_reverse │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.prefix(prefix))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsuffix"><a class="header" href="#polarsinternalsexprexprsuffix"><code>polars.internals.expr.Expr.suffix</code></a></h3>
<pre><code class="language-python">suffix(suffix: str) -&gt; Expr:
</code></pre>
<p>Add a suffix the to root column name of the expression.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1, 2, 3, 4, 5],
&quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
&quot;B&quot;: [5, 4, 3, 2, 1],
&quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
})
shape: (5, 4)
╭─────┬──────────┬─────┬──────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     │
│ --- ┆ ---      ┆ --- ┆ ---      │
│ i64 ┆ str      ┆ i64 ┆ str      │
╞═════╪══════════╪═════╪══════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
╰─────┴──────────┴─────┴──────────╯
(df.select([
pl.all(),
pl.all().reverse().prefix(&quot;reverse_&quot;)
]))
shape: (5, 8)
╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
│ A   ┆ fruits   ┆ B   ┆ cars     ┆ reverse_A ┆ reverse_fruits ┆ reverse_B ┆ reverse_cars │
│ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
│ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
│ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def suffix(self, suffix: str) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Add a suffix the to root column name of the expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt; {
        &gt;&gt;&gt;     &quot;A&quot;: [1, 2, 3, 4, 5],
        &gt;&gt;&gt;     &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &gt;&gt;&gt;     &quot;B&quot;: [5, 4, 3, 2, 1],
        &gt;&gt;&gt;     &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &gt;&gt;&gt; })
        shape: (5, 4)
        ╭─────┬──────────┬─────┬──────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     │
        │ --- ┆ ---      ┆ --- ┆ ---      │
        │ i64 ┆ str      ┆ i64 ┆ str      │
        ╞═════╪══════════╪═════╪══════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; │
        ╰─────┴──────────┴─────┴──────────╯
        &gt;&gt;&gt; (df.select([
        &gt;&gt;&gt; pl.all(),
        &gt;&gt;&gt; pl.all().reverse().prefix(&quot;reverse_&quot;)
        &gt;&gt;&gt; ]))
        shape: (5, 8)
        ╭─────┬──────────┬─────┬──────────┬───────────┬────────────────┬───────────┬──────────────╮
        │ A   ┆ fruits   ┆ B   ┆ cars     ┆ reverse_A ┆ reverse_fruits ┆ reverse_B ┆ reverse_cars │
        │ --- ┆ ---      ┆ --- ┆ ---      ┆ ---       ┆ ---            ┆ ---       ┆ ---          │
        │ i64 ┆ str      ┆ i64 ┆ str      ┆ i64       ┆ str            ┆ i64       ┆ str          │
        ╞═════╪══════════╪═════╪══════════╪═══════════╪════════════════╪═══════════╪══════════════╡
        │ 1   ┆ &quot;banana&quot; ┆ 5   ┆ &quot;beetle&quot; ┆ 5         ┆ &quot;banana&quot;       ┆ 1         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 2   ┆ &quot;banana&quot; ┆ 4   ┆ &quot;audi&quot;   ┆ 4         ┆ &quot;apple&quot;        ┆ 2         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 3   ┆ &quot;apple&quot;  ┆ 3   ┆ &quot;beetle&quot; ┆ 3         ┆ &quot;apple&quot;        ┆ 3         ┆ &quot;beetle&quot;     │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4   ┆ &quot;apple&quot;  ┆ 2   ┆ &quot;beetle&quot; ┆ 2         ┆ &quot;banana&quot;       ┆ 4         ┆ &quot;audi&quot;       │
        ├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5   ┆ &quot;banana&quot; ┆ 1   ┆ &quot;beetle&quot; ┆ 1         ┆ &quot;banana&quot;       ┆ 5         ┆ &quot;beetle&quot;     │
        ╰─────┴──────────┴─────┴──────────┴───────────┴────────────────┴───────────┴──────────────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.suffix(suffix))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_not"><a class="header" href="#polarsinternalsexprexpris_not"><code>polars.internals.expr.Expr.is_not</code></a></h3>
<pre><code class="language-python">is_not() -&gt; Expr:
</code></pre>
<p>Negate a boolean expression.</p>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({
&quot;a&quot;: [True, False, False],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
})
shape: (3, 2)
╭───────┬──────╮
│ a     ┆ b    │
│ ---   ┆ ---  │
│ bool  ┆ str  │
╞═══════╪══════╡
│ true  ┆ &quot;a&quot;  │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ false ┆ &quot;b&quot;  │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ false ┆ null │
╰───────┴──────╯
df.select(pl.col(&quot;a&quot;).is_not())
shape: (3, 1)
╭───────╮
│ a     │
│ ---   │
│ bool  │
╞═══════╡
│ false │
├╌╌╌╌╌╌╌┤
│ true  │
├╌╌╌╌╌╌╌┤
│ true  │
╰───────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Negate a boolean expression.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({
        &gt;&gt;&gt;     &quot;a&quot;: [True, False, False],
        &gt;&gt;&gt;     &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, None],
        &gt;&gt;&gt; })
        shape: (3, 2)
        ╭───────┬──────╮
        │ a     ┆ b    │
        │ ---   ┆ ---  │
        │ bool  ┆ str  │
        ╞═══════╪══════╡
        │ true  ┆ &quot;a&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ &quot;b&quot;  │
        ├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┤
        │ false ┆ null │
        ╰───────┴──────╯
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).is_not())
        shape: (3, 1)
        ╭───────╮
        │ a     │
        │ ---   │
        │ bool  │
        ╞═══════╡
        │ false │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ├╌╌╌╌╌╌╌┤
        │ true  │
        ╰───────╯

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_null"><a class="header" href="#polarsinternalsexprexpris_null"><code>polars.internals.expr.Expr.is_null</code></a></h3>
<pre><code class="language-python">is_null() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression contains null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression contains null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_not_null"><a class="header" href="#polarsinternalsexprexpris_not_null"><code>polars.internals.expr.Expr.is_not_null</code></a></h3>
<pre><code class="language-python">is_not_null() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression does not contain null values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_null(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression does not contain null values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_finite"><a class="header" href="#polarsinternalsexprexpris_finite"><code>polars.internals.expr.Expr.is_finite</code></a></h3>
<pre><code class="language-python">is_finite() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are finite.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_finite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are finite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_finite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_infinite"><a class="header" href="#polarsinternalsexprexpris_infinite"><code>polars.internals.expr.Expr.is_infinite</code></a></h3>
<pre><code class="language-python">is_infinite() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are infinite.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_infinite(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are infinite.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_infinite())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_nan"><a class="header" href="#polarsinternalsexprexpris_nan"><code>polars.internals.expr.Expr.is_nan</code></a></h3>
<pre><code class="language-python">is_nan() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are NaN (Not A Number).</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_not_nan"><a class="header" href="#polarsinternalsexprexpris_not_nan"><code>polars.internals.expr.Expr.is_not_nan</code></a></h3>
<pre><code class="language-python">is_not_nan() -&gt; Expr:
</code></pre>
<p>Create a boolean expression returning <code>True</code> where the expression values are not NaN (Not A Number).</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_not_nan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Create a boolean expression returning `True` where the expression values are not NaN (Not A Number).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_not_nan())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpragg_groups"><a class="header" href="#polarsinternalsexprexpragg_groups"><code>polars.internals.expr.Expr.agg_groups</code></a></h3>
<pre><code class="language-python">agg_groups() -&gt; Expr:
</code></pre>
<p>Get the group indexes of the group by operation.
Should be used in aggregation context only.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def agg_groups(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the group indexes of the group by operation.
        Should be used in aggregation context only.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.agg_groups())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcount"><a class="header" href="#polarsinternalsexprexprcount"><code>polars.internals.expr.Expr.count</code></a></h3>
<pre><code class="language-python">count() -&gt; Expr:
</code></pre>
<p>Count the number of values in this expression</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def count(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count the number of values in this expression&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.count())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlen"><a class="header" href="#polarsinternalsexprexprlen"><code>polars.internals.expr.Expr.len</code></a></h3>
<pre><code class="language-python">len() -&gt; Expr:
</code></pre>
<p>Alias for count
Count the number of values in this expression</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def len(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for count
        Count the number of values in this expression
        &quot;&quot;&quot;
        return self.count()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprslice"><a class="header" href="#polarsinternalsexprexprslice"><code>polars.internals.expr.Expr.slice</code></a></h3>
<pre><code class="language-python">slice(offset: int, length: int) -&gt; Expr:
</code></pre>
<p>Slice the Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>offset</code>]: Start index.</li>
<li>[<code>length</code>]: Length of the slice.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def slice(self, offset: int, length: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Slice the Series.

        Parameters
        ----------
        offset
            Start index.
        length
            Length of the slice.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.slice(offset, length))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdrop_nulls"><a class="header" href="#polarsinternalsexprexprdrop_nulls"><code>polars.internals.expr.Expr.drop_nulls</code></a></h3>
<pre><code class="language-python">drop_nulls() -&gt; Expr:
</code></pre>
<p>Syntactic sugar for:</p>
<blockquote>
<blockquote>
<blockquote>
<p>pl.col(&quot;foo&quot;).filter(pl.col(&quot;foo&quot;).is_not_null())</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def drop_nulls(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Syntactic sugar for:

        &gt;&gt;&gt; pl.col(&quot;foo&quot;).filter(pl.col(&quot;foo&quot;).is_not_null())
        &quot;&quot;&quot;
        return self.filter(self.is_not_null())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcumsum"><a class="header" href="#polarsinternalsexprexprcumsum"><code>polars.internals.expr.Expr.cumsum</code></a></h3>
<pre><code class="language-python">cumsum(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative sum computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumsum(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative sum computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumsum(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcumprod"><a class="header" href="#polarsinternalsexprexprcumprod"><code>polars.internals.expr.Expr.cumprod</code></a></h3>
<pre><code class="language-python">cumprod(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative product computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cumprod(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative product computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cumprod(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcummin"><a class="header" href="#polarsinternalsexprexprcummin"><code>polars.internals.expr.Expr.cummin</code></a></h3>
<pre><code class="language-python">cummin(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative min computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummin(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative min computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummin(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcummax"><a class="header" href="#polarsinternalsexprexprcummax"><code>polars.internals.expr.Expr.cummax</code></a></h3>
<pre><code class="language-python">cummax(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get an array with the cumulative max computed at every element.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the operation.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cummax(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get an array with the cumulative max computed at every element.

        Parameters
        ----------
        reverse
            Reverse the operation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.cummax(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfloor"><a class="header" href="#polarsinternalsexprexprfloor"><code>polars.internals.expr.Expr.floor</code></a></h3>
<pre><code class="language-python">floor() -&gt; Expr:
</code></pre>
<p>Floor underlying floating point array to the lowest integers smaller or equal to the float value.</p>
<p>Only works on floating point Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def floor(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Floor underlying floating point array to the lowest integers smaller or equal to the float value.

        Only works on floating point Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.floor())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprround"><a class="header" href="#polarsinternalsexprexprround"><code>polars.internals.expr.Expr.round</code></a></h3>
<pre><code class="language-python">round(decimals: int) -&gt; Expr:
</code></pre>
<p>Round underlying floating point data by <code>decimals</code> digits.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>decimals</code>]: Number of decimals to round by.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def round(self, decimals: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Round underlying floating point data by `decimals` digits.

        Parameters
        ----------
        decimals
            Number of decimals to round by.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.round(decimals))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdot"><a class="header" href="#polarsinternalsexprexprdot"><code>polars.internals.expr.Expr.dot</code></a></h3>
<pre><code class="language-python">dot(other: Union[Expr, str]) -&gt; Expr:
</code></pre>
<p>Compute the dot/inner product between two Expressions</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Expression to compute dot product with</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dot(self, other: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the dot/inner product between two Expressions

        Parameters
        ----------
        other
            Expression to compute dot product with
        &quot;&quot;&quot;
        other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.dot(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmode"><a class="header" href="#polarsinternalsexprexprmode"><code>polars.internals.expr.Expr.mode</code></a></h3>
<pre><code class="language-python">mode() -&gt; Expr:
</code></pre>
<p>Compute the most occurring value(s). Can return multiple Values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the most occurring value(s). Can return multiple Values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcast"><a class="header" href="#polarsinternalsexprexprcast"><code>polars.internals.expr.Expr.cast</code></a></h3>
<pre><code class="language-python">cast(dtype: TypeAny, strict: bool) -&gt; Expr:
</code></pre>
<p>Cast between data types.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dtype</code>]: DataType to cast to</li>
<li>[<code>strict</code>]: Throw an error if a cast could not be done for instance due to an overflow</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cast(self, dtype: Type[Any], strict: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Cast between data types.

        Parameters
        ----------
        dtype
            DataType to cast to
        strict
            Throw an error if a cast could not be done for instance due to an overflow
        &quot;&quot;&quot;
        dtype = py_type_to_dtype(dtype)
        return wrap_expr(self._pyexpr.cast(dtype, strict))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsort"><a class="header" href="#polarsinternalsexprexprsort"><code>polars.internals.expr.Expr.sort</code></a></h3>
<pre><code class="language-python">sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Sort this column. In projection/ selection context the whole column is sorted.
If used in a groupby context, the groups are sorted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column. In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_sort"><a class="header" href="#polarsinternalsexprexprarg_sort"><code>polars.internals.expr.Expr.arg_sort</code></a></h3>
<pre><code class="language-python">arg_sort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Get the index values that would sort this column.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>[<code>out</code>]: Series of type UInt32</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_sort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index values that would sort this column.

        Parameters
        ----------
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.

        Returns
        -------
        out
            Series of type UInt32
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_sort(reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_max"><a class="header" href="#polarsinternalsexprexprarg_max"><code>polars.internals.expr.Expr.arg_max</code></a></h3>
<pre><code class="language-python">arg_max() -&gt; Expr:
</code></pre>
<p>Get the index of the maximal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the maximal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_min"><a class="header" href="#polarsinternalsexprexprarg_min"><code>polars.internals.expr.Expr.arg_min</code></a></h3>
<pre><code class="language-python">arg_min() -&gt; Expr:
</code></pre>
<p>Get the index of the minimal value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the index of the minimal value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsort_by"><a class="header" href="#polarsinternalsexprexprsort_by"><code>polars.internals.expr.Expr.sort_by</code></a></h3>
<pre><code class="language-python">sort_by(by: Union[Expr, str, tp.List[Union[Expr, str]]], 
    reverse: Union[bool, tp.List[bool]],) -&gt; Expr:
</code></pre>
<p>Sort this column by the ordering of another column, or multiple other columns.
In projection/ selection context the whole column is sorted.
If used in a groupby context, the groups are sorted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: The column(s) used for sorting.</li>
<li>[<code>reverse</code>]: False -&gt; order from small to large.
True -&gt; order from large to small.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sort_by(
        self,
        by: Union[&quot;Expr&quot;, str, tp.List[Union[&quot;Expr&quot;, str]]],
        reverse: Union[bool, tp.List[bool]] = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Sort this column by the ordering of another column, or multiple other columns.
        In projection/ selection context the whole column is sorted.
        If used in a groupby context, the groups are sorted.

        Parameters
        ----------
        by
            The column(s) used for sorting.
        reverse
            False -&gt; order from small to large.
            True -&gt; order from large to small.
        &quot;&quot;&quot;
        if not isinstance(by, list):
            by = [by]
        if not isinstance(reverse, list):
            reverse = [reverse]
        by = _selection_to_pyexpr_list(by)

        return wrap_expr(self._pyexpr.sort_by(by, reverse))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtake"><a class="header" href="#polarsinternalsexprexprtake"><code>polars.internals.expr.Expr.take</code></a></h3>
<pre><code class="language-python">take(index: Union[tp.List[int], Expr, pli.Series, np.ndarray],) -&gt; Expr:
</code></pre>
<p>Take values by index.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>index</code>]: An expression that leads to a UInt32 dtyped Series.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Values taken by index</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take(
        self, index: Union[tp.List[int], &quot;Expr&quot;, &quot;pli.Series&quot;, np.ndarray]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take values by index.

        Parameters
        ----------
        index
            An expression that leads to a UInt32 dtyped Series.

        Returns
        -------
        Values taken by index
        &quot;&quot;&quot;
        if isinstance(index, (list, np.ndarray)):
            index = pli.lit(pli.Series(&quot;&quot;, index, dtype=UInt32))  # type: ignore
        elif isinstance(index, pli.Series):
            index = pli.lit(index)  # type: ignore
        else:
            index = pli.expr_to_lit_or_expr(index, str_to_lit=False)  # type: ignore
        return pli.wrap_expr(self._pyexpr.take(index._pyexpr))  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprshift"><a class="header" href="#polarsinternalsexprexprshift"><code>polars.internals.expr.Expr.shift</code></a></h3>
<pre><code class="language-python">shift(periods: int) -&gt; Expr:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with <code>Nones</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift(self, periods: int = 1) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with `Nones`.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.shift(periods))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprshift_and_fill"><a class="header" href="#polarsinternalsexprexprshift_and_fill"><code>polars.internals.expr.Expr.shift_and_fill</code></a></h3>
<pre><code class="language-python">shift_and_fill(periods: int, fill_value: Expr) -&gt; Expr:
</code></pre>
<p>Shift the values by a given period and fill the parts that will be empty due to this operation
with the result of the <code>fill_value</code> expression.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>periods</code>]: Number of places to shift (may be negative).</li>
<li>[<code>fill_value</code>]: Fill None values with the result of this expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def shift_and_fill(self, periods: int, fill_value: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Shift the values by a given period and fill the parts that will be empty due to this operation
        with the result of the `fill_value` expression.

        Parameters
        ----------
        periods
            Number of places to shift (may be negative).
        fill_value
            Fill None values with the result of this expression.
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.shift_and_fill(periods, fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfill_null"><a class="header" href="#polarsinternalsexprexprfill_null"><code>polars.internals.expr.Expr.fill_null</code></a></h3>
<pre><code class="language-python">fill_null(fill_value: Union[str, int, float, Expr],) -&gt; Expr:
</code></pre>
<p>Fill none value with a fill value or strategy</p>
<ul>
<li>[<code>fill_value</code>]: Fill null strategy or a value
* &quot;backward&quot;
* &quot;forward&quot;
* &quot;min&quot;
* &quot;max&quot;
* &quot;mean&quot;
* &quot;one&quot;
* &quot;zero&quot;</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_null(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value or strategy

        fill_value
            Fill null strategy or a value
                   * &quot;backward&quot;
                   * &quot;forward&quot;
                   * &quot;min&quot;
                   * &quot;max&quot;
                   * &quot;mean&quot;
                   * &quot;one&quot;
                   * &quot;zero&quot;
        &quot;&quot;&quot;
        # we first must check if it is not an expr, as expr does not implement __bool__
        # and thus leads to a value error in the second comparisson.
        if not isinstance(fill_value, Expr) and fill_value in [
            &quot;backward&quot;,
            &quot;forward&quot;,
            &quot;min&quot;,
            &quot;max&quot;,
            &quot;mean&quot;,
            &quot;zero&quot;,
            &quot;one&quot;,
        ]:
            return wrap_expr(self._pyexpr.fill_null_with_strategy(fill_value))

        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_null(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfill_nan"><a class="header" href="#polarsinternalsexprexprfill_nan"><code>polars.internals.expr.Expr.fill_nan</code></a></h3>
<pre><code class="language-python">fill_nan(fill_value: Union[str, int, float, Expr],) -&gt; Expr:
</code></pre>
<p>Fill none value with a fill value</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def fill_nan(self, fill_value: Union[str, int, float, &quot;Expr&quot;]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill none value with a fill value
        &quot;&quot;&quot;
        fill_value = expr_to_lit_or_expr(fill_value, str_to_lit=True)
        return wrap_expr(self._pyexpr.fill_nan(fill_value._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprforward_fill"><a class="header" href="#polarsinternalsexprexprforward_fill"><code>polars.internals.expr.Expr.forward_fill</code></a></h3>
<pre><code class="language-python">forward_fill() -&gt; Expr:
</code></pre>
<p>Fill missing values with the latest seen values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def forward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the latest seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.forward_fill())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprbackward_fill"><a class="header" href="#polarsinternalsexprexprbackward_fill"><code>polars.internals.expr.Expr.backward_fill</code></a></h3>
<pre><code class="language-python">backward_fill() -&gt; Expr:
</code></pre>
<p>Fill missing values with the next to be seen values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def backward_fill(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Fill missing values with the next to be seen values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.backward_fill())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprreverse"><a class="header" href="#polarsinternalsexprexprreverse"><code>polars.internals.expr.Expr.reverse</code></a></h3>
<pre><code class="language-python">reverse() -&gt; Expr:
</code></pre>
<p>Reverse the selection.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reverse(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reverse the selection.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reverse())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstd"><a class="header" href="#polarsinternalsexprexprstd"><code>polars.internals.expr.Expr.std</code></a></h3>
<pre><code class="language-python">std() -&gt; Expr:
</code></pre>
<p>Get standard deviation.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def std(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get standard deviation.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.std())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprvar"><a class="header" href="#polarsinternalsexprexprvar"><code>polars.internals.expr.Expr.var</code></a></h3>
<pre><code class="language-python">var() -&gt; Expr:
</code></pre>
<p>Get variance.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def var(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get variance.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.var())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmax"><a class="header" href="#polarsinternalsexprexprmax"><code>polars.internals.expr.Expr.max</code></a></h3>
<pre><code class="language-python">max() -&gt; Expr:
</code></pre>
<p>Get maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def max(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get maximum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.max())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmin"><a class="header" href="#polarsinternalsexprexprmin"><code>polars.internals.expr.Expr.min</code></a></h3>
<pre><code class="language-python">min() -&gt; Expr:
</code></pre>
<p>Get minimum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def min(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get minimum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.min())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsum"><a class="header" href="#polarsinternalsexprexprsum"><code>polars.internals.expr.Expr.sum</code></a></h3>
<pre><code class="language-python">sum() -&gt; Expr:
</code></pre>
<p>Get sum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sum(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get sum value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.sum())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmean"><a class="header" href="#polarsinternalsexprexprmean"><code>polars.internals.expr.Expr.mean</code></a></h3>
<pre><code class="language-python">mean() -&gt; Expr:
</code></pre>
<p>Get mean value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def mean(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mean value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.mean())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmedian"><a class="header" href="#polarsinternalsexprexprmedian"><code>polars.internals.expr.Expr.median</code></a></h3>
<pre><code class="language-python">median() -&gt; Expr:
</code></pre>
<p>Get median value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def median(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get median value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.median())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprn_unique"><a class="header" href="#polarsinternalsexprexprn_unique"><code>polars.internals.expr.Expr.n_unique</code></a></h3>
<pre><code class="language-python">n_unique() -&gt; Expr:
</code></pre>
<p>Count unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def n_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Count unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.n_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarg_unique"><a class="header" href="#polarsinternalsexprexprarg_unique"><code>polars.internals.expr.Expr.arg_unique</code></a></h3>
<pre><code class="language-python">arg_unique() -&gt; Expr:
</code></pre>
<p>Get index of first unique value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arg_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get index of first unique value.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.arg_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprunique"><a class="header" href="#polarsinternalsexprexprunique"><code>polars.internals.expr.Expr.unique</code></a></h3>
<pre><code class="language-python">unique() -&gt; Expr:
</code></pre>
<p>Get unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Get unique values.&quot;&quot;&quot;
        return wrap_expr(self._pyexpr.unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfirst"><a class="header" href="#polarsinternalsexprexprfirst"><code>polars.internals.expr.Expr.first</code></a></h3>
<pre><code class="language-python">first() -&gt; Expr:
</code></pre>
<p>Get the first value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the first value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlast"><a class="header" href="#polarsinternalsexprexprlast"><code>polars.internals.expr.Expr.last</code></a></h3>
<pre><code class="language-python">last() -&gt; Expr:
</code></pre>
<p>Get the last value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def last(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get the last value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.last())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlist"><a class="header" href="#polarsinternalsexprexprlist"><code>polars.internals.expr.Expr.list</code></a></h3>
<pre><code class="language-python">list() -&gt; Expr:
</code></pre>
<p>Aggregate to list.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def list(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Aggregate to list.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.list())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprover"><a class="header" href="#polarsinternalsexprexprover"><code>polars.internals.expr.Expr.over</code></a></h3>
<pre><code class="language-python">over(expr: Union[str, Expr, tp.List[Union[Expr, str]]],) -&gt; Expr:
</code></pre>
<p>Apply window function over a subgroup.
This is similar to a groupby + aggregation + self join.
Or similar to <a href="https:/www.postgresql.org/docs/9.1/tutorial-window.html">window functions in Postgres</a></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>expr</code>]: Column(s) to group by.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = DataFrame({
&quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
&quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
})
(df.lazy()
.select([
pl.col(&quot;groups&quot;)
sum(&quot;values&quot;).over(&quot;groups&quot;)
]).collect())
╭────────┬────────╮
│ groups ┆ values │
│ ---    ┆ ---    │
│ i32    ┆ i32    │
╞════════╪════════╡
│ 1      ┆ 16     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1      ┆ 16     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2      ┆ 13     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2      ┆ 13     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ ...    ┆ ...    │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1      ┆ 16     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2      ┆ 13     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3      ┆ 15     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3      ┆ 15     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 1      ┆ 16     │
╰────────┴────────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def over(self, expr: Union[str, &quot;Expr&quot;, tp.List[Union[&quot;Expr&quot;, str]]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply window function over a subgroup.
        This is similar to a groupby + aggregation + self join.
        Or similar to [window functions in Postgres](https://www.postgresql.org/docs/9.1/tutorial-window.html)

        Parameters
        ----------
        expr
            Column(s) to group by.

        Examples
        --------

        &gt;&gt;&gt; df = DataFrame({
        &gt;&gt;&gt;    &quot;groups&quot;: [1, 1, 2, 2, 1, 2, 3, 3, 1],
        &gt;&gt;&gt;    &quot;values&quot;: [1, 2, 3, 4, 5, 6, 7, 8, 8]
        &gt;&gt;&gt;})
        &gt;&gt;&gt; (df.lazy()
        &gt;&gt;&gt;    .select([
        &gt;&gt;&gt;       pl.col(&quot;groups&quot;)
        &gt;&gt;&gt;       sum(&quot;values&quot;).over(&quot;groups&quot;)
        &gt;&gt;&gt;   ]).collect())
            ╭────────┬────────╮
            │ groups ┆ values │
            │ ---    ┆ ---    │
            │ i32    ┆ i32    │
            ╞════════╪════════╡
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ ...    ┆ ...    │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 2      ┆ 13     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 3      ┆ 15     │
            ├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
            │ 1      ┆ 16     │
            ╰────────┴────────╯

        &quot;&quot;&quot;

        pyexprs = _selection_to_pyexpr_list(expr)

        return wrap_expr(self._pyexpr.over(pyexprs))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_unique"><a class="header" href="#polarsinternalsexprexpris_unique"><code>polars.internals.expr.Expr.is_unique</code></a></h3>
<pre><code class="language-python">is_unique() -&gt; Expr:
</code></pre>
<p>Get mask of unique values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_unique(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of unique values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_unique())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_first"><a class="header" href="#polarsinternalsexprexpris_first"><code>polars.internals.expr.Expr.is_first</code></a></h3>
<pre><code class="language-python">is_first() -&gt; Expr:
</code></pre>
<p>Get a mask of the first unique value.</p>
<p><strong>Returns:</strong></p>
<p>Boolean Series</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_first(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get a mask of the first unique value.

        Returns
        -------
        Boolean Series
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_first())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_duplicated"><a class="header" href="#polarsinternalsexprexpris_duplicated"><code>polars.internals.expr.Expr.is_duplicated</code></a></h3>
<pre><code class="language-python">is_duplicated() -&gt; Expr:
</code></pre>
<p>Get mask of duplicated values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_duplicated(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get mask of duplicated values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.is_duplicated())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprquantile"><a class="header" href="#polarsinternalsexprexprquantile"><code>polars.internals.expr.Expr.quantile</code></a></h3>
<pre><code class="language-python">quantile(quantile: float) -&gt; Expr:
</code></pre>
<p>Get quantile value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def quantile(self, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Get quantile value.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.quantile(quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprfilter"><a class="header" href="#polarsinternalsexprexprfilter"><code>polars.internals.expr.Expr.filter</code></a></h3>
<pre><code class="language-python">filter(predicate: Expr) -&gt; Expr:
</code></pre>
<p>Filter a single column.
Mostly useful in in aggregation context. If you want to filter on a DataFrame level, use <code>LazyFrame.filter</code>.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def filter(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Filter a single column.
        Mostly useful in in aggregation context. If you want to filter on a DataFrame level, use `LazyFrame.filter`.

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.filter(predicate._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprwhere"><a class="header" href="#polarsinternalsexprexprwhere"><code>polars.internals.expr.Expr.where</code></a></h3>
<pre><code class="language-python">where(predicate: Expr) -&gt; Expr:
</code></pre>
<p>Alias for filter</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>predicate</code>]: Boolean expression.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def where(self, predicate: &quot;Expr&quot;) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for filter

        Parameters
        ----------
        predicate
            Boolean expression.
        &quot;&quot;&quot;
        return self.filter(predicate)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprmap"><a class="header" href="#polarsinternalsexprexprmap"><code>polars.internals.expr.Expr.map</code></a></h3>
<pre><code class="language-python">map(f: Callable[[pli.Series], pli.Series], 
    return_dtype: OptionalTypeDataType, 
    agg_list: bool,) -&gt; Expr:
</code></pre>
<p>Apply a custom python function. This function must produce a <code>Series</code>. Any other value will be stored as
null/missing. If you want to apply a function over single values, consider using <code>apply</code>.</p>
<p><a href="https:/pola-rs.github.io/polars-book/user-guide/howcani/apply/udfs.html">read more in the book</a></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>return_dtype</code>]: Dtype of the output Series.
agg_list</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def map(
        self,
        f: Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;],
        return_dtype: Optional[Type[DataType]] = None,
        agg_list: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom python function. This function must produce a `Series`. Any other value will be stored as
        null/missing. If you want to apply a function over single values, consider using `apply`.

        [read more in the book](https://pola-rs.github.io/polars-book/user-guide/howcani/apply/udfs.html)

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.
        agg_list

        &quot;&quot;&quot;
        if return_dtype is not None:
            return_dtype = py_type_to_dtype(return_dtype)
        return wrap_expr(self._pyexpr.map(f, return_dtype, agg_list))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprapply"><a class="header" href="#polarsinternalsexprexprapply"><code>polars.internals.expr.Expr.apply</code></a></h3>
<pre><code class="language-python">apply(f: Union[Callable[[pli.Series], pli.Series], Callable[[Any], Any]], 
    return_dtype: OptionalTypeDataType,) -&gt; Expr:
</code></pre>
<p>Apply a custom function in a GroupBy or Projection context.</p>
<p>Depending on the context it has the following behavior:</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<ul>
<li>Select/Project
expected type <code>f</code>: Callable[[Any], Any]
Applies a python function over each individual value in the column.</li>
<li>GroupBy
expected type <code>f</code>: Callable[[Series], Series]
Applies a python function over each group.</li>
</ul>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>f</code>]: Lambda/ function to apply.</li>
<li>[<code>return_dtype</code>]: Dtype of the output Series.</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
&quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})
df
.lazy()
.groupby(&quot;b&quot;)
.agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
.collect()
)
shape: (3, 2)
╭─────┬─────╮
│ b   ┆ a   │
│ --- ┆ --- │
│ str ┆ i64 │
╞═════╪═════╡
│ a   ┆ 1   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ b   ┆ 2   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ c   ┆ 2   │
╰─────┴─────╯</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def apply(
        self,
        f: Union[Callable[[&quot;pli.Series&quot;], &quot;pli.Series&quot;], Callable[[Any], Any]],
        return_dtype: Optional[Type[DataType]] = None,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a custom function in a GroupBy or Projection context.

        Depending on the context it has the following behavior:

        ## Context

        * Select/Project
            expected type `f`: Callable[[Any], Any]
            Applies a python function over each individual value in the column.
        * GroupBy
            expected type `f`: Callable[[Series], Series]
            Applies a python function over each group.

        Parameters
        ----------
        f
            Lambda/ function to apply.
        return_dtype
            Dtype of the output Series.

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1,  2,  1,  1],
                   &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;]})
        &gt;&gt;&gt; df
         .lazy()
         .groupby(&quot;b&quot;)
         .agg([col(&quot;a&quot;).apply(lambda x: x.sum())])
         .collect()
        )
        shape: (3, 2)
        ╭─────┬─────╮
        │ b   ┆ a   │
        │ --- ┆ --- │
        │ str ┆ i64 │
        ╞═════╪═════╡
        │ a   ┆ 1   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ b   ┆ 2   │
        ├╌╌╌╌╌┼╌╌╌╌╌┤
        │ c   ┆ 2   │
        ╰─────┴─────╯

        &quot;&quot;&quot;

        # input x: Series of type list containing the group values
        def wrap_f(x: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)

        return self.map(wrap_f, agg_list=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprapplywrap_f"><a class="header" href="#polarsinternalsexprexprapplywrap_f"><code>polars.internals.expr.Expr.apply.wrap_f</code></a></h3>
<pre><code class="language-python">wrap_f(x: pli.Series) -&gt; pli.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def wrap_f(x: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            return x.apply(f, return_dtype=return_dtype)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprflatten"><a class="header" href="#polarsinternalsexprexprflatten"><code>polars.internals.expr.Expr.flatten</code></a></h3>
<pre><code class="language-python">flatten() -&gt; Expr:
</code></pre>
<p>Alias for explode.</p>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def flatten(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Alias for explode.

        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;

        return wrap_expr(self._pyexpr.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprexplode"><a class="header" href="#polarsinternalsexprexprexplode"><code>polars.internals.expr.Expr.explode</code></a></h3>
<pre><code class="language-python">explode() -&gt; Expr:
</code></pre>
<p>Explode a list or utf8 Series. This means that every item is expanded to a new row.</p>
<p><strong>Returns:</strong></p>
<p>Exploded Series of same dtype</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def explode(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Explode a list or utf8 Series. This means that every item is expanded to a new row.

        Returns
        -------
        Exploded Series of same dtype
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.explode())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtake_every"><a class="header" href="#polarsinternalsexprexprtake_every"><code>polars.internals.expr.Expr.take_every</code></a></h3>
<pre><code class="language-python">take_every(n: int) -&gt; Expr:
</code></pre>
<p>Take every nth value in the Series and return as a new Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def take_every(self, n: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take every nth value in the Series and return as a new Series.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.take_every(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprhead"><a class="header" href="#polarsinternalsexprexprhead"><code>polars.internals.expr.Expr.head</code></a></h3>
<pre><code class="language-python">head(n: Optionalint) -&gt; Expr:
</code></pre>
<p>Take the first n values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def head(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the first n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.head(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtail"><a class="header" href="#polarsinternalsexprexprtail"><code>polars.internals.expr.Expr.tail</code></a></h3>
<pre><code class="language-python">tail(n: Optionalint) -&gt; Expr:
</code></pre>
<p>Take the last n values.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tail(self, n: Optional[int] = None) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take the last n values.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.tail(n))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprpow"><a class="header" href="#polarsinternalsexprexprpow"><code>polars.internals.expr.Expr.pow</code></a></h3>
<pre><code class="language-python">pow(exponent: float) -&gt; Expr:
</code></pre>
<p>Raise expression to the power of exponent.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def pow(self, exponent: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Raise expression to the power of exponent.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.pow(exponent))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_in"><a class="header" href="#polarsinternalsexprexpris_in"><code>polars.internals.expr.Expr.is_in</code></a></h3>
<pre><code class="language-python">is_in(other: Union[Expr, tp.List[Any]]) -&gt; Expr:
</code></pre>
<p>Check if elements of this Series are in the right Series, or List values of the right Series.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>other</code>]: Series of primitive type or List type.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr that evaluates to a Boolean Series.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_in(self, other: Union[&quot;Expr&quot;, tp.List[Any]]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if elements of this Series are in the right Series, or List values of the right Series.

        Parameters
        ----------
        other
            Series of primitive type or List type.

        Returns
        -------
        Expr that evaluates to a Boolean Series.
        &quot;&quot;&quot;
        if isinstance(other, list):
            other = pli.lit(pli.Series(other))
        else:
            other = expr_to_lit_or_expr(other, str_to_lit=False)
        return wrap_expr(self._pyexpr.is_in(other._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrepeat_by"><a class="header" href="#polarsinternalsexprexprrepeat_by"><code>polars.internals.expr.Expr.repeat_by</code></a></h3>
<pre><code class="language-python">repeat_by(by: Union[Expr, str]) -&gt; Expr:
</code></pre>
<p>Repeat the elements in this Series <code>n</code> times by dictated by the number given by <code>by</code>.
The elements are expanded into a <code>List</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>by</code>]: Numeric column that determines how often the values will be repeated.
The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Series of type List</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def repeat_by(self, by: Union[&quot;Expr&quot;, str]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Repeat the elements in this Series `n` times by dictated by the number given by `by`.
        The elements are expanded into a `List`

        Parameters
        ----------
        by
            Numeric column that determines how often the values will be repeated.
            The column will be coerced to UInt32. Give this dtype to make the coercion a no-op.

        Returns
        -------
        Series of type List
        &quot;&quot;&quot;
        by = expr_to_lit_or_expr(by, False)
        return wrap_expr(self._pyexpr.repeat_by(by._pyexpr))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexpris_between"><a class="header" href="#polarsinternalsexprexpris_between"><code>polars.internals.expr.Expr.is_between</code></a></h3>
<pre><code class="language-python">is_between(start: Union[Expr, datetime], 
    end: Union[Expr, datetime],) -&gt; Expr:
</code></pre>
<p>Check if this expression is between start and end.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def is_between(
        self, start: Union[&quot;Expr&quot;, datetime], end: Union[&quot;Expr&quot;, datetime]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Check if this expression is between start and end.
        &quot;&quot;&quot;
        cast_to_datetime = False
        if isinstance(start, datetime):
            start = pli.lit(start)
            cast_to_datetime = True
        if isinstance(end, datetime):
            end = pli.lit(end)
            cast_to_datetime = True
        if cast_to_datetime:
            expr = self.cast(Datetime)
        else:
            expr = self
        return ((expr &gt; start) &amp; (expr &lt; end)).alias(&quot;is_between&quot;)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdt"><a class="header" href="#polarsinternalsexprexprdt"><code>polars.internals.expr.Expr.dt</code></a></h3>
<pre><code class="language-python">dt() -&gt; ExprDateTimeNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def dt(self) -&gt; &quot;ExprDateTimeNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprDateTimeNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstr"><a class="header" href="#polarsinternalsexprexprstr"><code>polars.internals.expr.Expr.str</code></a></h3>
<pre><code class="language-python">str() -&gt; ExprStringNameSpace:
</code></pre>
<p>Create an object namespace of all string related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str(self) -&gt; &quot;ExprStringNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all string related methods.
        &quot;&quot;&quot;
        return ExprStringNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarr"><a class="header" href="#polarsinternalsexprexprarr"><code>polars.internals.expr.Expr.arr</code></a></h3>
<pre><code class="language-python">arr() -&gt; ExprListNameSpace:
</code></pre>
<p>Create an object namespace of all datetime related methods.</p>
<p><strong>Decoration</strong> via <code>@property</code>.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arr(self) -&gt; &quot;ExprListNameSpace&quot;:
        &quot;&quot;&quot;
        Create an object namespace of all datetime related methods.
        &quot;&quot;&quot;
        return ExprListNameSpace(self)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprhash"><a class="header" href="#polarsinternalsexprexprhash"><code>polars.internals.expr.Expr.hash</code></a></h3>
<pre><code class="language-python">hash(k0: int, k1: int, k2: int, k3: int) -&gt; Expr:
</code></pre>
<p>Hash the Series.</p>
<p>The hash value is of type <code>Datetime</code></p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>k0</code>]: seed parameter</li>
<li>[<code>k1</code>]: seed parameter</li>
<li>[<code>k2</code>]: seed parameter</li>
<li>[<code>k3</code>]: seed parameter</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def hash(self, k0: int = 0, k1: int = 1, k2: int = 2, k3: int = 3) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Hash the Series.

        The hash value is of type `Datetime`

        Parameters
        ----------
        k0
            seed parameter
        k1
            seed parameter
        k2
            seed parameter
        k3
            seed parameter
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.hash(k0, k1, k2, k3))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprreinterpret"><a class="header" href="#polarsinternalsexprexprreinterpret"><code>polars.internals.expr.Expr.reinterpret</code></a></h3>
<pre><code class="language-python">reinterpret(signed: bool) -&gt; Expr:
</code></pre>
<p>Reinterpret the underlying bits as a signed/unsigned integer.
This operation is only allowed for 64bit integers. For lower bits integers,
you can safely use that cast operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>signed</code>]: True -&gt; pl.Int64
False -&gt; pl.UInt64</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reinterpret(self, signed: bool) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reinterpret the underlying bits as a signed/unsigned integer.
        This operation is only allowed for 64bit integers. For lower bits integers,
        you can safely use that cast operation.

        Parameters
        ----------
        signed
            True -&gt; pl.Int64
            False -&gt; pl.UInt64
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reinterpret(signed))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprinspect"><a class="header" href="#polarsinternalsexprexprinspect"><code>polars.internals.expr.Expr.inspect</code></a></h3>
<pre><code class="language-python">inspect(fmt: str) -&gt; Expr:
</code></pre>
<p>Prints the value that this expression evaluates to and passes on the value.</p>
<blockquote>
<blockquote>
<blockquote>
<p>df.select(pl.col(&quot;foo&quot;).cumsum().inspect(&quot;value is: {}&quot;).alias(&quot;bar&quot;))</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def inspect(self, fmt: str = &quot;{}&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Prints the value that this expression evaluates to and passes on the value.

        &gt;&gt;&gt; df.select(pl.col(&quot;foo&quot;).cumsum().inspect(&quot;value is: {}&quot;).alias(&quot;bar&quot;))
        &quot;&quot;&quot;

        def inspect(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            print(fmt.format(s))  # type: ignore
            return s

        return self.map(inspect, return_dtype=None, agg_list=True)
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprinspectinspect"><a class="header" href="#polarsinternalsexprexprinspectinspect"><code>polars.internals.expr.Expr.inspect.inspect</code></a></h3>
<pre><code class="language-python">inspect(s: pli.Series) -&gt; pli.Series:
</code></pre>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">        def inspect(s: &quot;pli.Series&quot;) -&gt; &quot;pli.Series&quot;:
            print(fmt.format(s))  # type: ignore
            return s
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprinterpolate"><a class="header" href="#polarsinternalsexprexprinterpolate"><code>polars.internals.expr.Expr.interpolate</code></a></h3>
<pre><code class="language-python">interpolate() -&gt; Expr:
</code></pre>
<p>Interpolate intermediate values. The interpolation method is linear.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def interpolate(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Interpolate intermediate values. The interpolation method is linear.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.interpolate())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_min"><a class="header" href="#polarsinternalsexprexprrolling_min"><code>polars.internals.expr.Expr.rolling_min</code></a></h3>
<pre><code class="language-python">rolling_min(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>apply a rolling min (moving min) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_min(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        apply a rolling min (moving min) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_min(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_max"><a class="header" href="#polarsinternalsexprexprrolling_max"><code>polars.internals.expr.Expr.rolling_max</code></a></h3>
<pre><code class="language-python">rolling_max(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Apply a rolling max (moving max) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_max(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling max (moving max) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_max(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_mean"><a class="header" href="#polarsinternalsexprexprrolling_mean"><code>polars.internals.expr.Expr.rolling_mean</code></a></h3>
<pre><code class="language-python">rolling_mean(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Apply a rolling mean (moving mean) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0]
}
)
df.select([
pl.col(&quot;A&quot;).rolling_mean(window_size=2)
])
shape: (6, 1)
┌──────┐
│ A    │
│ ---  │
│ f64  │
╞══════╡
│ null │
├╌╌╌╌╌╌┤
│ 4.5  │
├╌╌╌╌╌╌┤
│ 7    │
├╌╌╌╌╌╌┤
│ 4    │
├╌╌╌╌╌╌┤
│ 9    │
├╌╌╌╌╌╌┤
│ 13   │
└──────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_mean(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling mean (moving mean) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window

        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 8.0, 6.0, 2.0, 16.0, 10.0]
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_mean(window_size=2)
        &gt;&gt;&gt; ])
        shape: (6, 1)
        ┌──────┐
        │ A    │
        │ ---  │
        │ f64  │
        ╞══════╡
        │ null │
        ├╌╌╌╌╌╌┤
        │ 4.5  │
        ├╌╌╌╌╌╌┤
        │ 7    │
        ├╌╌╌╌╌╌┤
        │ 4    │
        ├╌╌╌╌╌╌┤
        │ 9    │
        ├╌╌╌╌╌╌┤
        │ 13   │
        └──────┘

        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_mean(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_sum"><a class="header" href="#polarsinternalsexprexprrolling_sum"><code>polars.internals.expr.Expr.rolling_sum</code></a></h3>
<pre><code class="language-python">rolling_sum(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Apply a rolling sum (moving sum) over the values in this array.
A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length of the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_sum(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Apply a rolling sum (moving sum) over the values in this array.
        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length of the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_sum(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_std"><a class="header" href="#polarsinternalsexprexprrolling_std"><code>polars.internals.expr.Expr.rolling_std</code></a></h3>
<pre><code class="language-python">rolling_std(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Compute a rolling std dev</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_std(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling std dev

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_std(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_var"><a class="header" href="#polarsinternalsexprexprrolling_var"><code>polars.internals.expr.Expr.rolling_var</code></a></h3>
<pre><code class="language-python">rolling_var(window_size: int, 
    weights: Optionaltp.List[float], 
    min_periods: Optionalint, 
    center: bool,) -&gt; Expr:
</code></pre>
<p>Compute a rolling variance.</p>
<p>A window of length <code>window_size</code> will traverse the array. The values that fill this window
will (optionally) be multiplied with the weights given by the <code>weight</code> vector. The resultingParameters
values will be aggregated to their sum.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: The length of the window.</li>
<li>[<code>weights</code>]: An optional slice with the same length as the window that will be multiplied
elementwise with the values in the window.</li>
<li>[<code>min_periods</code>]: The number of values in the window that should be non-null before computing a result.
If None, it will be set equal to window size.</li>
<li>[<code>center</code>]: Set the labels at the center of the window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_var(
        self,
        window_size: int,
        weights: Optional[tp.List[float]] = None,
        min_periods: Optional[int] = None,
        center: bool = False,
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling variance.

        A window of length `window_size` will traverse the array. The values that fill this window
        will (optionally) be multiplied with the weights given by the `weight` vector. The resultingParameters
        values will be aggregated to their sum.

        Parameters
        ----------
        window_size
            The length of the window.
        weights
            An optional slice with the same length as the window that will be multiplied
            elementwise with the values in the window.
        min_periods
            The number of values in the window that should be non-null before computing a result.
            If None, it will be set equal to window size.
        center
            Set the labels at the center of the window
        &quot;&quot;&quot;
        if min_periods is None:
            min_periods = window_size
        return wrap_expr(
            self._pyexpr.rolling_var(window_size, weights, min_periods, center)
        )
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_apply"><a class="header" href="#polarsinternalsexprexprrolling_apply"><code>polars.internals.expr.Expr.rolling_apply</code></a></h3>
<pre><code class="language-python">rolling_apply(window_size: int, 
    function: Callable[[pli.Series], Any],) -&gt; Expr:
</code></pre>
<p>Allows a custom rolling window function.
Prefer the specific rolling window functions over this one, as they are faster.</p>
<p>Prefer:
* rolling_min
* rolling_max
* rolling_mean
* rolling_sum</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>function</code>]: Aggregation function</li>
</ul>
<p><strong>Examples:</strong></p>
<blockquote>
<blockquote>
<blockquote>
<p>df = pl.DataFrame(
{
&quot;A&quot;: [1.0, 2.0, 9.0, 2.0, 13.0],
}
)
df.select([
pl.col(&quot;A&quot;).rolling_apply(3, lambda s: s.std())
])
shape: (5, 1)
┌────────────────────┐
│ A                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ null               │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ null               │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4.358898943540674  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4.041451884327381  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5.5677643628300215 │
└────────────────────┘</p>
</blockquote>
</blockquote>
</blockquote>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_apply(
        self, window_size: int, function: Callable[[&quot;pli.Series&quot;], Any]
    ) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Allows a custom rolling window function.
        Prefer the specific rolling window functions over this one, as they are faster.

        Prefer:
            * rolling_min
            * rolling_max
            * rolling_mean
            * rolling_sum

        Parameters
        ----------
        window_size
            Size of the rolling window
        function
            Aggregation function


        Examples
        --------

        &gt;&gt;&gt; df = pl.DataFrame(
        &gt;&gt;&gt;     {
        &gt;&gt;&gt;         &quot;A&quot;: [1.0, 2.0, 9.0, 2.0, 13.0],
        &gt;&gt;&gt;     }
        &gt;&gt;&gt; )
        &gt;&gt;&gt; df.select([
        &gt;&gt;&gt;     pl.col(&quot;A&quot;).rolling_apply(3, lambda s: s.std())
        &gt;&gt;&gt; ])
        shape: (5, 1)
        ┌────────────────────┐
        │ A                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ null               │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.358898943540674  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 4.041451884327381  │
        ├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
        │ 5.5677643628300215 │
        └────────────────────┘

        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_apply(window_size, function))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_median"><a class="header" href="#polarsinternalsexprexprrolling_median"><code>polars.internals.expr.Expr.rolling_median</code></a></h3>
<pre><code class="language-python">rolling_median(window_size: int) -&gt; Expr:
</code></pre>
<p>Compute a rolling median</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_median(self, window_size: int) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling median

        Parameters
        ----------
        window_size
            Size of the rolling window
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_median(window_size))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_quantile"><a class="header" href="#polarsinternalsexprexprrolling_quantile"><code>polars.internals.expr.Expr.rolling_quantile</code></a></h3>
<pre><code class="language-python">rolling_quantile(window_size: int, 
    quantile: float,) -&gt; Expr:
</code></pre>
<p>Compute a rolling quantile</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>quantile</code>]: quantile to compute</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_quantile(self, window_size: int, quantile: float) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling quantile

        Parameters
        ----------
        window_size
            Size of the rolling window
        quantile
            quantile to compute
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_quantile(window_size, quantile))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrolling_skew"><a class="header" href="#polarsinternalsexprexprrolling_skew"><code>polars.internals.expr.Expr.rolling_skew</code></a></h3>
<pre><code class="language-python">rolling_skew(window_size: int, bias: bool) -&gt; Expr:
</code></pre>
<p>Compute a rolling skew</p>
<ul>
<li>[<code>window_size</code>]: Size of the rolling window</li>
<li>[<code>bias</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rolling_skew(self, window_size: int, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute a rolling skew
        window_size
            Size of the rolling window
        bias
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rolling_skew(window_size, bias))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprabs"><a class="header" href="#polarsinternalsexprexprabs"><code>polars.internals.expr.Expr.abs</code></a></h3>
<pre><code class="language-python">abs() -&gt; Expr:
</code></pre>
<p>Take absolute values</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def abs(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Take absolute values
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.abs())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprargsort"><a class="header" href="#polarsinternalsexprexprargsort"><code>polars.internals.expr.Expr.argsort</code></a></h3>
<pre><code class="language-python">argsort(reverse: bool) -&gt; Expr:
</code></pre>
<p>Index location of the sorted variant of this Series.
<strong>Parameters:</strong></p>
<ul>
<li>[<code>reverse</code>]: Reverse the ordering. Default is from low to high.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def argsort(self, reverse: bool = False) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Index location of the sorted variant of this Series.
        Parameters
        ----------
        reverse
            Reverse the ordering. Default is from low to high.
        &quot;&quot;&quot;
        return pli.argsort_by([self], [reverse])
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprrank"><a class="header" href="#polarsinternalsexprexprrank"><code>polars.internals.expr.Expr.rank</code></a></h3>
<pre><code class="language-python">rank(method: str) -&gt; Expr:
</code></pre>
<p>Assign ranks to data, dealing with ties appropriately.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>method</code>]: {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
The method used to assign ranks to tied elements.
The following methods are available (default is 'average'):
* 'average': The average of the ranks that would have been assigned to
all the tied values is assigned to each value.
* 'min': The minimum of the ranks that would have been assigned to all
the tied values is assigned to each value.  (This is also
referred to as &quot;competition&quot; ranking.)
* 'max': The maximum of the ranks that would have been assigned to all
the tied values is assigned to each value.
* 'dense': Like 'min', but the rank of the next highest element is</li>
<li>
<pre><code>* 'ordinal': All values are given a distinct rank, corresponding to
  the order that the values occur in `a`.
* 'random': Like 'ordinal', but the rank for ties is not dependent
  on the order that the values occur in `a`.
</code></pre>
</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def rank(self, method: str = &quot;average&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Assign ranks to data, dealing with ties appropriately.

        Parameters
        ----------
        method
            {'average', 'min', 'max', 'dense', 'ordinal', 'random'}, optional
            The method used to assign ranks to tied elements.
            The following methods are available (default is 'average'):
              * 'average': The average of the ranks that would have been assigned to
                all the tied values is assigned to each value.
              * 'min': The minimum of the ranks that would have been assigned to all
                the tied values is assigned to each value.  (This is also
                referred to as &quot;competition&quot; ranking.)
              * 'max': The maximum of the ranks that would have been assigned to all
                the tied values is assigned to each value.
              * 'dense': Like 'min', but the rank of the next highest element is
                assigned the rank immediately after those assigned to the tied
                elements.
              * 'ordinal': All values are given a distinct rank, corresponding to
                the order that the values occur in `a`.
              * 'random': Like 'ordinal', but the rank for ties is not dependent
                on the order that the values occur in `a`.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.rank(method))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprdiff"><a class="header" href="#polarsinternalsexprexprdiff"><code>polars.internals.expr.Expr.diff</code></a></h3>
<pre><code class="language-python">diff(n: int, null_behavior: str) -&gt; Expr:
</code></pre>
<p>Calculate the n-th discrete difference.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>n</code>]: number of slots to shift</li>
<li>[<code>null_behavior</code>]: {'ignore', 'drop'}</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def diff(self, n: int = 1, null_behavior: str = &quot;ignore&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Calculate the n-th discrete difference.

        Parameters
        ----------
        n
            number of slots to shift
        null_behavior
            {'ignore', 'drop'}
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.diff(n, null_behavior))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprskew"><a class="header" href="#polarsinternalsexprexprskew"><code>polars.internals.expr.Expr.skew</code></a></h3>
<pre><code class="language-python">skew(bias: bool) -&gt; Expr:
</code></pre>
<p>Compute the sample skewness of a data set.
For normally distributed data, the skewness should be about zero. For
unimodal continuous distributions, a skewness value greater than zero means
that there is more weight in the right tail of the distribution. The
function <code>skewtest</code> can be used to determine if the skewness value
is close enough to zero, statistically speaking.</p>
<p>See scipy.stats for more information.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p><strong>Notes:</strong></p>
<p>The sample skewness is computed as the Fisher-Pearson coefficient
of skewness, i.e.
.. math::
g_1=\frac{m_3}{m_2^{3/2}}
where
.. math::
m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
is the biased sample :math:<code>i\texttt{th}</code> central moment, and
:math:<code>\bar{x}</code> is
the sample mean.  If <code>bias</code> is False, the calculations are
corrected for bias and the value computed is the adjusted
Fisher-Pearson standardized moment coefficient, i.e.
.. math::
G_1=\frac{k_3}{k_2^{3/2}}=
\frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def skew(self, bias: bool = True) -&gt; &quot;Expr&quot;:
        r&quot;&quot;&quot;Compute the sample skewness of a data set.
        For normally distributed data, the skewness should be about zero. For
        unimodal continuous distributions, a skewness value greater than zero means
        that there is more weight in the right tail of the distribution. The
        function `skewtest` can be used to determine if the skewness value
        is close enough to zero, statistically speaking.


        See scipy.stats for more information.

        Parameters
        ----------
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.

        Notes
        -----
        The sample skewness is computed as the Fisher-Pearson coefficient
        of skewness, i.e.
        .. math::
            g_1=\frac{m_3}{m_2^{3/2}}
        where
        .. math::
            m_i=\frac{1}{N}\sum_{n=1}^N(x[n]-\bar{x})^i
        is the biased sample :math:`i\texttt{th}` central moment, and
        :math:`\bar{x}` is
        the sample mean.  If ``bias`` is False, the calculations are
        corrected for bias and the value computed is the adjusted
        Fisher-Pearson standardized moment coefficient, i.e.
        .. math::
            G_1=\frac{k_3}{k_2^{3/2}}=
                \frac{\sqrt{N(N-1)}}{N-2}\frac{m_3}{m_2^{3/2}}.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.skew(bias))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprkurtosis"><a class="header" href="#polarsinternalsexprexprkurtosis"><code>polars.internals.expr.Expr.kurtosis</code></a></h3>
<pre><code class="language-python">kurtosis(fisher: bool, bias: bool) -&gt; Expr:
</code></pre>
<p>Compute the kurtosis (Fisher or Pearson) of a dataset.
Kurtosis is the fourth central moment divided by the square of the
variance. If Fisher's definition is used, then 3.0 is subtracted from
the result to give 0.0 for a normal distribution.
If bias is False then the kurtosis is calculated using k statistics to
eliminate bias coming from biased moment estimators</p>
<p>See scipy.stats for more information</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fisher</code> [<code>bool, optional</code>]: If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
Pearson's definition is used (normal ==&gt; 3.0).</li>
<li><code>bias</code> [<code>bool, optional</code>]: If False, then the calculations are corrected for statistical bias.</li>
</ul>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def kurtosis(self, fisher: bool = True, bias: bool = True) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;Compute the kurtosis (Fisher or Pearson) of a dataset.
        Kurtosis is the fourth central moment divided by the square of the
        variance. If Fisher's definition is used, then 3.0 is subtracted from
        the result to give 0.0 for a normal distribution.
        If bias is False then the kurtosis is calculated using k statistics to
        eliminate bias coming from biased moment estimators

        See scipy.stats for more information

        Parameters
        ----------
        fisher : bool, optional
            If True, Fisher's definition is used (normal ==&gt; 0.0). If False,
            Pearson's definition is used (normal ==&gt; 3.0).
        bias : bool, optional
            If False, then the calculations are corrected for statistical bias.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.kurtosis(fisher, bias))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprclip"><a class="header" href="#polarsinternalsexprexprclip"><code>polars.internals.expr.Expr.clip</code></a></h3>
<pre><code class="language-python">clip(min_val: Union[int, float], 
    max_val: Union[int, float],) -&gt; Expr:
</code></pre>
<p>Clip (limit) the values in an array.</p>
<p><strong>Parameters:</strong></p>
<p>min_val, max_val
Minimum and maximum value.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def clip(self, min_val: Union[int, float], max_val: Union[int, float]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Clip (limit) the values in an array.

        Parameters
        ----------
        min_val, max_val
            Minimum and maximum value.
        &quot;&quot;&quot;
        min_val = pli.lit(min_val)  # type: ignore
        max_val = pli.lit(max_val)  # type: ignore

        return (
            pli.when(self &lt; min_val)  # type: ignore
            .then(min_val)
            .when(self &gt; max_val)
            .then(max_val)
            .otherwise(self)
        ).keep_name()
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprlower_bound"><a class="header" href="#polarsinternalsexprexprlower_bound"><code>polars.internals.expr.Expr.lower_bound</code></a></h3>
<pre><code class="language-python">lower_bound() -&gt; Expr:
</code></pre>
<p>Returns a unit Series with the lowest value possible for the dtype of this expression.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def lower_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the lowest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.lower_bound())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprupper_bound"><a class="header" href="#polarsinternalsexprexprupper_bound"><code>polars.internals.expr.Expr.upper_bound</code></a></h3>
<pre><code class="language-python">upper_bound() -&gt; Expr:
</code></pre>
<p>Returns a unit Series with the highest value possible for the dtype of this expression.</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def upper_bound(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Returns a unit Series with the highest value possible for the dtype of this expression.
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.upper_bound())
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprstr_concat"><a class="header" href="#polarsinternalsexprexprstr_concat"><code>polars.internals.expr.Expr.str_concat</code></a></h3>
<pre><code class="language-python">str_concat(delimiter: str) -&gt; Expr:
</code></pre>
<p>Vertically concat the values in the Series to a single string value.</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Utf8</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, None, 2]})
&gt;&gt;&gt; df = df.select(pl.col(&quot;foo&quot;).str_concat(&quot;-&quot;))
shape: (1, 1)
┌──────────┐
│ foo      │
│ ---      │
│ str      │
╞══════════╡
│ 1-null-2 │
└──────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def str_concat(self, delimiter: str = &quot;-&quot;) -&gt; &quot;Expr&quot;:  # type: ignore
        &quot;&quot;&quot;
        Vertically concat the values in the Series to a single string value.

        Returns
        -------
        Series of dtype Utf8

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;foo&quot;: [1, None, 2]})
        &gt;&gt;&gt; df = df.select(pl.col(&quot;foo&quot;).str_concat(&quot;-&quot;))
        shape: (1, 1)
        ┌──────────┐
        │ foo      │
        │ ---      │
        │ str      │
        ╞══════════╡
        │ 1-null-2 │
        └──────────┘
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.str_concat(delimiter))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprsin"><a class="header" href="#polarsinternalsexprexprsin"><code>polars.internals.expr.Expr.sin</code></a></h3>
<pre><code class="language-python">sin() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric sine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).sin())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 0.8414709848078965 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def sin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).sin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.8414709848078965 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.sin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprcos"><a class="header" href="#polarsinternalsexprexprcos"><code>polars.internals.expr.Expr.cos</code></a></h3>
<pre><code class="language-python">cos() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric cosine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).cos())
shape: (1, 1)
┌─────┐
│ a   │
│ --- │
│ f64 │
╞═════╡
│ 1   │
└─────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def cos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).cos())
        shape: (1, 1)
        ┌─────┐
        │ a   │
        │ --- │
        │ f64 │
        ╞═════╡
        │ 1   │
        └─────┘
        &quot;&quot;&quot;
        return np.cos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprtan"><a class="header" href="#polarsinternalsexprexprtan"><code>polars.internals.expr.Expr.tan</code></a></h3>
<pre><code class="language-python">tan() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric tangent on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).tan())
shape: (1, 1)
┌───────────────────┐
│ a                 │
│ ---               │
│ f64               │
╞═══════════════════╡
│ 1.557407724654902 │
└───────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def tan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).tan())
        shape: (1, 1)
        ┌───────────────────┐
        │ a                 │
        │ ---               │
        │ f64               │
        ╞═══════════════════╡
        │ 1.557407724654902 │
        └───────────────────┘
        &quot;&quot;&quot;
        return np.tan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarcsin"><a class="header" href="#polarsinternalsexprexprarcsin"><code>polars.internals.expr.Expr.arcsin</code></a></h3>
<pre><code class="language-python">arcsin() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric sine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arcsin())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 1.5707963267948966 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arcsin(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric sine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arcsin())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arcsin(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarccos"><a class="header" href="#polarsinternalsexprexprarccos"><code>polars.internals.expr.Expr.arccos</code></a></h3>
<pre><code class="language-python">arccos() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric cosine on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arccos())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 1.5707963267948966 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arccos(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric cosine on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [0.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arccos())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 1.5707963267948966 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arccos(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprarctan"><a class="header" href="#polarsinternalsexprexprarctan"><code>polars.internals.expr.Expr.arctan</code></a></h3>
<pre><code class="language-python">arctan() -&gt; Expr:
</code></pre>
<p>Compute the element-wise value for Trigonometric tangent on an array</p>
<p><strong>Returns:</strong></p>
<p>Series of dtype Float64</p>
<p>Examples
&gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
&gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arctan())
shape: (1, 1)
┌────────────────────┐
│ a                  │
│ ---                │
│ f64                │
╞════════════════════╡
│ 0.7853981633974483 │
└────────────────────┘</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def arctan(self) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Compute the element-wise value for Trigonometric tangent on an array

        Returns
        -------
        Series of dtype Float64

        Examples
        &gt;&gt;&gt; df = pl.DataFrame({&quot;a&quot;: [1.0]})
        &gt;&gt;&gt; df.select(pl.col(&quot;a&quot;).arctan())
        shape: (1, 1)
        ┌────────────────────┐
        │ a                  │
        │ ---                │
        │ f64                │
        ╞════════════════════╡
        │ 0.7853981633974483 │
        └────────────────────┘
        &quot;&quot;&quot;
        return np.arctan(self)  # type: ignore
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
<div class='function-wrap'></raw></p>
<h3 id="polarsinternalsexprexprreshape"><a class="header" href="#polarsinternalsexprexprreshape"><code>polars.internals.expr.Expr.reshape</code></a></h3>
<pre><code class="language-python">reshape(dims: tp.Tuple[int, ]) -&gt; Expr:
</code></pre>
<p>Reshape this Expr to a flat series, shape: (len,)
or a List series, shape: (rows, cols)</p>
<p>if a -1 is used in any of the dimensions, that dimension is inferred.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li>[<code>dims</code>]: Tuple of the dimension sizes</li>
</ul>
<p><strong>Returns:</strong></p>
<p>Expr</p>
<p>
<details>
  <summary style="text-align:right">source</summary>
</raw></p>
<pre><code class="language-python">    def reshape(self, dims: tp.Tuple[int, ...]) -&gt; &quot;Expr&quot;:
        &quot;&quot;&quot;
        Reshape this Expr to a flat series, shape: (len,)
        or a List series, shape: (rows, cols)

        if a -1 is used in any of the dimensions, that dimension is inferred.

        Parameters
        ----------
        dims
            Tuple of the dimension sizes

        Returns
        -------
        Expr
        &quot;&quot;&quot;
        return wrap_expr(self._pyexpr.reshape(dims))
</code></pre>
<p>
</details>
</raw></p>
<p></div></raw>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../../../polars/internals/expr.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../../../polars/internals/expr/ExprListNameSpace.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../../../polars/internals/expr.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../../../polars/internals/expr/ExprListNameSpace.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../../../theme/js/index.js"></script>
        

        

    </body>
</html>
