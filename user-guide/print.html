<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Polars - User Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quickstart/intro.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="dsl/intro.html"><strong aria-hidden="true">3.</strong> Polars expressions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dsl/intro.html"><strong aria-hidden="true">3.1.</strong> Expressions</a></li><li class="chapter-item "><a href="dsl/contexts.html"><strong aria-hidden="true">3.2.</strong> Contexts</a></li><li class="chapter-item "><a href="dsl/groupby.html"><strong aria-hidden="true">3.3.</strong> GroupBy</a></li><li class="chapter-item "><a href="dsl/folds.html"><strong aria-hidden="true">3.4.</strong> Folds</a></li><li class="chapter-item "><a href="dsl/window_functions.html"><strong aria-hidden="true">3.5.</strong> Window functions</a></li><li class="chapter-item "><a href="dsl/numpy.html"><strong aria-hidden="true">3.6.</strong> Numpy universal functions</a></li><li class="chapter-item "><a href="notebooks/introduction_polars.html"><strong aria-hidden="true">3.7.</strong> Examples</a></li><li class="chapter-item "><a href="dsl/api.html"><strong aria-hidden="true">3.8.</strong> API</a></li></ol></li><li class="chapter-item expanded "><a href="indexing.html"><strong aria-hidden="true">4.</strong> Indexing</a></li><li class="chapter-item expanded "><a href="datatypes.html"><strong aria-hidden="true">5.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="coming_from_pandas.html"><strong aria-hidden="true">6.</strong> Coming from Pandas</a></li><li class="chapter-item expanded "><a href="howcani/intro.html"><strong aria-hidden="true">7.</strong> How can I?</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howcani/df/intro.html"><strong aria-hidden="true">7.1.</strong> Manipulate a DataFrame</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howcani/df/common-manipulations.html"><strong aria-hidden="true">7.1.1.</strong> Common manipulations</a></li><li class="chapter-item "><a href="howcani/df/row_col_selection.html"><strong aria-hidden="true">7.1.2.</strong> Row and column selection</a></li><li class="chapter-item "><a href="howcani/df/filter.html"><strong aria-hidden="true">7.1.3.</strong> Filter</a></li><li class="chapter-item "><a href="howcani/df/sorting.html"><strong aria-hidden="true">7.1.4.</strong> Sorting</a></li><li class="chapter-item "><a href="howcani/df/groupby.html"><strong aria-hidden="true">7.1.5.</strong> GroupBy</a></li><li class="chapter-item "><a href="howcani/df/join.html"><strong aria-hidden="true">7.1.6.</strong> Join DataFrames</a></li><li class="chapter-item "><a href="howcani/df/aggregate.html"><strong aria-hidden="true">7.1.7.</strong> Aggregate</a></li><li class="chapter-item "><a href="howcani/df/conditionally-apply.html"><strong aria-hidden="true">7.1.8.</strong> Conditionally apply</a></li><li class="chapter-item "><a href="howcani/df/melt.html"><strong aria-hidden="true">7.1.9.</strong> Melt</a></li><li class="chapter-item "><a href="howcani/df/pivot.html"><strong aria-hidden="true">7.1.10.</strong> Pivot</a></li></ol></li><li class="chapter-item "><a href="howcani/io/intro.html"><strong aria-hidden="true">7.2.</strong> IO</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howcani/io/csv.html"><strong aria-hidden="true">7.2.1.</strong> CSV files</a></li><li class="chapter-item "><a href="howcani/io/parquet.html"><strong aria-hidden="true">7.2.2.</strong> Parquet files</a></li><li class="chapter-item "><a href="howcani/io/read_db.html"><strong aria-hidden="true">7.2.3.</strong> Read from a database</a></li><li class="chapter-item "><a href="howcani/io/aws.html"><strong aria-hidden="true">7.2.4.</strong> Interact with AWS</a></li><li class="chapter-item "><a href="howcani/io/google-big-query.html"><strong aria-hidden="true">7.2.5.</strong> Interact with Google BigQuery</a></li><li class="chapter-item "><a href="howcani/io/postgres.html"><strong aria-hidden="true">7.2.6.</strong> Interact with Postgres</a></li></ol></li><li class="chapter-item "><a href="howcani/interop/intro.html"><strong aria-hidden="true">7.3.</strong> Interoperability</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howcani/interop/arrow.html"><strong aria-hidden="true">7.3.1.</strong> Arrow</a></li><li class="chapter-item "><a href="howcani/interop/numpy.html"><strong aria-hidden="true">7.3.2.</strong> NumPy</a></li></ol></li><li class="chapter-item "><a href="howcani/data/intro.html"><strong aria-hidden="true">7.4.</strong> Data handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howcani/data/strings.html"><strong aria-hidden="true">7.4.1.</strong> Process strings</a></li><li class="chapter-item "><a href="howcani/data/timestamps.html"><strong aria-hidden="true">7.4.2.</strong> Process timestamps</a></li></ol></li><li class="chapter-item "><a href="howcani/apply/intro.html"><strong aria-hidden="true">7.5.</strong> Apply</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="howcani/apply/udfs.html"><strong aria-hidden="true">7.5.1.</strong> Use custom functions</a></li><li class="chapter-item "><a href="howcani/apply/window-functions.html"><strong aria-hidden="true">7.5.2.</strong> Apply window functions</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="performance/intro.html"><strong aria-hidden="true">8.</strong> Performance</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="performance/strings.html"><strong aria-hidden="true">8.1.</strong> Strings</a></li></ol></li><li class="chapter-item expanded "><a href="optimizations/intro.html"><strong aria-hidden="true">9.</strong> Optimizations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="optimizations/lazy/intro.html"><strong aria-hidden="true">9.1.</strong> Lazy API</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="optimizations/lazy/predicate-pushdown.html"><strong aria-hidden="true">9.1.1.</strong> Predicate pushdown</a></li><li class="chapter-item "><a href="optimizations/lazy/projection-pushdown.html"><strong aria-hidden="true">9.1.2.</strong> Projection pushdown</a></li><li class="chapter-item "><a href="optimizations/lazy/other-optimizations.html"><strong aria-hidden="true">9.1.3.</strong> Other optimizations</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">10.</strong> Reference guides</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Polars - User Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="margin: 30px auto; background-color: white; border-radius: 50%; width: 200px; height: 200px;"><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/logos/polars-logo-dark.svg" alt="Polars logo" style="width: 168px; height: 168px; padding: 10px 20px;"></div>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is an introduction to the
<a href="https://github.com/pola-rs/polars"><code>Polars</code> DataFrame library</a>. Its goal is to
explain the inner workings of <code>Polars</code> by going through examples and comparing it to other
solutions. Some design choices are introduced here, and the optimal use of <code>Polars</code>
described.</p>
<p>Even though <code>Polars</code> is completely written in <a href="https://www.rust-lang.org/"><code>Rust</code></a> (no
runtime overhead!) and uses <a href="https://arrow.apache.org/"><code>Arrow</code></a> -the
<a href="https://docs.rs/crate/arrow/3.0.0">native <code>Rust</code> implementation</a>- at its foundation, the
examples presented in this guide will be mostly using its higher-level language
bindings. The latter are merely a thin wrapper that will not offer more
functionalities than the core library does.</p>
<p>For people used to <a href="https://pandas.pydata.org/"><code>Pandas</code></a>, the
<a href="https://www.python.org/"><code>Python</code></a> bindings are the easiest to get started with
<code>Polars</code>, allowing easier experimentation.</p>
<h2 id="goals-and-non-goals"><a class="header" href="#goals-and-non-goals">Goals and non-goals</a></h2>
<p>The goal of <code>Polars</code> is being a lightning fast DataFrame library that utilizes all
available cores on your machine.</p>
<p><code>Polars</code> is semi-lazy. It allows you to do most of your work eagerly, similar to <code>pandas</code>, but
it does provide you with a powerful expression syntax that will be optimized and executed on polars' query engine.</p>
<p><code>Polars</code> also supports full lazy query execution that allows for more query optimization.</p>
<p><code>Polars</code> keeps track of your query in a <em>logical plan</em>. This
plan is optimized and reordered before running it. When a result is requested <code>Polars</code>
distributes the available work to different <em>executors</em> that use the algorithms available
in the eager API to come up with the result. Because the whole query context is known to
the optimizer and executors of the logical plan, processes dependent on separate data
sources can be parallelized on the fly.</p>
<p><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/docs/api.svg" alt="" /></p>
<h3 id="performance-"><a class="header" href="#performance-">Performance 🚀🚀</a></h3>
<p>Polars is very fast, and in fact is one of the best performing solutions available.
See the results in h2oai's db-benchmark. The image below shows the biggest datasets yielding a result.</p>
<p><img src="https://www.ritchievink.com/img/post-35-polars-0.15/db-benchmark.png" alt="" /></p>
<h3 id="current-status"><a class="header" href="#current-status">Current status</a></h3>
<p>Below a concise list of the features allowing <code>Polars</code> to meet its goals:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Copy-on-write">Copy-on-write</a> (COW) semantics
<ul>
<li>&quot;Free&quot; clones</li>
<li>Cheap appends</li>
</ul>
</li>
<li>Appending without clones</li>
<li>Column oriented data storage
<ul>
<li>No block manager (-i.e.- predictable performance)</li>
</ul>
</li>
<li>Missing values indicated with bitmask
<ul>
<li>NaN are different from missing</li>
<li>Bitmask optimizations</li>
</ul>
</li>
<li>Efficient algorithms</li>
<li><a href="optimizations/lazy/intro.html">Query optimizations</a>
<ul>
<li>Predicate pushdown
<ul>
<li>Filtering at scan level</li>
</ul>
</li>
<li>Projection pushdown
<ul>
<li>Projection at scan level</li>
</ul>
</li>
<li>Simplify expressions</li>
<li>Parallel execution of physical plan</li>
</ul>
</li>
<li>SIMD vectorization</li>
<li><a href="https://numpy.org/doc/stable/reference/ufuncs.html"><code>NumPy</code> universal functions</a></li>
</ul>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>Development of <code>Polars</code> is proudly powered by</p>
<p><a href="https://www.xomnia.com"><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/sponsors/xomnia.png" alt="Xomnia" /></a></p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Installing <code>Polars</code> is just a simple <code>pip install</code> away.</p>
<pre><code class="language-shell">$ pip install polars
</code></pre>
<p>All binaries are pre-built for <code>Python</code> v3.6+.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick start</a></h2>
<p>Below we show a simple snippet that parses a CSV file, filters it, and finishes with a
groupby operation. As mentioned before the eager API must feel very similar to users
familiar to <code>Pandas</code>. The lazy API is more declarative, and describes <em>what one wants</em>
instead of <em>how one wants it</em>.</p>
<pre><code class="language-python">import polars as pl
</code></pre>
<h3 id="eager-quickstart"><a class="header" href="#eager-quickstart">Eager quickstart</a></h3>
<pre><code class="language-python">df = pl.read_csv(&quot;https://j.mp/iriscsv&quot;)
df = (df.filter(pl.col(&quot;sepal_length&quot;) &gt; 5)
      .groupby(&quot;species&quot;)
      .sum())
</code></pre>
<h3 id="lazy-quickstart"><a class="header" href="#lazy-quickstart">Lazy quickstart</a></h3>
<pre><code class="language-python">q = (
    pl.scan_csv(&quot;iris.csv&quot;)
    .filter(pl.col(&quot;sepal_length&quot;) &gt; 5)
    .groupby(&quot;species&quot;)
    .agg(pl.col(&quot;*&quot;).sum())
)
df = q.collect()
</code></pre>
<p>In both cases, the snippet will output:</p>
<pre><code class="language-text">shape: (3, 5)
╭──────────────┬──────────────────┬─────────────────┬──────────────────┬─────────────────╮
│ species      ┆ sepal_length_sum ┆ sepal_width_sum ┆ petal_length_sum ┆ petal_width_sum │
│ ---          ┆ ---              ┆ ---             ┆ ---              ┆ ---             │
│ str          ┆ f64              ┆ f64             ┆ f64              ┆ f64             │
╞══════════════╪══════════════════╪═════════════════╪══════════════════╪═════════════════╡
│ &quot;virginica&quot;  ┆ 324.5            ┆ 146.2           ┆ 273.1            ┆ 99.6            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;versicolor&quot; ┆ 281.9            ┆ 131.8           ┆ 202.9            ┆ 63.3            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;setosa&quot;     ┆ 116.9            ┆ 81.7            ┆ 33.2             ┆ 6.1             │
╰──────────────┴──────────────────┴─────────────────┴──────────────────┴─────────────────╯
</code></pre>
<p>As we can see, <code>Polars</code> pretty-prints the output object, including the column name and
datatype as headers.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>If you want to dive right into the <code>Python</code> API docs, refer to
<a href="https://pola-rs.github.io/polars/py-polars/html/reference">the index</a> or follow one of the following direct links:</p>
<h3 id="eager-api"><a class="header" href="#eager-api">Eager API</a></h3>
<p>In the eager API, Operations are
executed directly in an imperative manner. The important data structures are the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/dataframe.html"><code>DataFrame</code></a> and the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/series.html"><code>Series</code></a></p>
<h3 id="lazy-api"><a class="header" href="#lazy-api">Lazy API</a></h3>
<p>The lazy API builds a query plan. Nothing is executed until you explicitly ask <code>Polars</code>
to execute the query (via <code>LazyFrame.collect()</code>, or <code>LazyFrame.fetch()</code>). This provides
<code>Polars</code> with the entire context of the query, allowing optimizations and choosing the
fastest algorithm given that context.</p>
<p>The important data structure is here the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe.html"><code>LazyFrame</code></a>, a <code>DataFrame</code>
abstraction lazily keeping track of the query plan.</p>
<p>Arguments given to a <code>LazyFrame</code> can be constructed by building simple to complex
queries following the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/expression.html"><code>Expr</code> API</a>. See the examples in
the <a href="quickstart//dsl/intro.html">Expressions?</a> section of the guide.</p>
<h1 id="polars-expressions"><a class="header" href="#polars-expressions">Polars Expressions</a></h1>
<p>Polars has a powerful concept called expressions. Polars expressions can be used in
various contexts and produce Series. That may sound a bit strange, so lets give an
example.</p>
<p>The following is an expression:</p>
<p><code>pl.col(&quot;foo&quot;).sort().head(2)</code></p>
<p>The snippet above says on <code>select column &quot;foo&quot; -&gt; sort -&gt; take first 2 values</code>. The
power of expressions is that every expression produces a new expression and that they
can be <code>piped</code> together. Besides, being very expressive, they are also <strong>embarrassingly
parallel</strong>!</p>
<h2 id="expression-examples"><a class="header" href="#expression-examples">Expression examples</a></h2>
<p>In this section we will go through some examples, but first let's create a dataset:</p>
<pre><code class="language-python">import polars as pl
import numpy as np

np.random.seed(12)

df = pl.DataFrame(
    {
        &quot;nrs&quot;: [1, 2, 3, None, 5],
        &quot;names&quot;: [&quot;foo&quot;, &quot;ham&quot;, &quot;spam&quot;, &quot;egg&quot;, None],
        &quot;random&quot;: np.random.rand(5),
        &quot;groups&quot;: [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;],
    }
)
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌──────┬───────┬──────────────────────┬────────┐
│ nrs  ┆ names ┆ random               ┆ groups │
│ ---  ┆ ---   ┆ ---                  ┆ ---    │
│ i64  ┆ str   ┆ f64                  ┆ str    │
╞══════╪═══════╪══════════════════════╪════════╡
│ 1    ┆ foo   ┆ 0.15416284237967237  ┆ A      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2    ┆ ham   ┆ 0.7400496965154048   ┆ A      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3    ┆ spam  ┆ 0.26331501518513467  ┆ B      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ null ┆ egg   ┆ 0.5337393933802977   ┆ C      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 5    ┆ null  ┆ 0.014574962485419674 ┆ B      │
└──────┴───────┴──────────────────────┴────────┘
</code></pre>
<p>You can do a lot with expressions. They are so expressive that you sometimes have
multiple ways to get the same results. To get a feel for them let's go through some
examples.</p>
<h3 id="count-unique-values"><a class="header" href="#count-unique-values">Count unique values</a></h3>
<p>We can count the unique values in a column. Note that we are creating the same result in
different ways. To not have duplicate column names in the <code>DataFrame</code>, we use an
<code>alias</code> expression, which renames an expression.</p>
<pre><code class="language-python">df = df[
    [
        pl.col(&quot;names&quot;).n_unique().alias(&quot;unique_names_1&quot;),
        pl.col(&quot;names&quot;).unique().count().alias(&quot;unique_names_2&quot;),
    ]
]
print(df)
</code></pre>
<pre><code class="language-text">shape: (1, 2)
┌────────────────┬────────────────┐
│ unique_names_1 ┆ unique_names_2 │
│ ---            ┆ ---            │
│ u32            ┆ u32            │
╞════════════════╪════════════════╡
│ 5              ┆ 5              │
└────────────────┴────────────────┘
</code></pre>
<h3 id="various-aggregations"><a class="header" href="#various-aggregations">Various aggregations</a></h3>
<p>We can do various aggregations. Below we show some of them, but there are more, such as
<code>median</code>, <code>mean</code>, <code>first</code>, etc.</p>
<pre><code class="language-python">df = df[
    [
        pl.sum(&quot;random&quot;).alias(&quot;sum&quot;),
        pl.min(&quot;random&quot;).alias(&quot;min&quot;),
        pl.max(&quot;random&quot;).alias(&quot;max&quot;),
        pl.col(&quot;random&quot;).max().alias(&quot;other_max&quot;),
        pl.std(&quot;random&quot;).alias(&quot;std dev&quot;),
        pl.var(&quot;random&quot;).alias(&quot;variance&quot;),
    ]
]
print(df)
</code></pre>
<pre><code class="language-text">shape: (1, 6)
┌────────────────┬────────────────┬────────────────┬───────────────┬───────────────┬───────────────┐
│ sum            ┆ min            ┆ max            ┆ other_max     ┆ std dev       ┆ variance      │
│ ---            ┆ ---            ┆ ---            ┆ ---           ┆ ---           ┆ ---           │
│ f64            ┆ f64            ┆ f64            ┆ f64           ┆ f64           ┆ f64           │
╞════════════════╪════════════════╪════════════════╪═══════════════╪═══════════════╪═══════════════╡
│ 1.705841909945 ┆ 0.014574962485 ┆ 0.740049696515 ┆ 0.74004969651 ┆ 0.29320870456 ┆ 0.08597134443 │
│ 9292           ┆ 419674         ┆ 4048           ┆ 54048         ┆ 7623          ┆ 422363        │
└────────────────┴────────────────┴────────────────┴───────────────┴───────────────┴───────────────┘
</code></pre>
<h3 id="filter-and-conditionals"><a class="header" href="#filter-and-conditionals">Filter and conditionals</a></h3>
<p>We can also do some pretty complex things. In the next snippet we count all names ending
with the string <code>&quot;am&quot;</code>.</p>
<pre><code class="language-python">df = df[[pl.col(&quot;names&quot;).filter(pl.col(&quot;names&quot;).str.contains(r&quot;am$&quot;)).count()]]
print(df)
</code></pre>
<pre><code class="language-text">shape: (1, 1)
┌───────┐
│ names │
│ ---   │
│ u32   │
╞═══════╡
│ 2     │
└───────┘
</code></pre>
<h3 id="binary-functions-and-modification"><a class="header" href="#binary-functions-and-modification">Binary functions and modification</a></h3>
<p>In the example below we use a conditional to create a new expression in the following
<code>when -&gt; then -&gt; otherwise</code> construct. The <code>when()</code> function requires a predicate
expression (and thus leads to a <code>boolean</code> <code>Series</code>), the <code>then</code> expects an
expression that will be used in case the predicate evaluates <code>true</code>, and the <code>otherwise</code>
expects an expression that will be used in case the predicate evaluates <code>false</code>.</p>
<p>Note that you can pass any expression, or just base expressions like <code>pl.col(&quot;foo&quot;)</code>,
<code>pl.lit(3)</code>, <code>pl.lit(&quot;bar&quot;)</code>, etc.</p>
<p>Finally, we multiply this with result of a sum expression.</p>
<pre><code class="language-python">df = df[[pl.when(pl.col(&quot;random&quot;) &gt; 0.5).then(0).otherwise(pl.col(&quot;random&quot;)) * pl.sum(&quot;nrs&quot;)]]
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 1)
┌────────────────────┐
│ literal            │
│ ---                │
│ f64                │
╞════════════════════╡
│ 1.695791266176396  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.0                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2.8964651670364816 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.0                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.1603245873396164 │
└────────────────────┘
</code></pre>
<h3 id="window-expressions-split-apply-combine"><a class="header" href="#window-expressions-split-apply-combine">Window expressions (split-apply-combine)</a></h3>
<p>A polars expression can also do an implicit GROUPBY, AGGREGATION, and JOIN in a single expression.
In the examples below we do a GROUPBY OVER <code>&quot;groups&quot;</code> and AGGREGATE SUM of <code>&quot;random&quot;</code>, and in the next expression
we GROUPBY OVER <code>&quot;names&quot;</code> and AGGREGATE a LIST of <code>&quot;random&quot;</code>. These window functions can be combined with other expressions,
and are an efficient way to determine group statistics. See more of those <a href="https://pola-rs.github.io/polars/py-polars/html/reference/expression.html#aggregation">group statistics here</a>.</p>
<pre><code class="language-python">df = df[
    [
        pl.col(&quot;*&quot;),  # select all
        pl.col(&quot;random&quot;).sum().over(&quot;groups&quot;).alias(&quot;sum[random]/groups&quot;),
        pl.col(&quot;random&quot;).list().over(&quot;names&quot;).alias(&quot;random/name&quot;),
    ]
]
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 6)
┌──────┬───────┬──────────────────────┬────────┬─────────────────────┬────────────────────────┐
│ nrs  ┆ names ┆ random               ┆ groups ┆ sum[random]/groups  ┆ random/name            │
│ ---  ┆ ---   ┆ ---                  ┆ ---    ┆ ---                 ┆ ---                    │
│ i64  ┆ str   ┆ f64                  ┆ str    ┆ f64                 ┆ list [f64]             │
╞══════╪═══════╪══════════════════════╪════════╪═════════════════════╪════════════════════════╡
│ 1    ┆ foo   ┆ 0.15416284237967237  ┆ A      ┆ 0.8942125388950771  ┆ [0.15416284237967237]  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2    ┆ ham   ┆ 0.7400496965154048   ┆ A      ┆ 0.8942125388950771  ┆ [0.7400496965154048]   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3    ┆ spam  ┆ 0.26331501518513467  ┆ B      ┆ 0.27788997767055434 ┆ [0.26331501518513467]  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ null ┆ egg   ┆ 0.5337393933802977   ┆ C      ┆ 0.5337393933802977  ┆ [0.5337393933802977]   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5    ┆ null  ┆ 0.014574962485419674 ┆ B      ┆ 0.27788997767055434 ┆ [0.014574962485419674] │
└──────┴───────┴──────────────────────┴────────┴─────────────────────┴────────────────────────┘
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This is the tip of the iceberg in terms of possible expressions, there are a ton more, and they
can be combined in myriad ways.</p>
<p>This page was an introduction to Polars expressions and gave a glimpse of what's
possible with them. In the next page, we see in which contexts we can use expressions. And later we'll go through expressions
in various groupby contexts and by doing that keep Polars execution parallel.</p>
<h1 id="polars-expressions-1"><a class="header" href="#polars-expressions-1">Polars Expressions</a></h1>
<p>Polars has a powerful concept called expressions. Polars expressions can be used in
various contexts and produce Series. That may sound a bit strange, so lets give an
example.</p>
<p>The following is an expression:</p>
<p><code>pl.col(&quot;foo&quot;).sort().head(2)</code></p>
<p>The snippet above says on <code>select column &quot;foo&quot; -&gt; sort -&gt; take first 2 values</code>. The
power of expressions is that every expression produces a new expression and that they
can be <code>piped</code> together. Besides, being very expressive, they are also <strong>embarrassingly
parallel</strong>!</p>
<h2 id="expression-examples-1"><a class="header" href="#expression-examples-1">Expression examples</a></h2>
<p>In this section we will go through some examples, but first let's create a dataset:</p>
<pre><code class="language-python">import polars as pl
import numpy as np

np.random.seed(12)

df = pl.DataFrame(
    {
        &quot;nrs&quot;: [1, 2, 3, None, 5],
        &quot;names&quot;: [&quot;foo&quot;, &quot;ham&quot;, &quot;spam&quot;, &quot;egg&quot;, None],
        &quot;random&quot;: np.random.rand(5),
        &quot;groups&quot;: [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;],
    }
)
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌──────┬───────┬──────────────────────┬────────┐
│ nrs  ┆ names ┆ random               ┆ groups │
│ ---  ┆ ---   ┆ ---                  ┆ ---    │
│ i64  ┆ str   ┆ f64                  ┆ str    │
╞══════╪═══════╪══════════════════════╪════════╡
│ 1    ┆ foo   ┆ 0.15416284237967237  ┆ A      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 2    ┆ ham   ┆ 0.7400496965154048   ┆ A      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 3    ┆ spam  ┆ 0.26331501518513467  ┆ B      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ null ┆ egg   ┆ 0.5337393933802977   ┆ C      │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ 5    ┆ null  ┆ 0.014574962485419674 ┆ B      │
└──────┴───────┴──────────────────────┴────────┘
</code></pre>
<p>You can do a lot with expressions. They are so expressive that you sometimes have
multiple ways to get the same results. To get a feel for them let's go through some
examples.</p>
<h3 id="count-unique-values-1"><a class="header" href="#count-unique-values-1">Count unique values</a></h3>
<p>We can count the unique values in a column. Note that we are creating the same result in
different ways. To not have duplicate column names in the <code>DataFrame</code>, we use an
<code>alias</code> expression, which renames an expression.</p>
<pre><code class="language-python">df = df[
    [
        pl.col(&quot;names&quot;).n_unique().alias(&quot;unique_names_1&quot;),
        pl.col(&quot;names&quot;).unique().count().alias(&quot;unique_names_2&quot;),
    ]
]
print(df)
</code></pre>
<pre><code class="language-text">shape: (1, 2)
┌────────────────┬────────────────┐
│ unique_names_1 ┆ unique_names_2 │
│ ---            ┆ ---            │
│ u32            ┆ u32            │
╞════════════════╪════════════════╡
│ 5              ┆ 5              │
└────────────────┴────────────────┘
</code></pre>
<h3 id="various-aggregations-1"><a class="header" href="#various-aggregations-1">Various aggregations</a></h3>
<p>We can do various aggregations. Below we show some of them, but there are more, such as
<code>median</code>, <code>mean</code>, <code>first</code>, etc.</p>
<pre><code class="language-python">df = df[
    [
        pl.sum(&quot;random&quot;).alias(&quot;sum&quot;),
        pl.min(&quot;random&quot;).alias(&quot;min&quot;),
        pl.max(&quot;random&quot;).alias(&quot;max&quot;),
        pl.col(&quot;random&quot;).max().alias(&quot;other_max&quot;),
        pl.std(&quot;random&quot;).alias(&quot;std dev&quot;),
        pl.var(&quot;random&quot;).alias(&quot;variance&quot;),
    ]
]
print(df)
</code></pre>
<pre><code class="language-text">shape: (1, 6)
┌────────────────┬────────────────┬────────────────┬───────────────┬───────────────┬───────────────┐
│ sum            ┆ min            ┆ max            ┆ other_max     ┆ std dev       ┆ variance      │
│ ---            ┆ ---            ┆ ---            ┆ ---           ┆ ---           ┆ ---           │
│ f64            ┆ f64            ┆ f64            ┆ f64           ┆ f64           ┆ f64           │
╞════════════════╪════════════════╪════════════════╪═══════════════╪═══════════════╪═══════════════╡
│ 1.705841909945 ┆ 0.014574962485 ┆ 0.740049696515 ┆ 0.74004969651 ┆ 0.29320870456 ┆ 0.08597134443 │
│ 9292           ┆ 419674         ┆ 4048           ┆ 54048         ┆ 7623          ┆ 422363        │
└────────────────┴────────────────┴────────────────┴───────────────┴───────────────┴───────────────┘
</code></pre>
<h3 id="filter-and-conditionals-1"><a class="header" href="#filter-and-conditionals-1">Filter and conditionals</a></h3>
<p>We can also do some pretty complex things. In the next snippet we count all names ending
with the string <code>&quot;am&quot;</code>.</p>
<pre><code class="language-python">df = df[[pl.col(&quot;names&quot;).filter(pl.col(&quot;names&quot;).str.contains(r&quot;am$&quot;)).count()]]
print(df)
</code></pre>
<pre><code class="language-text">shape: (1, 1)
┌───────┐
│ names │
│ ---   │
│ u32   │
╞═══════╡
│ 2     │
└───────┘
</code></pre>
<h3 id="binary-functions-and-modification-1"><a class="header" href="#binary-functions-and-modification-1">Binary functions and modification</a></h3>
<p>In the example below we use a conditional to create a new expression in the following
<code>when -&gt; then -&gt; otherwise</code> construct. The <code>when()</code> function requires a predicate
expression (and thus leads to a <code>boolean</code> <code>Series</code>), the <code>then</code> expects an
expression that will be used in case the predicate evaluates <code>true</code>, and the <code>otherwise</code>
expects an expression that will be used in case the predicate evaluates <code>false</code>.</p>
<p>Note that you can pass any expression, or just base expressions like <code>pl.col(&quot;foo&quot;)</code>,
<code>pl.lit(3)</code>, <code>pl.lit(&quot;bar&quot;)</code>, etc.</p>
<p>Finally, we multiply this with result of a sum expression.</p>
<pre><code class="language-python">df = df[[pl.when(pl.col(&quot;random&quot;) &gt; 0.5).then(0).otherwise(pl.col(&quot;random&quot;)) * pl.sum(&quot;nrs&quot;)]]
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 1)
┌────────────────────┐
│ literal            │
│ ---                │
│ f64                │
╞════════════════════╡
│ 1.695791266176396  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.0                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2.8964651670364816 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.0                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.1603245873396164 │
└────────────────────┘
</code></pre>
<h3 id="window-expressions-split-apply-combine-1"><a class="header" href="#window-expressions-split-apply-combine-1">Window expressions (split-apply-combine)</a></h3>
<p>A polars expression can also do an implicit GROUPBY, AGGREGATION, and JOIN in a single expression.
In the examples below we do a GROUPBY OVER <code>&quot;groups&quot;</code> and AGGREGATE SUM of <code>&quot;random&quot;</code>, and in the next expression
we GROUPBY OVER <code>&quot;names&quot;</code> and AGGREGATE a LIST of <code>&quot;random&quot;</code>. These window functions can be combined with other expressions,
and are an efficient way to determine group statistics. See more of those <a href="https://pola-rs.github.io/polars/py-polars/html/reference/expression.html#aggregation">group statistics here</a>.</p>
<pre><code class="language-python">df = df[
    [
        pl.col(&quot;*&quot;),  # select all
        pl.col(&quot;random&quot;).sum().over(&quot;groups&quot;).alias(&quot;sum[random]/groups&quot;),
        pl.col(&quot;random&quot;).list().over(&quot;names&quot;).alias(&quot;random/name&quot;),
    ]
]
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 6)
┌──────┬───────┬──────────────────────┬────────┬─────────────────────┬────────────────────────┐
│ nrs  ┆ names ┆ random               ┆ groups ┆ sum[random]/groups  ┆ random/name            │
│ ---  ┆ ---   ┆ ---                  ┆ ---    ┆ ---                 ┆ ---                    │
│ i64  ┆ str   ┆ f64                  ┆ str    ┆ f64                 ┆ list [f64]             │
╞══════╪═══════╪══════════════════════╪════════╪═════════════════════╪════════════════════════╡
│ 1    ┆ foo   ┆ 0.15416284237967237  ┆ A      ┆ 0.8942125388950771  ┆ [0.15416284237967237]  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2    ┆ ham   ┆ 0.7400496965154048   ┆ A      ┆ 0.8942125388950771  ┆ [0.7400496965154048]   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3    ┆ spam  ┆ 0.26331501518513467  ┆ B      ┆ 0.27788997767055434 ┆ [0.26331501518513467]  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ null ┆ egg   ┆ 0.5337393933802977   ┆ C      ┆ 0.5337393933802977  ┆ [0.5337393933802977]   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5    ┆ null  ┆ 0.014574962485419674 ┆ B      ┆ 0.27788997767055434 ┆ [0.014574962485419674] │
└──────┴───────┴──────────────────────┴────────┴─────────────────────┴────────────────────────┘
</code></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>This is the tip of the iceberg in terms of possible expressions, there are a ton more, and they
can be combined in myriad ways.</p>
<p>This page was an introduction to Polars expressions and gave a glimpse of what's
possible with them. In the next page, we see in which contexts we can use expressions. And later we'll go through expressions
in various groupby contexts and by doing that keep Polars execution parallel.</p>
<h1 id="expression-contexts"><a class="header" href="#expression-contexts">Expression contexts</a></h1>
<p>You cannot use an expression anywhere. An expression needs a context, the available contexts are:</p>
<ul>
<li>select</li>
<li>split-apply-combine</li>
<li>hstack/ add columns</li>
</ul>
<h2 id="syntactic-sugar"><a class="header" href="#syntactic-sugar">Syntactic sugar</a></h2>
<p>The reason for such a context, is that you actually are using the Polars lazy API, even if you use it in eager.
For instance this snippet:</p>
<pre><code class="language-python">df.groupby(&quot;foo&quot;).agg([pl.col(&quot;bar&quot;).sum()])
</code></pre>
<p>actually desugars to:</p>
<pre><code class="language-python">(df.lazy().groupby(&quot;foo&quot;).agg([pl.col(&quot;bar&quot;).sum()])).collect()
</code></pre>
<p>This allows Polars to push the expression into the query engine, do optimizations, and cache intermediate results.</p>
<h2 id="select-context"><a class="header" href="#select-context">Select context</a></h2>
<p>You cannot use an expression everywhere. An expression needs a context from which it can
select the column <code>&quot;foo&quot;</code> to start with.</p>
<h4 id="select-in-eager-as-bracket-expressions"><a class="header" href="#select-in-eager-as-bracket-expressions">Select in eager as bracket expressions</a></h4>
<pre><code class="language-python">
</code></pre>
<h4 id="select-in-eager-via-select"><a class="header" href="#select-in-eager-via-select">Select in eager via select</a></h4>
<pre><code class="language-python">
</code></pre>
<h4 id="select-in-lazy-via-select"><a class="header" href="#select-in-lazy-via-select">Select in lazy via select</a></h4>
<pre><code class="language-python">
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 2)
┌─────┬───────┐
│ nrs ┆ names │
│ --- ┆ ---   │
│ i64 ┆ str   │
╞═════╪═══════╡
│ 11  ┆ null  │
├╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 11  ┆ egg   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 11  ┆ foo   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 11  ┆ ham   │
├╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 11  ┆ spam  │
└─────┴───────┘
</code></pre>
<h2 id="split-apply-combine-context"><a class="header" href="#split-apply-combine-context">Split-apply-combine context</a></h2>
<p>You can use expression during <code>groupby</code> aggregations in lazy as well as eager:</p>
<h4 id="lazy-aggregation"><a class="header" href="#lazy-aggregation">Lazy aggregation</a></h4>
<pre><code class="language-python">
</code></pre>
<h4 id="eager-aggregation"><a class="header" href="#eager-aggregation">Eager aggregation</a></h4>
<pre><code class="language-python">
print(df)
</code></pre>
<pre><code class="language-text">shape: (3, 3)
┌────────┬─────────┬───────┐
│ groups ┆ nrs_sum ┆ count │
│ ---    ┆ ---     ┆ ---   │
│ str    ┆ i64     ┆ u32   │
╞════════╪═════════╪═══════╡
│ B      ┆ 8       ┆ 2     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ C      ┆ null    ┆ 1     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ A      ┆ 3       ┆ 2     │
└────────┴─────────┴───────┘
</code></pre>
<h2 id="add-columns-context"><a class="header" href="#add-columns-context">Add columns context</a></h2>
<p>And finally you can use expressions to add one or multiple columns to an existing <code>DataFrame</code></p>
<h4 id="lazy-add-columns"><a class="header" href="#lazy-add-columns">Lazy add columns</a></h4>
<pre><code class="language-python">
</code></pre>
<h4 id="eager-aggregation-1"><a class="header" href="#eager-aggregation-1">Eager aggregation</a></h4>
<pre><code class="language-python">
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 6)
┌──────┬───────┬──────────────────────┬────────┬─────────┬───────┐
│ nrs  ┆ names ┆ random               ┆ groups ┆ nrs_sum ┆ count │
│ ---  ┆ ---   ┆ ---                  ┆ ---    ┆ ---     ┆ ---   │
│ i64  ┆ str   ┆ f64                  ┆ str    ┆ i64     ┆ u32   │
╞══════╪═══════╪══════════════════════╪════════╪═════════╪═══════╡
│ 1    ┆ foo   ┆ 0.15416284237967237  ┆ A      ┆ 11      ┆ 5     │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2    ┆ ham   ┆ 0.7400496965154048   ┆ A      ┆ 11      ┆ 5     │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3    ┆ spam  ┆ 0.26331501518513467  ┆ B      ┆ 11      ┆ 5     │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ null ┆ egg   ┆ 0.5337393933802977   ┆ C      ┆ 11      ┆ 5     │
├╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 5    ┆ null  ┆ 0.014574962485419674 ┆ B      ┆ 11      ┆ 5     │
└──────┴───────┴──────────────────────┴────────┴─────────┴───────┘
</code></pre>
<h1 id="groupby"><a class="header" href="#groupby">GroupBy</a></h1>
<blockquote>
<p>In redaction</p>
</blockquote>
<h2 id="a-multithreaded-approach"><a class="header" href="#a-multithreaded-approach">A multithreaded approach</a></h2>
<p>One of the most efficient way to process tabular data is to parallelize its processing
via the &quot;split-apply-combine&quot; approach. This operation is at the core of <code>Polars</code>
grouping implementation, allowing it to attain lightning-fast operations. Most
specifically, both the &quot;split&quot; and &quot;apply&quot; phases are executed in a multithreaded
fashion.</p>
<p>A simple grouping operation is taken below as an example to illustrate this approach:</p>
<p><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/docs/split-apply-combine.svg" alt="" /></p>
<p>For the hashing operations performed during the &quot;split&quot; phase, <code>Polars</code> uses a
multithreaded lock-free approach that is illustrated on the following schema:</p>
<p><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/docs/lock-free-hash.svg" alt="" /></p>
<p>This parallelization allows the grouping and joining operations (for instance) to be
blazingly fast!</p>
<blockquote>
<p>Include content from the
<a href="https://www.ritchievink.com/blog/2021/02/28/i-wrote-one-of-the-fastest-dataframe-libraries/">blog post</a></p>
</blockquote>
<h2 id="do-not-kill-the-parallelization"><a class="header" href="#do-not-kill-the-parallelization">Do not kill the parallelization!</a></h2>
<p>We have all heard that <code>Python</code> is slow, and does &quot;not scale.&quot; Besides the overhead of
running &quot;slow&quot; bytecode, <code>Python</code> has to remain within the constraints of the Global
Interpreter Lock (GIL). This means that if one uses a <code>lambda</code> or a custom <code>Python</code>
function to apply during a parallelized phase, <code>Polars</code> speed is capped running <code>Python</code>
code preventing any multiple threads from executing the function.</p>
<p>This all feels terribly limiting, especially because we often need those <code>lambda</code> in a
<code>.groupby()</code> step for instance. This approach is still supported by <code>Polars</code>, but
keeping in mind bytecode AND the GIL price have to be paid.</p>
<p>To mitigate this, <code>Polars</code> implements a powerful syntax defined not only in its lazy,
but also in its eager API.</p>
<h2 id="polars-expressions-2"><a class="header" href="#polars-expressions-2">Polars Expressions</a></h2>
<p>In the introduction on previous page we discussed that using custom Python functions,
killed parallelization, and that we can use the expressions of the lazy API to mitigate
this. Let's take a look at what that means.</p>
<h3 id="eager-and-lazy"><a class="header" href="#eager-and-lazy">Eager and Lazy</a></h3>
<p>For groupby operations you can use the lazy API in Polars eager. That means that if you
run this snippet of code</p>
<pre><code class="language-python">df.groupby(&quot;foo&quot;).agg([pl.col(&quot;bar&quot;).sum()])
</code></pre>
<p>It actually desugars to:</p>
<pre><code class="language-python">(df.lazy().groupby(&quot;foo&quot;).agg([pl.col(&quot;bar&quot;).sum()])).collect()
</code></pre>
<p>That means you don't have to go to lazy by yourself if you need the more powerful API.</p>
<h3 id="why-would-you-want-this"><a class="header" href="#why-would-you-want-this">Why would you want this?</a></h3>
<p>As discussed earlier, this allows us to delay the need of grabbing Python <code>lambdas</code> to
do a more complex aggregation. So let's start very simple and see how we can use the DSL
to do increasingly complex queries.</p>
<p>Let's start with the simple
<a href="https://github.com/unitedstates/congress-legislators">US congress dataset</a>.</p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset

q = (
    dataset.lazy()
    .groupby(&quot;first_name&quot;)
    .agg([pl.count(&quot;party&quot;), pl.col(&quot;gender&quot;).list(), pl.first(&quot;last_name&quot;)])
    .sort(&quot;party_count&quot;, reverse=True)
    .limit(5)
)

df = q.collect()
</code></pre>
<h4 id="basic-aggregations"><a class="header" href="#basic-aggregations">Basic aggregations</a></h4>
<p>You can easily combine different aggregations by adding multiple expressions in a
<code>list</code>. There is no upper bound on the number of aggregations you can do, and you can
make any combination you want. In the snippet below we do the following aggregations:</p>
<p>Per GROUP <code>&quot;first_name&quot;</code> we</p>
<ul>
<li>count the number of rows in the group:
<ul>
<li>short form: <code>pl.count(&quot;party&quot;)</code></li>
<li>full form: <code>pl.col(&quot;party&quot;).count()</code></li>
</ul>
</li>
<li>aggregate the gender values group to a list:
<ul>
<li>full form: <code>pl.col(&quot;gender&quot;).list()</code></li>
</ul>
</li>
<li>get the first value of column <code>&quot;last_name&quot;</code> in the group:
<ul>
<li>short form: <code>pl.first(&quot;last_name&quot;)</code></li>
<li>full form: <code>pl.col(&quot;last_name&quot;).first()</code></li>
</ul>
</li>
</ul>
<p>Besides the aggregation, we immediately sort the result and limit to the top 5 so that
we have a nice summary overview.</p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset

q = (
    dataset.lazy()
    .groupby(&quot;first_name&quot;)
    .agg([pl.count(&quot;party&quot;), pl.col(&quot;gender&quot;).list(), pl.first(&quot;last_name&quot;)])
    .sort(&quot;party_count&quot;, reverse=True)
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌────────────┬─────────────┬─────────────────────┬─────────────────┐
│ first_name ┆ party_count ┆ gender_agg_list     ┆ last_name_first │
│ ---        ┆ ---         ┆ ---                 ┆ ---             │
│ cat        ┆ u32         ┆ list [cat]          ┆ str             │
╞════════════╪═════════════╪═════════════════════╪═════════════════╡
│ &quot;John&quot;     ┆ 1254        ┆ [&quot;M&quot;, &quot;M&quot;, ... &quot;M&quot;] ┆ Walker          │
├╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;William&quot;  ┆ 1022        ┆ [&quot;M&quot;, &quot;M&quot;, ... &quot;M&quot;] ┆ Few             │
├╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;James&quot;    ┆ 712         ┆ [&quot;M&quot;, &quot;M&quot;, ... &quot;M&quot;] ┆ Armstrong       │
├╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;Thomas&quot;   ┆ 453         ┆ [&quot;M&quot;, &quot;M&quot;, ... &quot;M&quot;] ┆ Tucker          │
├╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;Charles&quot;  ┆ 439         ┆ [&quot;M&quot;, &quot;M&quot;, ... &quot;M&quot;] ┆ Carroll         │
└────────────┴─────────────┴─────────────────────┴─────────────────┘
</code></pre>
<h4 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h4>
<p>Ok, that was pretty easy right. Let's turn it up a notch. Let's say we want to know how
many delegates of a &quot;state&quot; are &quot;Pro&quot; or &quot;Anti&quot; administration we could directly query
that in the aggregation without the need of <code>lambda</code> or grooming the DataFrame.</p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset

q = (
    dataset.lazy()
    .groupby(&quot;state&quot;)
    .agg(
        [
            (pl.col(&quot;party&quot;) == &quot;Anti-Administration&quot;).sum().alias(&quot;anti&quot;),
            (pl.col(&quot;party&quot;) == &quot;Pro-Administration&quot;).sum().alias(&quot;pro&quot;),
        ]
    )
    .sort(&quot;pro&quot;, reverse=True)
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 3)
┌───────┬──────┬─────┐
│ state ┆ anti ┆ pro │
│ ---   ┆ ---  ┆ --- │
│ cat   ┆ u32  ┆ u32 │
╞═══════╪══════╪═════╡
│ &quot;CT&quot;  ┆ 0    ┆ 3   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;NJ&quot;  ┆ 0    ┆ 3   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;NC&quot;  ┆ 1    ┆ 2   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;SC&quot;  ┆ 0    ┆ 1   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌┤
│ &quot;PA&quot;  ┆ 1    ┆ 1   │
└───────┴──────┴─────┘
</code></pre>
<p>Something similar could of course also be done with a nested GROUPBY, but that would not
allow me showing these nice features. 😉</p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset

q = (
    dataset.lazy()
    .groupby([&quot;state&quot;, &quot;party&quot;])
    .agg([pl.count(&quot;party&quot;).alias(&quot;count&quot;)])
    .filter((pl.col(&quot;party&quot;) == &quot;Anti-Administration&quot;) | (pl.col(&quot;party&quot;) == &quot;Pro-Administration&quot;))
    .sort(&quot;count&quot;, reverse=True)
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 3)
┌───────┬───────────────────────┬───────┐
│ state ┆ party                 ┆ count │
│ ---   ┆ ---                   ┆ ---   │
│ cat   ┆ cat                   ┆ u32   │
╞═══════╪═══════════════════════╪═══════╡
│ &quot;NJ&quot;  ┆ &quot;Pro-Administration&quot;  ┆ 3     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;CT&quot;  ┆ &quot;Pro-Administration&quot;  ┆ 3     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;VA&quot;  ┆ &quot;Anti-Administration&quot; ┆ 3     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;NC&quot;  ┆ &quot;Pro-Administration&quot;  ┆ 2     │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ &quot;KY&quot;  ┆ &quot;Anti-Administration&quot; ┆ 1     │
└───────┴───────────────────────┴───────┘
</code></pre>
<h4 id="filtering"><a class="header" href="#filtering">Filtering</a></h4>
<p>We can also filter the groups. Let's say we want to compute a mean per group, but we
don't want to include all values from that group and we also don't want to filter the
rows from the <code>DataFrame</code> (because we need that rows for another aggregation.)</p>
<p>In the example below we show how that can be done. Note that we can make <code>Python</code>
functions for clarity. These functions don't cost us anything. That is because we only
create <code>Polars</code> expression, we don't apply a custom function over <code>Series</code> during
runtime of the query.</p>
<pre><code class="language-python">from datetime import datetime

import polars as pl

from .dataset import dataset


def compute_age() -&gt; pl.Expr:
    return (pl.lit(datetime(2021, 1, 1)) - pl.col(&quot;birthday&quot;)).dt.year()


def avg_birthday(gender: str) -&gt; pl.Expr:
    return compute_age().filter(pl.col(&quot;gender&quot;) == gender).mean().alias(f&quot;avg {gender} birthday&quot;)


q = (
    dataset.lazy()
    .groupby([&quot;state&quot;])
    .agg(
        [
            avg_birthday(&quot;M&quot;),
            avg_birthday(&quot;F&quot;),
            (pl.col(&quot;gender&quot;) == &quot;M&quot;).sum().alias(&quot;# male&quot;),
            (pl.col(&quot;gender&quot;) == &quot;F&quot;).sum().alias(&quot;# female&quot;),
        ]
    )
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 5)
┌───────┬───────────────────┬────────────────┬────────┬──────────┐
│ state ┆ avg M birthday    ┆ avg F birthday ┆ # male ┆ # female │
│ ---   ┆ ---               ┆ ---            ┆ ---    ┆ ---      │
│ cat   ┆ f64               ┆ f64            ┆ u32    ┆ u32      │
╞═══════╪═══════════════════╪════════════════╪════════╪══════════╡
│ &quot;PA&quot;  ┆ 2227.193308550186 ┆ null           ┆ 1046   ┆ 7        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ &quot;ID&quot;  ┆ 2212.875          ┆ null           ┆ 57     ┆ 2        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ &quot;CT&quot;  ┆ 2209.363157894737 ┆ null           ┆ 234    ┆ 6        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ &quot;OK&quot;  ┆ 2206.849315068493 ┆ null           ┆ 90     ┆ 3        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┤
│ &quot;GU&quot;  ┆ 2213.25           ┆ null           ┆ 3      ┆ 1        │
└───────┴───────────────────┴────────────────┴────────┴──────────┘
</code></pre>
<h4 id="sorting"><a class="header" href="#sorting">Sorting</a></h4>
<p>I often see a DataFrame being sorted for the sole purpose of the ordering during the
GROUPBY operation. Let's say that we want to get the names of the oldest and youngest
(not that they are still alive) politicians per state, we could SORT and GROUPBY.</p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset


def get_person() -&gt; pl.Expr:
    return pl.col(&quot;first_name&quot;) + pl.lit(&quot; &quot;) + pl.col(&quot;last_name&quot;)


q = (
    dataset.lazy()
    .sort(&quot;birthday&quot;)
    .groupby([&quot;state&quot;])
    .agg(
        [
            get_person().first().alias(&quot;youngest&quot;),
            get_person().last().alias(&quot;oldest&quot;),
        ]
    )
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 3)
┌───────┬─────────────────┬────────────────┐
│ state ┆ youngest        ┆ oldest         │
│ ---   ┆ ---             ┆ ---            │
│ cat   ┆ str             ┆ str            │
╞═══════╪═════════════════╪════════════════╡
│ &quot;MO&quot;  ┆ Spencer Pettis  ┆ Russ Carnahan  │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;OL&quot;  ┆ Daniel Clark    ┆ Julien Poydras │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;TX&quot;  ┆ John Cranford   ┆ Will Hurd      │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;FL&quot;  ┆ Charles Downing ┆ Patrick Murphy │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;CT&quot;  ┆ Henry Edwards   ┆ Elizabeth Esty │
└───────┴─────────────────┴────────────────┘
</code></pre>
<p>However, IF we also want to sort the names alphabetically (and why wouldn't you!), this
breaks. Luckily we can sort in a groupby context separate from the <code>DataFrame</code>.</p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset


def get_person() -&gt; pl.Expr:
    return pl.col(&quot;first_name&quot;) + pl.lit(&quot; &quot;) + pl.col(&quot;last_name&quot;)


q = (
    dataset.lazy()
    .sort(&quot;birthday&quot;)
    .groupby([&quot;state&quot;])
    .agg(
        [
            get_person().first().alias(&quot;youngest&quot;),
            get_person().last().alias(&quot;oldest&quot;),
            get_person().sort().first().alias(&quot;alphabetical_first&quot;),
        ]
    )
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌───────┬─────────────────┬──────────────────────┬────────────────────┐
│ state ┆ youngest        ┆ oldest               ┆ alphabetical_first │
│ ---   ┆ ---             ┆ ---                  ┆ ---                │
│ cat   ┆ str             ┆ str                  ┆ str                │
╞═══════╪═════════════════╪══════════════════════╪════════════════════╡
│ &quot;GU&quot;  ┆ Antonio Won Pat ┆ Robert Underwood     ┆ Antonio Won Pat    │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;NM&quot;  ┆ José Gallegos   ┆ Xochitl Torres Small ┆ Albert Fall        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;KY&quot;  ┆ John Edwards    ┆ Ben Chandler         ┆ Aaron Harding      │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;OK&quot;  ┆ David Harvey    ┆ Kendra Horn          ┆ Alice Robertson    │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ &quot;ND&quot;  ┆ Lyman Casey     ┆ Rick Berg            ┆ Arthur Link        │
└───────┴─────────────────┴──────────────────────┴────────────────────┘
</code></pre>
<p>We can even sort by another column in the GROUPBY context. If we want to know if the
alphabetically sorted name is male or female we could add
<code>pl.col(&quot;gender&quot;).sort_by(&quot;first_name&quot;).first().alias(&quot;gender&quot;)</code></p>
<pre><code class="language-python">import polars as pl

from .dataset import dataset


def get_person() -&gt; pl.Expr:
    return pl.col(&quot;first_name&quot;) + pl.lit(&quot; &quot;) + pl.col(&quot;last_name&quot;)


q = (
    dataset.lazy()
    .sort(&quot;birthday&quot;)
    .groupby([&quot;state&quot;])
    .agg(
        [
            get_person().first().alias(&quot;youngest&quot;),
            get_person().last().alias(&quot;oldest&quot;),
            get_person().sort().first().alias(&quot;alphabetical_first&quot;),
            pl.col(&quot;gender&quot;).sort_by(&quot;first_name&quot;).first().alias(&quot;gender&quot;),
        ]
    )
    .sort(&quot;state&quot;)
    .limit(5)
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 5)
┌───────┬───────────────────┬────────────────┬────────────────────┬────────┐
│ state ┆ youngest          ┆ oldest         ┆ alphabetical_first ┆ gender │
│ ---   ┆ ---               ┆ ---            ┆ ---                ┆ ---    │
│ cat   ┆ str               ┆ str            ┆ str                ┆ cat    │
╞═══════╪═══════════════════╪════════════════╪════════════════════╪════════╡
│ &quot;DE&quot;  ┆ Samuel White      ┆ John Carney    ┆ Albert Polk        ┆ &quot;M&quot;    │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ &quot;VA&quot;  ┆ William Grayson   ┆ Scott Taylor   ┆ Abraham Venable    ┆ &quot;M&quot;    │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ &quot;SC&quot;  ┆ Ralph Izard       ┆ Joe Cunningham ┆ Abraham Nott       ┆ &quot;M&quot;    │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ &quot;MD&quot;  ┆ Benjamin Contee   ┆ Frank Kratovil ┆ Albert Blakeney    ┆ &quot;M&quot;    │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┤
│ &quot;PA&quot;  ┆ Thomas Fitzsimons ┆ Ryan Costello  ┆ Aaron Kreider      ┆ &quot;M&quot;    │
└───────┴───────────────────┴────────────────┴────────────────────┴────────┘
</code></pre>
<h3 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h3>
<p>In the examples above we've seen that we can do a lot by combining expressions. By doing
so we delay the use of custom python functions that slow down the queries (by the slow
nature of Python AND the GIL).</p>
<p>If you think there is a type expression missing, let me know and open a
<a href="https://github.com/pola-rs/polars/issues/new/choose">feature request</a>.</p>
<h1 id="folds"><a class="header" href="#folds">Folds</a></h1>
<p>Polars provides expressions/methods for horizontal aggregations like, <a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.DataFrame.sum.html">sum</a>,
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.DataFrame.min.html">min</a>, <a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.DataFrame.mean.html">mean</a>,
etc. by setting the argument <code>axis=1</code>. However, when you need a more complex aggregation the default ones provided by the
polars library may not be sufficient. That's when <code>folds</code> come in handy. Polars' <code>fold</code> expression operates on columns and
can therefore be really fast. It utilizes the data layout most efficiently and often has vectorized execution.</p>
<p>Let's start with an example by implement the <code>sum</code> operation ourselves, with a <code>fold</code></p>
<h2 id="manual-sum"><a class="header" href="#manual-sum">Manual Sum</a></h2>
<pre><code class="language-python">
out = df.select(pl.fold(acc=pl.lit(0), f=lambda acc, x: acc + x, exprs=pl.col(&quot;*&quot;)).alias(&quot;sum&quot;))
print(out)
</code></pre>
<pre><code class="language-text">shape: (3, 1)
┌─────┐
│ sum │
│ --- │
│ i64 │
╞═════╡
│ 11  │
├╌╌╌╌╌┤
│ 22  │
├╌╌╌╌╌┤
│ 33  │
└─────┘
</code></pre>
<p>The snippet above recursively applies the function <code>f(acc, x) -&gt; acc</code> to an accumulator <code>acc</code> and a new column <code>x</code>.
The function operations on columns at a time and can take advantage from cache efficiency and vectorization.</p>
<h2 id="conditional"><a class="header" href="#conditional">Conditional</a></h2>
<p>In the case where you'd want to apply a condition/predicate on all columns in a <code>DataFrame</code> a <code>fold</code> operation can be
a very concise way to express this.</p>
<pre><code class="language-python">
out = df.filter(pl.fold(acc=pl.lit(True), f=lambda acc, x: acc &amp; x, exprs=pl.col(&quot;*&quot;) &gt; 1))
print(out)
</code></pre>
<pre><code class="language-text">shape: (1, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ i64 │
╞═════╪═════╡
│ 3   ┆ 2   │
└─────┴─────┘
</code></pre>
<p>In the snippet we filter all rows that have <strong>ALL</strong> values &gt; 1.</p>
<h2 id="folds-and-string-data"><a class="header" href="#folds-and-string-data">Folds and string data</a></h2>
<p>Folds could be used to concatenate string data. However, due to the materialization of intermediate columns, this
operation will have squared complexity.</p>
<p>Therefore, we recommend using the <code>concat_str</code> expression for this.</p>
<pre><code class="language-python">df = pl.DataFrame({&quot;a&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;b&quot;: [1, 2, 3]})

out = df[[pl.concat_str([&quot;a&quot;, &quot;b&quot;])]]
print(out)
</code></pre>
<pre><code class="language-text">shape: (3, 1)
┌─────┐
│ a   │
│ --- │
│ str │
╞═════╡
│ a1  │
├╌╌╌╌╌┤
│ b2  │
├╌╌╌╌╌┤
│ c3  │
└─────┘
</code></pre>
<h1 id="window-functions-"><a class="header" href="#window-functions-">Window functions 🚀🚀</a></h1>
<p>Window functions are expressions with superpowers. They allow you to do aggregation on groups in the
<strong>select</strong> context. Let's get a feel of what that means. First we create a dataset. The dataset loaded in the
snippet below contains information about pokemon and has the following columns:</p>
<p><code>['#',  'Name',  'Type 1',  'Type 2',  'Total',  'HP',  'Attack',  'Defense',  'Sp. Atk',  'Sp. Def',  'Speed',  'Generation',  'Legendary']</code></p>
<pre><code class="language-python">import polars as pl

# then let's load some csv data with information about pokemon
df = pl.read_csv(
    &quot;https://gist.githubusercontent.com/ritchie46/cac6b337ea52281aa23c049250a4ff03/raw/89a957ff3919d90e6ef2d34235e6bf22304f3366/pokemon.csv&quot;
)
</code></pre>
<pre><code class="language-text">shape: (163, 13)
┌─────┬───────────────────────┬─────────┬────────┬─────┬─────────┬───────┬────────────┬───────────┐
│ #   ┆ Name                  ┆ Type 1  ┆ Type 2 ┆ ... ┆ Sp. Def ┆ Speed ┆ Generation ┆ Legendary │
│ --- ┆ ---                   ┆ ---     ┆ ---    ┆     ┆ ---     ┆ ---   ┆ ---        ┆ ---       │
│ i64 ┆ str                   ┆ str     ┆ str    ┆     ┆ i64     ┆ i64   ┆ i64        ┆ bool      │
╞═════╪═══════════════════════╪═════════╪════════╪═════╪═════════╪═══════╪════════════╪═══════════╡
│ 1   ┆ Bulbasaur             ┆ Grass   ┆ Poison ┆ ... ┆ 65      ┆ 45    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ Ivysaur               ┆ Grass   ┆ Poison ┆ ... ┆ 80      ┆ 60    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ Venusaur              ┆ Grass   ┆ Poison ┆ ... ┆ 100     ┆ 80    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ VenusaurMega Venusaur ┆ Grass   ┆ Poison ┆ ... ┆ 120     ┆ 80    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ ... ┆ ...                   ┆ ...     ┆ ...    ┆ ... ┆ ...     ┆ ...   ┆ ...        ┆ ...       │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 146 ┆ Moltres               ┆ Fire    ┆ Flying ┆ ... ┆ 85      ┆ 90    ┆ 1          ┆ true      │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 147 ┆ Dratini               ┆ Dragon  ┆        ┆ ... ┆ 50      ┆ 50    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 148 ┆ Dragonair             ┆ Dragon  ┆        ┆ ... ┆ 70      ┆ 70    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 149 ┆ Dragonite             ┆ Dragon  ┆ Flying ┆ ... ┆ 100     ┆ 80    ┆ 1          ┆ false     │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌┤
│ 150 ┆ Mewtwo                ┆ Psychic ┆        ┆ ... ┆ 90      ┆ 130   ┆ 1          ┆ true      │
└─────┴───────────────────────┴─────────┴────────┴─────┴─────────┴───────┴────────────┴───────────┘
</code></pre>
<h2 id="groupby-aggregations-in-selection"><a class="header" href="#groupby-aggregations-in-selection">Groupby Aggregations in selection</a></h2>
<p>Below we show how we use window function to group over different columns and do an aggregation on them.
Doing so, allows us to do multiple groupby operations in parallel in a single query. The results of the aggregation
are projected back to the original rows. A window function will therefore always lead to a DataFrame with the same size
as the original.</p>
<pre><code class="language-python">    [
        &quot;Type 1&quot;,
        &quot;Type 2&quot;,
        pl.col(&quot;Attack&quot;).mean().over(&quot;Type 1&quot;).alias(&quot;avg_attack_by_type&quot;),
        pl.col(&quot;Defense&quot;).mean().over([&quot;Type 1&quot;, &quot;Type 2&quot;]).alias(&quot;avg_defense_by_type_combination&quot;),
        pl.col(&quot;Attack&quot;).mean().alias(&quot;avg_attack&quot;),
    ]
)
</code></pre>
<pre><code class="language-text">shape: (163, 5)
┌─────────┬────────┬────────────────────┬─────────────────────────────────┬───────────────────┐
│ Type 1  ┆ Type 2 ┆ avg_attack_by_type ┆ avg_defense_by_type_combination ┆ avg_attack        │
│ ---     ┆ ---    ┆ ---                ┆ ---                             ┆ ---               │
│ str     ┆ str    ┆ f64                ┆ f64                             ┆ f64               │
╞═════════╪════════╪════════════════════╪═════════════════════════════════╪═══════════════════╡
│ Grass   ┆ Poison ┆ 72.92307692307692  ┆ 67.8                            ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Grass   ┆ Poison ┆ 72.92307692307692  ┆ 67.8                            ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Grass   ┆ Poison ┆ 72.92307692307692  ┆ 67.8                            ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Grass   ┆ Poison ┆ 72.92307692307692  ┆ 67.8                            ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ ...     ┆ ...    ┆ ...                ┆ ...                             ┆ ...               │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Fire    ┆ Flying ┆ 88.64285714285714  ┆ 82                              ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Dragon  ┆        ┆ 94                 ┆ 55                              ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Dragon  ┆        ┆ 94                 ┆ 55                              ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Dragon  ┆ Flying ┆ 94                 ┆ 95                              ┆ 75.34969325153374 │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Psychic ┆        ┆ 53.875             ┆ 51.42857142857143               ┆ 75.34969325153374 │
└─────────┴────────┴────────────────────┴─────────────────────────────────┴───────────────────┘
</code></pre>
<h2 id="operations-per-group"><a class="header" href="#operations-per-group">Operations per group</a></h2>
<p>In case we want to do something on a group level, we can also use window functions. Below we flex our muscles using them:</p>
<p>We:</p>
<ul>
<li>sort all pokemon by type</li>
<li>select the first 3 pokemon per type as <code>&quot;Type 1&quot;</code></li>
<li>sort the pokemon within a type by speed and select the first 3 as <code>&quot;fastest/group&quot;</code></li>
<li>sort the pokemon within a type by attack and select the first 3 as <code>&quot;strongest/group&quot;</code></li>
<li>sort the pokemon by name within a type and select the first 3 as <code>&quot;sorted_by_alphabet&quot;</code></li>
</ul>
<pre><code class="language-python">    [
        pl.col(&quot;Type 1&quot;).head(3).over(&quot;Type 1&quot;).flatten(),
        pl.col(&quot;Name&quot;).sort_by(pl.col(&quot;Speed&quot;)).head(3).over(&quot;Type 1&quot;).flatten().alias(&quot;fastest/group&quot;),
        pl.col(&quot;Name&quot;).sort_by(pl.col(&quot;Attack&quot;)).head(3).over(&quot;Type 1&quot;).flatten().alias(&quot;strongest/group&quot;),
        pl.col(&quot;Name&quot;).sort().head(3).over(&quot;Type 1&quot;).flatten().alias(&quot;sorted_by_alphabet&quot;),
    ]
)
</code></pre>
<pre><code class="language-text">shape: (43, 4)
┌────────┬─────────────────────┬─────────────────┬───────────────────────────┐
│ Type 1 ┆ fastest/group       ┆ strongest/group ┆ sorted_by_alphabet        │
│ ---    ┆ ---                 ┆ ---             ┆ ---                       │
│ str    ┆ str                 ┆ str             ┆ str                       │
╞════════╪═════════════════════╪═════════════════╪═══════════════════════════╡
│ Bug    ┆ Paras               ┆ Metapod         ┆ Beedrill                  │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Bug    ┆ Metapod             ┆ Kakuna          ┆ BeedrillMega Beedrill     │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Bug    ┆ Parasect            ┆ Caterpie        ┆ Butterfree                │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Dragon ┆ Dratini             ┆ Dratini         ┆ Dragonair                 │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ ...    ┆ ...                 ┆ ...             ┆ ...                       │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Rock   ┆ Graveler            ┆ Onix            ┆ AerodactylMega Aerodactyl │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Rock   ┆ Omanyte             ┆ Omastar         ┆ Geodude                   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Water  ┆ Slowpoke            ┆ Magikarp        ┆ Blastoise                 │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Water  ┆ Slowbro             ┆ Tentacool       ┆ BlastoiseMega Blastoise   │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ Water  ┆ SlowbroMega Slowbro ┆ Horsea          ┆ Cloyster                  │
└────────┴─────────────────────┴─────────────────┴───────────────────────────┘
</code></pre>
<h1 id="numpy-interop"><a class="header" href="#numpy-interop">Numpy interop</a></h1>
<p>Polars expression support numpy <a href="https://numpy.org/doc/stable/reference/ufuncs.html">ufuncs</a>. See <a href="https://numpy.org/doc/stable/reference/ufuncs.html#available-ufuncs">here</a>
for a list on all supported numpy functions.</p>
<p>This means that if a function is not provided by polars, we can use numpy and we still have fast columnar operation through
the numpy API.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-python">import polars as pl
import numpy as np

df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [4, 5, 6]})

out = df.select([np.log(pl.all()).suffix(&quot;_log&quot;)])
print(out)
</code></pre>
<pre><code class="language-text">shape: (3, 2)
┌────────────────────┬────────────────────┐
│ a_log              ┆ b_log              │
│ ---                ┆ ---                │
│ f64                ┆ f64                │
╞════════════════════╪════════════════════╡
│ 0.0                ┆ 1.3862943611198906 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 0.6931471805599453 ┆ 1.6094379124341003 │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1.0986122886681098 ┆ 1.791759469228055  │
└────────────────────┴────────────────────┘
</code></pre>
<h2 id="gotchas"><a class="header" href="#gotchas">Gotcha's</a></h2>
<p>Read more about the <a href="dsl//howcani/interop/numpy.html">gotcha's here</a></p>
<pre><code class="language-python">import polars as pl

</code></pre>
<h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p><code>fn(Series) -&gt; Series</code></p>
<ul>
<li>Lazily evaluated
<ul>
<li>Can be optimized</li>
<li>Gives the library writer context and informed decision can be made</li>
</ul>
</li>
<li>Embarassingly parallel</li>
<li>Context dependent
<ul>
<li>selection / projection -&gt; <code>Series</code> = <strong>COLUMN, LITERAL or VALUE</strong></li>
<li>aggregation -&gt; <code>Series</code> = <strong>GROUPS</strong></li>
</ul>
</li>
</ul>
<pre><code class="language-python">df = pl.DataFrame(
    {
        &quot;A&quot;: [1, 2, 3, 4, 5],
        &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &quot;B&quot;: [5, 4, 3, 2, 1],
        &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
        &quot;optional&quot;: [28, 300, None, 2, -30],
    }
)
df
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
fruits
</th>
<th>
B
</th>
<th>
cars
</th>
<th>
optional
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
"banana"
</td>
<td>
5
</td>
<td>
"beetle"
</td>
<td>
28
</td>
</tr>
<tr>
<td>
2
</td>
<td>
"banana"
</td>
<td>
4
</td>
<td>
"audi"
</td>
<td>
300
</td>
</tr>
<tr>
<td>
3
</td>
<td>
"apple"
</td>
<td>
3
</td>
<td>
"beetle"
</td>
<td>
null
</td>
</tr>
<tr>
<td>
4
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
"beetle"
</td>
<td>
2
</td>
</tr>
<tr>
<td>
5
</td>
<td>
"banana"
</td>
<td>
1
</td>
<td>
"beetle"
</td>
<td>
-30
</td>
</tr>
</tbody>
</table>
</div>
<h1 id="selection-context"><a class="header" href="#selection-context">Selection context</a></h1>
<pre><code class="language-python"># We can select by name
(df.select([
    pl.col(&quot;A&quot;),
    &quot;B&quot;,      # the col part is inferred
    pl.lit(&quot;B&quot;),  # we must tell polars we mean the literal &quot;B&quot;
    pl.col(&quot;fruits&quot;),
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
B
</th>
<th>
literal
</th>
<th>
fruits
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
str
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
5
</td>
<td>
"B"
</td>
<td>
"banana"
</td>
</tr>
<tr>
<td>
2
</td>
<td>
4
</td>
<td>
"B"
</td>
<td>
"banana"
</td>
</tr>
<tr>
<td>
3
</td>
<td>
3
</td>
<td>
"B"
</td>
<td>
"apple"
</td>
</tr>
<tr>
<td>
4
</td>
<td>
2
</td>
<td>
"B"
</td>
<td>
"apple"
</td>
</tr>
<tr>
<td>
5
</td>
<td>
1
</td>
<td>
"B"
</td>
<td>
"banana"
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># you can select columns with a regex if it starts with '^' and ends with '$'

(df.select([
    pl.col(&quot;^A|B$&quot;).sum()
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
B
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
15
</td>
<td>
15
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># you can select multiple columns by name

(df.select([
    pl.col([&quot;A&quot;, &quot;B&quot;]).sum()
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
B
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
15
</td>
<td>
15
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># We select everything in normal order
# Then we select everything in reversed order
(df.select([
    pl.all(),
    pl.all().reverse().suffix(&quot;_reverse&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
fruits
</th>
<th>
B
</th>
<th>
cars
</th>
<th>
optional
</th>
<th>
A_reverse
</th>
<th>
fruits_reverse
</th>
<th>
B_reverse
</th>
<th>
cars_reverse
</th>
<th>
optional_reverse
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
"banana"
</td>
<td>
5
</td>
<td>
"beetle"
</td>
<td>
28
</td>
<td>
5
</td>
<td>
"banana"
</td>
<td>
1
</td>
<td>
"beetle"
</td>
<td>
-30
</td>
</tr>
<tr>
<td>
2
</td>
<td>
"banana"
</td>
<td>
4
</td>
<td>
"audi"
</td>
<td>
300
</td>
<td>
4
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
"beetle"
</td>
<td>
2
</td>
</tr>
<tr>
<td>
3
</td>
<td>
"apple"
</td>
<td>
3
</td>
<td>
"beetle"
</td>
<td>
null
</td>
<td>
3
</td>
<td>
"apple"
</td>
<td>
3
</td>
<td>
"beetle"
</td>
<td>
null
</td>
</tr>
<tr>
<td>
4
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
"beetle"
</td>
<td>
2
</td>
<td>
2
</td>
<td>
"banana"
</td>
<td>
4
</td>
<td>
"audi"
</td>
<td>
300
</td>
</tr>
<tr>
<td>
5
</td>
<td>
"banana"
</td>
<td>
1
</td>
<td>
"beetle"
</td>
<td>
-30
</td>
<td>
1
</td>
<td>
"banana"
</td>
<td>
5
</td>
<td>
"beetle"
</td>
<td>
28
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># all expressions run in parallel
# single valued `Series` are broadcasted to the shape of the `DataFrame`
(df.select([
    pl.all(),
    pl.all().sum().suffix(&quot;_sum&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
fruits
</th>
<th>
B
</th>
<th>
cars
</th>
<th>
optional
</th>
<th>
A_sum
</th>
<th>
fruits_sum
</th>
<th>
B_sum
</th>
<th>
cars_sum
</th>
<th>
optional_sum
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
"banana"
</td>
<td>
5
</td>
<td>
"beetle"
</td>
<td>
28
</td>
<td>
15
</td>
<td>
null
</td>
<td>
15
</td>
<td>
null
</td>
<td>
300
</td>
</tr>
<tr>
<td>
2
</td>
<td>
"banana"
</td>
<td>
4
</td>
<td>
"audi"
</td>
<td>
300
</td>
<td>
15
</td>
<td>
null
</td>
<td>
15
</td>
<td>
null
</td>
<td>
300
</td>
</tr>
<tr>
<td>
3
</td>
<td>
"apple"
</td>
<td>
3
</td>
<td>
"beetle"
</td>
<td>
null
</td>
<td>
15
</td>
<td>
null
</td>
<td>
15
</td>
<td>
null
</td>
<td>
300
</td>
</tr>
<tr>
<td>
4
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
"beetle"
</td>
<td>
2
</td>
<td>
15
</td>
<td>
null
</td>
<td>
15
</td>
<td>
null
</td>
<td>
300
</td>
</tr>
<tr>
<td>
5
</td>
<td>
"banana"
</td>
<td>
1
</td>
<td>
"beetle"
</td>
<td>
-30
</td>
<td>
15
</td>
<td>
null
</td>
<td>
15
</td>
<td>
null
</td>
<td>
300
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># there are `str` and `dt` namespaces for specialized functions

predicate = pl.col(&quot;fruits&quot;).str.contains(&quot;^b.*&quot;)

(df.select([
    predicate
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
</tr>
<tr>
<td>
bool
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
true
</td>
</tr>
<tr>
<td>
true
</td>
</tr>
<tr>
<td>
false
</td>
</tr>
<tr>
<td>
false
</td>
</tr>
<tr>
<td>
true
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># use the predicate to filter

df.filter(predicate)
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
fruits
</th>
<th>
B
</th>
<th>
cars
</th>
<th>
optional
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
"banana"
</td>
<td>
5
</td>
<td>
"beetle"
</td>
<td>
28
</td>
</tr>
<tr>
<td>
2
</td>
<td>
"banana"
</td>
<td>
4
</td>
<td>
"audi"
</td>
<td>
300
</td>
</tr>
<tr>
<td>
5
</td>
<td>
"banana"
</td>
<td>
1
</td>
<td>
"beetle"
</td>
<td>
-30
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># predicate expressions can be used to filter

(df.select([
    pl.col(&quot;A&quot;).filter(pl.col(&quot;fruits&quot;).str.contains(&quot;^b.*&quot;)).sum(),
    (pl.col(&quot;B&quot;).filter(pl.col(&quot;cars&quot;).str.contains(&quot;^b.*&quot;)).sum() * pl.col(&quot;B&quot;).sum()).alias(&quot;some_compute()&quot;),
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
some_compute()
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
8
</td>
<td>
165
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># We can do arithmetic on columns and (literal) values

# can be evaluated to 1 without programmer knowing
some_var = 1

(df.select([
    ((pl.col(&quot;A&quot;) / 124.0 * pl.col(&quot;B&quot;)) / pl.sum(&quot;B&quot;) * some_var).alias(&quot;computed&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
computed
</th>
</tr>
<tr>
<td>
f64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
0.0
</td>
</tr>
<tr>
<td>
0.0
</td>
</tr>
<tr>
<td>
0.0
</td>
</tr>
<tr>
<td>
0.0
</td>
</tr>
<tr>
<td>
0.0
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># We can combine columns by a predicate

(df.select([
    &quot;fruits&quot;,
    &quot;B&quot;,
    pl.when(pl.col(&quot;fruits&quot;) == &quot;banana&quot;).then(pl.col(&quot;B&quot;)).otherwise(-1).alias(&quot;b&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B
</th>
<th>
b
</th>
</tr>
<tr>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"banana"
</td>
<td>
5
</td>
<td>
5
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
4
</td>
<td>
4
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
3
</td>
<td>
-1
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
2
</td>
<td>
-1
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
1
</td>
<td>
1
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># We can combine columns by a fold operation on column level

(df.select([
    &quot;A&quot;,
    &quot;B&quot;,
    pl.fold(0, lambda a, b: a + b, [pl.col(&quot;A&quot;), &quot;B&quot;, pl.col(&quot;B&quot;)**2, pl.col(&quot;A&quot;) / 2.0]).alias(&quot;fold&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
A
</th>
<th>
B
</th>
<th>
fold
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
i64
</td>
<td>
f64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
1
</td>
<td>
5
</td>
<td>
31
</td>
</tr>
<tr>
<td>
2
</td>
<td>
4
</td>
<td>
23
</td>
</tr>
<tr>
<td>
3
</td>
<td>
3
</td>
<td>
16
</td>
</tr>
<tr>
<td>
4
</td>
<td>
2
</td>
<td>
12
</td>
</tr>
<tr>
<td>
5
</td>
<td>
1
</td>
<td>
9
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># even combine all

(df.select([
    pl.arange(0, df.height).alias(&quot;idx&quot;),
    &quot;A&quot;,
    pl.col(&quot;A&quot;).shift().alias(&quot;A_shifted&quot;),
    pl.concat_str(pl.all(), &quot;-&quot;).alias(&quot;str_concat_1&quot;),  # prefer this
    pl.fold(pl.col(&quot;A&quot;), lambda a, b: a + &quot;-&quot; + b, pl.all().exclude(&quot;A&quot;)).alias(&quot;str_concat_2&quot;),  # over this (accidentally O(n^2))
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
idx
</th>
<th>
A
</th>
<th>
A_shifted
</th>
<th>
str_concat_1
</th>
<th>
str_concat_2
</th>
</tr>
<tr>
<td>
i64
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
str
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
0
</td>
<td>
1
</td>
<td>
null
</td>
<td>
"1-banana-5-beetle-28"
</td>
<td>
"1-banana-5-beetle-28"
</td>
</tr>
<tr>
<td>
1
</td>
<td>
2
</td>
<td>
1
</td>
<td>
"2-banana-4-audi-300"
</td>
<td>
"2-banana-4-audi-300"
</td>
</tr>
<tr>
<td>
2
</td>
<td>
3
</td>
<td>
2
</td>
<td>
null
</td>
<td>
null
</td>
</tr>
<tr>
<td>
3
</td>
<td>
4
</td>
<td>
3
</td>
<td>
"4-apple-2-beetle-2"
</td>
<td>
"4-apple-2-beetle-2"
</td>
</tr>
<tr>
<td>
4
</td>
<td>
5
</td>
<td>
4
</td>
<td>
"5-banana-1-beetle--30"
</td>
<td>
"5-banana-1-beetle--30"
</td>
</tr>
</tbody>
</table>
</div>
<h1 id="aggregation-context"><a class="header" href="#aggregation-context">Aggregation context</a></h1>
<ul>
<li>expression are applied over groups instead of columns</li>
</ul>
<pre><code class="language-python"># we can still combine many expressions

(df.sort(&quot;cars&quot;).groupby(&quot;fruits&quot;)
    .agg([
        pl.col(&quot;B&quot;).sum(),
        pl.sum(&quot;B&quot;).alias(&quot;B_sum2&quot;),  # syntactic sugar for the first
        pl.first(&quot;fruits&quot;),
        pl.count(&quot;A&quot;).alias(&quot;count&quot;),
        pl.col(&quot;cars&quot;).reverse()
    ]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B_sum
</th>
<th>
B_sum2
</th>
<th>
fruits_first
</th>
<th>
count
</th>
<th>
cars
</th>
</tr>
<tr>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
u32
</td>
<td>
list
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
[beetle, beetle, audi]
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
5
</td>
<td>
5
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
[beetle, beetle]
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># We can explode the list column &quot;cars&quot;

(df.sort(&quot;cars&quot;).groupby(&quot;fruits&quot;)
    .agg([
        pl.col(&quot;B&quot;).sum(),
        pl.sum(&quot;B&quot;).alias(&quot;B_sum2&quot;),  # syntactic sugar for the first
        pl.first(&quot;fruits&quot;),
        pl.count(&quot;A&quot;).alias(&quot;count&quot;),
        pl.col(&quot;cars&quot;).reverse()
    ])).explode(&quot;cars&quot;)
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B_sum
</th>
<th>
B_sum2
</th>
<th>
fruits_first
</th>
<th>
count
</th>
<th>
cars
</th>
</tr>
<tr>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
u32
</td>
<td>
str
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
5
</td>
<td>
5
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
"beetle"
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
5
</td>
<td>
5
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
"beetle"
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
"beetle"
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
"beetle"
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
"audi"
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python">(df.groupby(&quot;fruits&quot;)
    .agg([
        pl.col(&quot;B&quot;).sum(),
        pl.sum(&quot;B&quot;).alias(&quot;B_sum2&quot;),  # syntactic sugar for the first
        pl.first(&quot;fruits&quot;),
        pl.count(&quot;A&quot;).alias(&quot;count&quot;),
        pl.col(&quot;B&quot;).shift().alias(&quot;B_shifted&quot;)
    ])
 .explode(&quot;B_shifted&quot;)
)
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B_sum
</th>
<th>
B_sum2
</th>
<th>
fruits_first
</th>
<th>
count
</th>
<th>
B_shifted
</th>
</tr>
<tr>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
str
</td>
<td>
u32
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
5
</td>
<td>
5
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
null
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
5
</td>
<td>
5
</td>
<td>
"apple"
</td>
<td>
2
</td>
<td>
3
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
null
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
5
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
10
</td>
<td>
10
</td>
<td>
"banana"
</td>
<td>
3
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># we can also get the list of the groups
(df.groupby(&quot;fruits&quot;)
    .agg([
         pl.col(&quot;B&quot;).shift().alias(&quot;shift_B&quot;),
         pl.col(&quot;B&quot;).reverse().alias(&quot;rev_B&quot;),
    ]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
shift_B
</th>
<th>
rev_B
</th>
</tr>
<tr>
<td>
str
</td>
<td>
list
</td>
<td>
list
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
[null, 3]
</td>
<td>
[2, 3]
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
[null, 5, 4]
</td>
<td>
[1, 4, 5]
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># we can do predicates in the groupby as well

(df.groupby(&quot;fruits&quot;)
    .agg([
        pl.col(&quot;B&quot;).filter(pl.col(&quot;B&quot;) &gt; 1).list().keep_name(),
    ]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B
</th>
</tr>
<tr>
<td>
str
</td>
<td>
list
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"banana"
</td>
<td>
[5, 4]
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
[3, 2]
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># and sum only by the values where the predicates are true

(df.groupby(&quot;fruits&quot;)
    .agg([
        pl.col(&quot;B&quot;).filter(pl.col(&quot;B&quot;) &gt; 1).mean(),
    ]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B_mean
</th>
</tr>
<tr>
<td>
str
</td>
<td>
f64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"banana"
</td>
<td>
4.5
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
2.5
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># Another example
(df.groupby(&quot;fruits&quot;)
    .agg([
        pl.col(&quot;B&quot;).shift_and_fill(1, fill_value=0).alias(&quot;shifted&quot;),
        pl.col(&quot;B&quot;).shift_and_fill(1, fill_value=0).sum().alias(&quot;shifted_sum&quot;),
    ]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
shifted
</th>
<th>
shifted_sum
</th>
</tr>
<tr>
<td>
str
</td>
<td>
list
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
[0, 3]
</td>
<td>
3
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
[0, 5, 4]
</td>
<td>
9
</td>
</tr>
</tbody>
</table>
</div>
<h1 id="window-functions"><a class="header" href="#window-functions">Window functions!</a></h1>
<ul>
<li>Expression with superpowers.</li>
<li>Aggregation in selection context</li>
</ul>
<pre><code class="language-python">pl.col(&quot;foo&quot;).aggregation_expression(..).over(&quot;column_used_to_group&quot;)
</code></pre>
<pre><code class="language-python"># groupby 2 different columns

(df.sort(&quot;fruits&quot;)
.select([
    &quot;fruits&quot;,
    &quot;cars&quot;,
    &quot;B&quot;,
    pl.col(&quot;B&quot;).sum().over(&quot;fruits&quot;).alias(&quot;B_sum_by_fruits&quot;),
    pl.col(&quot;B&quot;).sum().over(&quot;cars&quot;).alias(&quot;B_sum_by_cars&quot;),
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
cars
</th>
<th>
B
</th>
<th>
B_sum_by_fruits
</th>
<th>
B_sum_by_cars
</th>
</tr>
<tr>
<td>
str
</td>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
"beetle"
</td>
<td>
3
</td>
<td>
5
</td>
<td>
11
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
"beetle"
</td>
<td>
2
</td>
<td>
5
</td>
<td>
11
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
"beetle"
</td>
<td>
5
</td>
<td>
10
</td>
<td>
11
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
"audi"
</td>
<td>
4
</td>
<td>
10
</td>
<td>
4
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
"beetle"
</td>
<td>
1
</td>
<td>
10
</td>
<td>
11
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># reverse B by groups and show the results in original DF

(df.sort(&quot;fruits&quot;)
.select([
    &quot;fruits&quot;,
    &quot;B&quot;,
    pl.col(&quot;B&quot;).reverse().over(&quot;fruits&quot;).flatten().alias(&quot;B_reversed_by_fruits&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B
</th>
<th>
B_reversed_by_fruits
</th>
</tr>
<tr>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
3
</td>
<td>
2
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
2
</td>
<td>
3
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
5
</td>
<td>
1
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
4
</td>
<td>
4
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
1
</td>
<td>
5
</td>
</tr>
</tbody>
</table>
</div>
<pre><code class="language-python"># Lag a column within &quot;fruits&quot;
(df
.sort(&quot;fruits&quot;)
.select([
    &quot;fruits&quot;,
    &quot;B&quot;,
    pl.col(&quot;B&quot;).shift().over(&quot;fruits&quot;).flatten().alias(&quot;lag_B_by_fruits&quot;)
]))
</code></pre>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
</style>
<table border="1 "class="dataframe ">
<thead>
<tr>
<th>
fruits
</th>
<th>
B
</th>
<th>
lag_B_by_fruits
</th>
</tr>
<tr>
<td>
str
</td>
<td>
i64
</td>
<td>
i64
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
"apple"
</td>
<td>
3
</td>
<td>
null
</td>
</tr>
<tr>
<td>
"apple"
</td>
<td>
2
</td>
<td>
3
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
5
</td>
<td>
null
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
4
</td>
<td>
5
</td>
</tr>
<tr>
<td>
"banana"
</td>
<td>
1
</td>
<td>
4
</td>
</tr>
</tbody>
</table>
</div>
<h1 id="expression-api"><a class="header" href="#expression-api">Expression API</a></h1>
<p>The full list of possible expressions is available on the <a href="https://pola-rs.github.io/polars/py-polars/html/reference/expression.html"><code>Expr</code></a>
class definition in the reference guide.</p>
<h1 id="indexing"><a class="header" href="#indexing">Indexing</a></h1>
<p>Polars DataFrames don't have an index and therefore indexing behavior can be consistent without the need of a <code>df.loc</code>,
<code>df.iloc</code>, or a <code>df.at</code> operation.</p>
<p>The rules are as follows, depending on the datatypes of the index values:</p>
<ul>
<li>
<p><strong>numeric</strong></p>
<ul>
<li>axis 0: row</li>
<li>axis 1: column</li>
</ul>
</li>
<li>
<p><strong>numeric + strings</strong></p>
<ul>
<li>axis 0: row (only accept numbers here)</li>
<li>axis 1: column (accept numeric + string values)</li>
</ul>
</li>
<li>
<p><strong>only strings</strong></p>
<ul>
<li>axis 0: column</li>
<li>axis 1: error</li>
</ul>
</li>
<li>
<p><strong>expressions</strong></p>
<p><em>All expression evaluations are executed in parallel</em></p>
<ul>
<li>axis 0: column</li>
<li>axis 1: column</li>
<li>..</li>
<li>axis n: column</li>
</ul>
</li>
</ul>
<h2 id="comparison-with-pandas"><a class="header" href="#comparison-with-pandas">Comparison with pandas</a></h2>
<table><thead><tr><th>pandas</th><th>polars</th></tr></thead><tbody>
<tr><td>select row<br> <code>df.iloc[2]</code></td><td><code>df[2, :]</code></td></tr>
<tr><td>select several rows by their indices<br> <code>df.iloc[[2, 5, 6]]</code></td><td><code>df[[2, 5, 6], :]</code></td></tr>
<tr><td>select slice of rows<br> <code>df.iloc[2:6]</code></td><td><code>df[2:6, :]</code></td></tr>
<tr><td>select rows using a boolean mask<br> <code>df.iloc[True, True, False]</code></td><td><code>df[[True, True, False]]</code></td></tr>
<tr><td>select slice of rows<br> <code>df.iloc[2:6]</code></td><td><code>df[2:6, :]</code></td></tr>
<tr><td>select rows by a predicate condition<br> <code>df.loc[df[&quot;A&quot;] &gt; 3]</code></td><td><code>df[df[&quot;A&quot;] &gt; 3]</code></td></tr>
<tr><td>select slice of columns<br> <code>df.iloc[:, 1:3]</code></td><td><code>df[:, 1:3]</code></td></tr>
<tr><td>select slice of columns by string order<br> <code>df.loc[:, &quot;A&quot;:&quot;Z&quot;]</code></td><td><code>df[:, &quot;A&quot;:&quot;Z&quot;]</code></td></tr>
<tr><td>select a single value (scalar)<br> <code>df.loc[2, &quot;A&quot;]</code></td><td><code>df[2, &quot;A&quot;]</code></td></tr>
<tr><td>select a single value (scalar)<br> <code>df.iloc[2, 1]</code></td><td><code>df[2, 1]</code></td></tr>
<tr><td>select a single value (Series/DataFrame)<br> <code>df.loc[2, [&quot;A&quot;]]</code></td><td><code>df[2, [&quot;A&quot;]]</code></td></tr>
<tr><td>select a single value (Series/DataFrame)<br> <code>df.iloc[2, [1]]</code></td><td><code>df[2, [1]]</code></td></tr>
</tbody></table>
<h2 id="expressions-1"><a class="header" href="#expressions-1">Expressions</a></h2>
<p>Expressions can also be used in indexing (it is syntactic sugar for <code>df.select</code>).</p>
<p>This can be used to do some pretty exotic selections.</p>
<pre><code class="language-python">df[[
    pl.col(&quot;A&quot;).head(5),  # get first of &quot;A&quot;
    pl.col(&quot;B&quot;).tail(5).reverse(), # get last of &quot;B&quot; in reversed order
    pl.col(&quot;B&quot;).filter(pl.col(&quot;B&quot;) &gt; 5).head(5), # get first of &quot;B&quot; that fulfils predicate
    pl.sum(&quot;A&quot;).over(&quot;B&quot;).head(5) # get the sum aggregation of &quot;A&quot; over the groups of &quot;B&quot; and return the first 5
]]
</code></pre>
<h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>Polars is entirely based on Arrow data types and backed by Arrow memory arrays. This makes data processing
cache-efficient and well-supported for Inter Process Communication. Most data types follow the exact implementation
from Arrow, with exception of <code>Utf8</code> (this is actually <code>LargeUtf8</code>), <code>Categorical</code>, and <code>Object</code> (support is limited).</p>
<p>The data types are:</p>
<ul>
<li><code>Int8</code>: 8-bit signed integer.</li>
<li><code>Int16</code>: 16-bit signed integer.</li>
<li><code>Int32</code>: 32-bit signed integer.</li>
<li><code>Int64</code>: 64-bit signed integer.</li>
<li><code>UInt8</code>: 8-bit unsigned integer.</li>
<li><code>UInt16</code>: 16-bit unsigned integer.</li>
<li><code>UInt32</code>: 32-bit unsigned integer.</li>
<li><code>UInt64</code>: 64-bit unsigned integer.</li>
<li><code>Float32</code>: 32-bit floating point.</li>
<li><code>Float64</code>: 64-bit floating point.</li>
<li><code>Boolean</code>: Boolean type effectively bit packed.</li>
<li><code>Utf8</code>: String data (this is actually Arrow <code>LargeUtf8</code> internally).</li>
<li><code>List</code>: A list array contains a child array containing the list values and an offset array. (this is actually Arrow <code>LargeList</code> internally).</li>
<li><code>Date</code>: Date representation, internally represented as days since UNIX epoch encoded by a 32-bit signed integer.</li>
<li><code>Datetime</code>: Datetime representation, internally represented as milliseconds since UNIX epoch encoded by a 64-bit signed integer.</li>
<li><code>Object</code>: A limited supported data type that can be any value.</li>
</ul>
<p>To learn more about the internal representation of these data types, check the <a href="https://arrow.apache.org/docs/format/Columnar.html">Arrow columnar format</a>.</p>
<h1 id="coming-from-pandas"><a class="header" href="#coming-from-pandas">Coming from pandas</a></h1>
<p>Users coming from <code>pandas</code> generally need to know one thing...</p>
<pre><code>polars != pandas
</code></pre>
<p>If your polars code looks like it could be pandas code, it might run, but it likely runs slower than it has to be.</p>
<p>Let's go through some typical pandas code and see how we might write that in polars</p>
<h2 id="column-assignment"><a class="header" href="#column-assignment">Column assignment</a></h2>
<p><strong>pandas</strong></p>
<pre><code class="language-python"># executes sequential
df[&quot;a&quot;] = df[&quot;b&quot;] * 10
df[&quot;c&quot;] = df[&quot;b&quot;] * 100
</code></pre>
<p><strong>polars</strong></p>
<pre><code class="language-python"># executes in parallel
df.with_columns([
    (pl.col(&quot;b&quot;) * 10).alias(&quot;a&quot;),
    (pl.col(&quot;b&quot;) * 100).alias(&quot;b&quot;),
])
</code></pre>
<h2 id="filtering-1"><a class="header" href="#filtering-1">Filtering</a></h2>
<p><strong>pandas</strong></p>
<pre><code class="language-python">df.loc[(df['sqft_living'] &gt; 2500) &amp; (df['price'] &lt; 300000)]
</code></pre>
<p><strong>polars</strong></p>
<pre><code class="language-python">df.filter(
    (pl.col(&quot;m2_living&quot;) &gt; 2500) &amp; (pl.col(&quot;price&quot;) &lt; 300000)
)
</code></pre>
<blockquote>
<p>More in redaction. Miss something? make a PR :).</p>
</blockquote>
<h2 id="no-index"><a class="header" href="#no-index">No index</a></h2>
<p>They are not needed. Not having them makes things easier. Convince me otherwise</p>
<h1 id="how-can-i"><a class="header" href="#how-can-i">How can I?</a></h1>
<p>This chapter contains some snippets that will get you up to speed with the most
idiomatic way to get things done in <code>Polars</code>.</p>
<h1 id="manipulate-a-polars-dataframe"><a class="header" href="#manipulate-a-polars-dataframe">Manipulate a Polars DataFrame</a></h1>
<h1 id="common-manipulations"><a class="header" href="#common-manipulations">Common manipulations</a></h1>
<p>Like other DataFrame libaries, Polars provides a wide range of common functions to
manipulate a Dataframe. Users that are familiar with Dataframes will see many
similarities with <code>Pandas</code> or <code>R</code> implementations.</p>
<h2 id="add-columns"><a class="header" href="#add-columns">Add columns</a></h2>
<pre><code class="language-python">out = df.with_column(pl.Series([&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;]).alias(&quot;e&quot;))
print(out)
</code></pre>
<pre><code class="language-text">shape: (5, 5)
┌──────┬──────┬─────────────────────┬─────┬─────┐
│ a    ┆ b    ┆ c                   ┆ d   ┆ e   │
│ ---  ┆ ---  ┆ ---                 ┆ --- ┆ --- │
│ i64  ┆ str  ┆ f64                 ┆ str ┆ str │
╞══════╪══════╪═════════════════════╪═════╪═════╡
│ 1    ┆ foo  ┆ 0.3745401188473625  ┆ a   ┆ p   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2    ┆ ham  ┆ 0.9507143064099162  ┆ b   ┆ q   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 3    ┆ spam ┆ 0.7319939418114051  ┆ c   ┆ r   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ null ┆ egg  ┆ 0.5986584841970366  ┆ d   ┆ s   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 5    ┆ null ┆ 0.15601864044243652 ┆ e   ┆ t   │
└──────┴──────┴─────────────────────┴─────┴─────┘
</code></pre>
<h2 id="type-casting"><a class="header" href="#type-casting">Type casting</a></h2>
<p>In this example we use Python datatypes, but we can also cast with Polars dtypes like
<code>pl.Float32</code> or <code>pl.Float64</code></p>
<pre><code class="language-python">out = df.with_column(pl.col(&quot;a&quot;).cast(float))
print(out)
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌──────┬──────┬─────────────────────┬─────┐
│ a    ┆ b    ┆ c                   ┆ d   │
│ ---  ┆ ---  ┆ ---                 ┆ --- │
│ f64  ┆ str  ┆ f64                 ┆ str │
╞══════╪══════╪═════════════════════╪═════╡
│ 1    ┆ foo  ┆ 0.3745401188473625  ┆ a   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 2    ┆ ham  ┆ 0.9507143064099162  ┆ b   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 3    ┆ spam ┆ 0.7319939418114051  ┆ c   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ null ┆ egg  ┆ 0.5986584841970366  ┆ d   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 5    ┆ null ┆ 0.15601864044243652 ┆ e   │
└──────┴──────┴─────────────────────┴─────┘
</code></pre>
<h2 id="rename-column"><a class="header" href="#rename-column">Rename column</a></h2>
<pre><code class="language-python">import numpy as np
import polars as pl

df = pl.DataFrame(
    {
        &quot;a&quot;: [1, 2, 3, None, 5],
        &quot;b&quot;: [&quot;foo&quot;, &quot;ham&quot;, &quot;spam&quot;, &quot;egg&quot;, None],
        &quot;c&quot;: np.random.rand(5),
        &quot;d&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;],
    }
)

df.columns = [&quot;banana&quot;, &quot;orange&quot;, &quot;apple&quot;, &quot;grapefruit&quot;]
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌────────┬────────┬─────────────────────┬────────────┐
│ banana ┆ orange ┆ apple               ┆ grapefruit │
│ ---    ┆ ---    ┆ ---                 ┆ ---        │
│ i64    ┆ str    ┆ f64                 ┆ str        │
╞════════╪════════╪═════════════════════╪════════════╡
│ 1      ┆ foo    ┆ 0.15599452033620265 ┆ a          │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2      ┆ ham    ┆ 0.05808361216819946 ┆ b          │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3      ┆ spam   ┆ 0.8661761457749352  ┆ c          │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ null   ┆ egg    ┆ 0.6011150117432088  ┆ d          │
├╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5      ┆ null   ┆ 0.7080725777960455  ┆ e          │
└────────┴────────┴─────────────────────┴────────────┘
</code></pre>
<h2 id="drop-column"><a class="header" href="#drop-column">Drop column</a></h2>
<pre><code class="language-python">
# drop single column
out = df.drop(&quot;d&quot;)

# drop multiple columns
out = df.drop([&quot;b&quot;, &quot;c&quot;])

# select all but &quot;b&quot; and &quot;c&quot;
out = df.select(pl.all().exclude([&quot;b&quot;, &quot;c&quot;]))

# select only &quot;a&quot;
out = df.select(pl.col(&quot;a&quot;))
</code></pre>
<pre><code class="language-text">shape: (5, 1)
┌──────┐
│ a    │
│ ---  │
│ i64  │
╞══════╡
│ 1    │
├╌╌╌╌╌╌┤
│ 2    │
├╌╌╌╌╌╌┤
│ 3    │
├╌╌╌╌╌╌┤
│ null │
├╌╌╌╌╌╌┤
│ 5    │
└──────┘
</code></pre>
<h2 id="drop-nulls"><a class="header" href="#drop-nulls">Drop nulls</a></h2>
<pre><code class="language-python">df.drop_nulls()
</code></pre>
<pre><code class="language-text">shape: (3, 4)
┌─────┬──────┬────────────────────┬─────┐
│ a   ┆ b    ┆ c                  ┆ d   │
│ --- ┆ ---  ┆ ---                ┆ --- │
│ i64 ┆ str  ┆ f64                ┆ str │
╞═════╪══════╪════════════════════╪═════╡
│ 1   ┆ foo  ┆ 0.3745401188473625 ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ ham  ┆ 0.9507143064099162 ┆ b   │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ spam ┆ 0.7319939418114051 ┆ c   │
└─────┴──────┴────────────────────┴─────┘
</code></pre>
<h2 id="fill-na"><a class="header" href="#fill-na">Fill NA</a></h2>
<p>Other strategies:</p>
<ul>
<li><code>mean</code></li>
<li><code>backward</code></li>
<li><code>min</code></li>
<li><code>max</code></li>
</ul>
<pre><code class="language-python">df.fill_none(&quot;forward&quot;)
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌─────┬──────┬─────────────────────┬─────┐
│ a   ┆ b    ┆ c                   ┆ d   │
│ --- ┆ ---  ┆ ---                 ┆ --- │
│ i64 ┆ str  ┆ f64                 ┆ str │
╞═════╪══════╪═════════════════════╪═════╡
│ 1   ┆ foo  ┆ 0.3745401188473625  ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ ham  ┆ 0.9507143064099162  ┆ b   │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ spam ┆ 0.7319939418114051  ┆ c   │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ egg  ┆ 0.5986584841970366  ┆ d   │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 5   ┆ egg  ┆ 0.15601864044243652 ┆ e   │
└─────┴──────┴─────────────────────┴─────┘
</code></pre>
<h2 id="get-columns"><a class="header" href="#get-columns">Get columns</a></h2>
<pre><code class="language-python">df.columns
</code></pre>
<pre><code class="language-text">['a', 'b', 'c', 'd']
</code></pre>
<h2 id="null-count"><a class="header" href="#null-count">Null Count</a></h2>
<pre><code class="language-python">df.null_count()
</code></pre>
<pre><code class="language-text">shape: (1, 4)
┌─────┬─────┬─────┬─────┐
│ a   ┆ b   ┆ c   ┆ d   │
│ --- ┆ --- ┆ --- ┆ --- │
│ u32 ┆ u32 ┆ u32 ┆ u32 │
╞═════╪═════╪═════╪═════╡
│ 1   ┆ 1   ┆ 0   ┆ 0   │
└─────┴─────┴─────┴─────┘
</code></pre>
<h2 id="sort-columns"><a class="header" href="#sort-columns">Sort columns</a></h2>
<pre><code class="language-python">df.sort(&quot;a&quot;, reverse=True)
</code></pre>
<pre><code class="language-text">shape: (5, 4)
┌──────┬──────┬─────────────────────┬─────┐
│ a    ┆ b    ┆ c                   ┆ d   │
│ ---  ┆ ---  ┆ ---                 ┆ --- │
│ i64  ┆ str  ┆ f64                 ┆ str │
╞══════╪══════╪═════════════════════╪═════╡
│ 5    ┆ null ┆ 0.15601864044243652 ┆ e   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 3    ┆ spam ┆ 0.7319939418114051  ┆ c   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 2    ┆ ham  ┆ 0.9507143064099162  ┆ b   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 1    ┆ foo  ┆ 0.3745401188473625  ┆ a   │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ null ┆ egg  ┆ 0.5986584841970366  ┆ d   │
└──────┴──────┴─────────────────────┴─────┘
</code></pre>
<h2 id="to-numpy"><a class="header" href="#to-numpy">To Numpy</a></h2>
<pre><code class="language-python">df.to_numpy()
</code></pre>
<pre><code class="language-text">[[1.0 'foo' 0.3745401188473625 'a']
 [2.0 'ham' 0.9507143064099162 'b']
 [3.0 'spam' 0.7319939418114051 'c']
 [nan 'egg' 0.5986584841970366 'd']
 [5.0 None 0.15601864044243652 'e']]
</code></pre>
<h2 id="to-pandas"><a class="header" href="#to-pandas">To Pandas</a></h2>
<pre><code class="language-python">df.to_pandas()
</code></pre>
<pre><code class="language-text">     a     b         c  d
0  1.0   foo  0.374540  a
1  2.0   ham  0.950714  b
2  3.0  spam  0.731994  c
3  NaN   egg  0.598658  d
4  5.0  None  0.156019  e
</code></pre>
<h1 id="row-and-column-selection"><a class="header" href="#row-and-column-selection">Row and column selection</a></h1>
<p>Selection of rows and columns is similar to other DataFrame libraries.</p>
<h2 id="column-selection"><a class="header" href="#column-selection">Column selection</a></h2>
<pre><code class="language-python">df[[&quot;a&quot;, &quot;b&quot;]]
</code></pre>
<pre><code class="language-text">shape: (5, 2)
┌──────┬──────┐
│ a    ┆ b    │
│ ---  ┆ ---  │
│ i64  ┆ str  │
╞══════╪══════╡
│ 1    ┆ foo  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 2    ┆ ham  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 3    ┆ spam │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ null ┆ egg  │
├╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ 5    ┆ null │
└──────┴──────┘
</code></pre>
<h2 id="row-selection"><a class="header" href="#row-selection">Row selection</a></h2>
<pre><code class="language-python">df[0:2]
</code></pre>
<pre><code class="language-text">shape: (2, 4)
┌─────┬─────┬────────────────────┬─────┐
│ a   ┆ b   ┆ c                  ┆ d   │
│ --- ┆ --- ┆ ---                ┆ --- │
│ i64 ┆ str ┆ f64                ┆ str │
╞═════╪═════╪════════════════════╪═════╡
│ 1   ┆ foo ┆ 0.3745401188473625 ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ ham ┆ 0.9507143064099162 ┆ b   │
└─────┴─────┴────────────────────┴─────┘
</code></pre>
<h1 id="filter"><a class="header" href="#filter">Filter</a></h1>
<h2 id="eager"><a class="header" href="#eager">Eager</a></h2>
<p>Filter operation in Eager are very similar to what you are used in <code>Pandas</code>.</p>
<pre><code class="language-python">import polars as pl

df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [None, &quot;b&quot;, &quot;c&quot;]})

mask = df[&quot;a&quot;] &gt; 2
out = df[mask]
</code></pre>
<p>or in more idiomatic <code>Polars</code> way:</p>
<pre><code class="language-python">df.filter(pl.col(&quot;a&quot;) &gt; 2)
</code></pre>
<h2 id="lazy"><a class="header" href="#lazy">Lazy</a></h2>
<p>Filters operations in Lazy are expressed as:</p>
<pre><code class="language-python">
df = pl.DataFrame({&quot;a&quot;: [1, 2, 3], &quot;b&quot;: [None, &quot;b&quot;, &quot;c&quot;]})

out = df.lazy().filter(pl.col(&quot;a&quot;) &gt; 2).collect()
</code></pre>
<p>Both result in:</p>
<pre><code class="language-text">shape: (1, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ str │
╞═════╪═════╡
│ 3   ┆ c   │
└─────┴─────┘
</code></pre>
<h1 id="sorting-1"><a class="header" href="#sorting-1">Sorting</a></h1>
<p>Polars supports sorting behavior similar to other DataFrame libraries, that is sorting
by one or multiple columns and in multiple/different orders.</p>
<h2 id="dataset"><a class="header" href="#dataset">Dataset</a></h2>
<pre><code class="language-python">import numpy as np
import polars as pl

df = pl.DataFrame({&quot;a&quot;: np.arange(1, 4), &quot;b&quot;: [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;]})
print(df)
</code></pre>
<pre><code class="language-text">shape: (3, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ str │
╞═════╪═════╡
│ 1   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ b   │
└─────┴─────┘
</code></pre>
<h2 id="eager-1"><a class="header" href="#eager-1">Eager</a></h2>
<pre><code class="language-python">out = df.sort([&quot;b&quot;, &quot;a&quot;], reverse=[True, False])
print(out)
</code></pre>
<pre><code class="language-text">shape: (3, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ str │
╞═════╪═════╡
│ 1   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 3   ┆ b   │
└─────┴─────┘
</code></pre>
<h2 id="lazy-1"><a class="header" href="#lazy-1">Lazy</a></h2>
<pre><code class="language-python">import polars as pl

q = df.lazy().sort(pl.col(&quot;a&quot;), reverse=True)
df = q.collect()
print(out)
</code></pre>
<pre><code class="language-text">shape: (3, 2)
┌─────┬─────┐
│ a   ┆ b   │
│ --- ┆ --- │
│ i64 ┆ str │
╞═════╪═════╡
│ 3   ┆ b   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ a   │
├╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ a   │
└─────┴─────┘
</code></pre>
<h1 id="groupby-1"><a class="header" href="#groupby-1">GroupBy</a></h1>
<h2 id="eager--lazy"><a class="header" href="#eager--lazy">Eager &amp; Lazy</a></h2>
<p>Groupby syntax is similar in both API's as both can use the expressions.
Grouping operations are done with the <code>.groupby()</code> method following by the <code>.agg()</code>
method.</p>
<p>In the <code>.agg()</code> method you can do as many aggregations on as many columns as you want.
Aggregation on all columns can be performed using the wildcard expression:
<code>.agg(pl.col(&quot;*&quot;).sum())</code>.</p>
<p>A quick (lazy) example:</p>
<pre><code class="language-python">import polars as pl

q = (
    pl.scan_csv(&quot;data/reddit.csv&quot;)
    .groupby(&quot;comment_karma&quot;)
    .agg([pl.col(&quot;name&quot;).n_unique().alias(&quot;unique_names&quot;), pl.max(&quot;link_karma&quot;)])
    .sort(by=&quot;unique_names&quot;, reverse=True)
)

df = q.fetch()
</code></pre>
<p>that would return:</p>
<pre><code class="language-text">shape: (100, 3)
┌───────────────┬──────────────┬────────────────┐
│ comment_karma ┆ unique_names ┆ link_karma_max │
│ ---           ┆ ---          ┆ ---            │
│ i64           ┆ u32          ┆ i64            │
╞═══════════════╪══════════════╪════════════════╡
│ 0             ┆ 367          ┆ 611            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1             ┆ 9            ┆ 22             │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3             ┆ 6            ┆ 1              │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 38            ┆ 4            ┆ 291            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ ...           ┆ ...          ┆ ...            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 97            ┆ 1            ┆ 324            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3917          ┆ 1            ┆ 315            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 835           ┆ 1            ┆ 1154           │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 936           ┆ 1            ┆ 841            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 505           ┆ 1            ┆ 953            │
└───────────────┴──────────────┴────────────────┘
</code></pre>
<h1 id="joins"><a class="header" href="#joins">Joins</a></h1>
<p>Polars supports sorting behavior similar to other DataFrame libraries.</p>
<ul>
<li>Join on a single or multiple column(s)</li>
<li>Left join</li>
<li>Inner join</li>
<li>Outer join</li>
</ul>
<h2 id="dataset-1"><a class="header" href="#dataset-1">Dataset</a></h2>
<pre><code class="language-python">import polars as pl

df_a = pl.DataFrame({&quot;a&quot;: [1, 2, 1, 1], &quot;b&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;], &quot;c&quot;: [0, 1, 2, 3]})

df_b = pl.DataFrame({&quot;foo&quot;: [1, 1, 1], &quot;bar&quot;: [&quot;a&quot;, &quot;c&quot;, &quot;c&quot;], &quot;ham&quot;: [&quot;let&quot;, &quot;var&quot;, &quot;const&quot;]})
print(df_a)
</code></pre>
<pre><code class="language-text">shape: (4, 3)
┌─────┬─────┬─────┐
│ a   ┆ b   ┆ c   │
│ --- ┆ --- ┆ --- │
│ i64 ┆ str ┆ i64 │
╞═════╪═════╪═════╡
│ 1   ┆ a   ┆ 0   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 2   ┆ b   ┆ 1   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ c   ┆ 2   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ 1   ┆ c   ┆ 3   │
└─────┴─────┴─────┘
</code></pre>
<pre><code class="language-python">print(df_b)
</code></pre>
<pre><code class="language-text">shape: (3, 3)
┌─────┬─────┬───────┐
│ foo ┆ bar ┆ ham   │
│ --- ┆ --- ┆ ---   │
│ i64 ┆ str ┆ str   │
╞═════╪═════╪═══════╡
│ 1   ┆ a   ┆ let   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1   ┆ c   ┆ var   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1   ┆ c   ┆ const │
└─────┴─────┴───────┘
</code></pre>
<h2 id="eager-2"><a class="header" href="#eager-2">Eager</a></h2>
<pre><code class="language-python">
out = df_a.join(df_b, left_on=[&quot;a&quot;, &quot;b&quot;], right_on=[&quot;foo&quot;, &quot;bar&quot;], how=&quot;left&quot;)
print(out)
</code></pre>
<pre><code class="language-text">shape: (6, 4)
┌─────┬─────┬─────┬───────┐
│ a   ┆ b   ┆ c   ┆ ham   │
│ --- ┆ --- ┆ --- ┆ ---   │
│ i64 ┆ str ┆ i64 ┆ str   │
╞═════╪═════╪═════╪═══════╡
│ 1   ┆ a   ┆ 0   ┆ let   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2   ┆ b   ┆ 1   ┆ null  │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1   ┆ c   ┆ 2   ┆ var   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1   ┆ c   ┆ 2   ┆ const │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1   ┆ c   ┆ 3   ┆ var   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1   ┆ c   ┆ 3   ┆ const │
└─────┴─────┴─────┴───────┘
</code></pre>
<h2 id="lazy-2"><a class="header" href="#lazy-2">Lazy</a></h2>
<pre><code class="language-python">
q = df_a.lazy().join(df_b.lazy(), left_on=&quot;a&quot;, right_on=&quot;foo&quot;, how=&quot;outer&quot;)
out = q.collect()
print(out)
</code></pre>
<pre><code class="language-text">shape: (10, 5)
┌─────┬─────┬─────┬──────┬───────┐
│ b   ┆ c   ┆ a   ┆ bar  ┆ ham   │
│ --- ┆ --- ┆ --- ┆ ---  ┆ ---   │
│ str ┆ i64 ┆ i64 ┆ str  ┆ str   │
╞═════╪═════╪═════╪══════╪═══════╡
│ a   ┆ 0   ┆ 1   ┆ a    ┆ let   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ a   ┆ 0   ┆ 1   ┆ c    ┆ var   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ a   ┆ 0   ┆ 1   ┆ c    ┆ const │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ b   ┆ 1   ┆ 2   ┆ null ┆ null  │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ ... ┆ ... ┆ ... ┆ ...  ┆ ...   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ c   ┆ 2   ┆ 1   ┆ c    ┆ var   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ c   ┆ 2   ┆ 1   ┆ c    ┆ const │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ c   ┆ 3   ┆ 1   ┆ a    ┆ let   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ c   ┆ 3   ┆ 1   ┆ c    ┆ var   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ c   ┆ 3   ┆ 1   ┆ c    ┆ const │
└─────┴─────┴─────┴──────┴───────┘
</code></pre>
<h1 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h1>
<p>Column Aggregations can be within via a <code>.select()</code> or the <code>.with_column()</code>/<code>.with_columns()</code>
context.</p>
<p>Aggregation on all columns can be performed using the wildcard expression:
<code>.select(pl.col(&quot;*&quot;).sum())</code>.</p>
<p>For instance:</p>
<pre><code class="language-python">import polars as pl

q = pl.scan_csv(&quot;data/reddit.csv&quot;).select([pl.sum(&quot;comment_karma&quot;), pl.min(&quot;link_karma&quot;)])

df = q.fetch()
</code></pre>
<p>yielding:</p>
<pre><code class="language-text">shape: (1, 2)
┌───────────────┬────────────┐
│ comment_karma ┆ link_karma │
│ ---           ┆ ---        │
│ i64           ┆ i64        │
╞═══════════════╪════════════╡
│ 242649        ┆ -109       │
└───────────────┴────────────┘
</code></pre>
<p>See more in the <a href="https://pola-rs.github.io/polars/py-polars/html/reference/expression.html#aggregation">API docs of Expr</a></p>
<h1 id="conditionally-apply"><a class="header" href="#conditionally-apply">Conditionally apply</a></h1>
<p>Modifying a <code>Series</code> or a column in a <code>DataFrame</code> consists of two steps.</p>
<ol>
<li>Creating a <code>boolean</code> <code>mask</code> based on some predicate.</li>
<li>Replace the values where the <code>mask</code> evaluates <code>True</code></li>
<li>(Only in lazy) Define values where the mask evaluates <code>False</code></li>
</ol>
<h2 id="dataset-2"><a class="header" href="#dataset-2">Dataset</a></h2>
<pre><code class="language-python">import numpy as np
import polars as pl

df = pl.DataFrame({&quot;range&quot;: np.arange(10), &quot;left&quot;: [&quot;foo&quot;] * 10, &quot;right&quot;: [&quot;bar&quot;] * 10})
df.head()
</code></pre>
<pre><code class="language-text">shape: (5, 3)
┌───────┬──────┬───────┐
│ range ┆ left ┆ right │
│ ---   ┆ ---  ┆ ---   │
│ i64   ┆ str  ┆ str   │
╞═══════╪══════╪═══════╡
│ 0     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 4     ┆ foo  ┆ bar   │
└───────┴──────┴───────┘
</code></pre>
<h2 id="eager-3"><a class="header" href="#eager-3">Eager</a></h2>
<pre><code class="language-python">
df = df.clone()
mask = df[&quot;range&quot;] &gt;= 5
df[mask, &quot;range&quot;] = 12
</code></pre>
<pre><code class="language-text">shape: (10, 3)
┌───────┬──────┬───────┐
│ range ┆ left ┆ right │
│ ---   ┆ ---  ┆ ---   │
│ i64   ┆ str  ┆ str   │
╞═══════╪══════╪═══════╡
│ 0     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 1     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 3     ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ ...   ┆ ...  ┆ ...   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 12    ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 12    ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 12    ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 12    ┆ foo  ┆ bar   │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 12    ┆ foo  ┆ bar   │
└───────┴──────┴───────┘
</code></pre>
<h2 id="lazy-3"><a class="header" href="#lazy-3">Lazy</a></h2>
<p>In lazy we can use the <code>.when()</code>/<code>.then()</code>/<code>.otherwise()</code> expressions.</p>
<ul>
<li><code>when</code> - accepts a predicate expression</li>
<li><code>then</code> - expression to use when <code>predicate == True</code></li>
<li><code>otherwise</code> - expression to use when <code>predicate == False</code></li>
</ul>
<p>See:</p>
<pre><code class="language-python">
q = df.lazy().with_column(
    pl.when(pl.col(&quot;range&quot;) &gt;= 5).then(pl.col(&quot;left&quot;)).otherwise(pl.col(&quot;right&quot;)).alias(&quot;foo_or_bar&quot;)
)

df = q.collect()
print(df)
</code></pre>
<pre><code class="language-text">shape: (10, 4)
┌───────┬──────┬───────┬────────────┐
│ range ┆ left ┆ right ┆ foo_or_bar │
│ ---   ┆ ---  ┆ ---   ┆ ---        │
│ i64   ┆ str  ┆ str   ┆ str        │
╞═══════╪══════╪═══════╪════════════╡
│ 0     ┆ foo  ┆ bar   ┆ bar        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1     ┆ foo  ┆ bar   ┆ bar        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2     ┆ foo  ┆ bar   ┆ bar        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3     ┆ foo  ┆ bar   ┆ bar        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ ...   ┆ ...  ┆ ...   ┆ ...        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5     ┆ foo  ┆ bar   ┆ foo        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 6     ┆ foo  ┆ bar   ┆ foo        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 7     ┆ foo  ┆ bar   ┆ foo        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 8     ┆ foo  ┆ bar   ┆ foo        │
├╌╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 9     ┆ foo  ┆ bar   ┆ foo        │
└───────┴──────┴───────┴────────────┘
</code></pre>
<h1 id="melts"><a class="header" href="#melts">Melts</a></h1>
<p>Melt operations unpivot a DataFrame from wide format to long format</p>
<h2 id="dataset-3"><a class="header" href="#dataset-3">Dataset</a></h2>
<pre><code class="language-python">import polars as pl

df = pl.DataFrame({&quot;A&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;a&quot;], &quot;B&quot;: [1, 3, 5], &quot;C&quot;: [10, 11, 12], &quot;D&quot;: [2, 4, 6]})
print(df)
</code></pre>
<pre><code class="language-text">shape: (3, 4)
┌─────┬─────┬─────┬─────┐
│ A   ┆ B   ┆ C   ┆ D   │
│ --- ┆ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ i64 ┆ i64 │
╞═════╪═════╪═════╪═════╡
│ a   ┆ 1   ┆ 10  ┆ 2   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ b   ┆ 3   ┆ 11  ┆ 4   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ a   ┆ 5   ┆ 12  ┆ 6   │
└─────┴─────┴─────┴─────┘
</code></pre>
<h2 id="eager--lazy-1"><a class="header" href="#eager--lazy-1">Eager + Lazy</a></h2>
<p><code>Eager</code> and <code>lazy</code> have the same API.</p>
<pre><code class="language-python">out = df.melt(id_vars=[&quot;A&quot;, &quot;B&quot;], value_vars=[&quot;C&quot;, &quot;D&quot;])
print(out)
</code></pre>
<pre><code class="language-text">shape: (6, 4)
┌─────┬─────┬──────────┬───────┐
│ A   ┆ B   ┆ variable ┆ value │
│ --- ┆ --- ┆ ---      ┆ ---   │
│ str ┆ i64 ┆ str      ┆ i64   │
╞═════╪═════╪══════════╪═══════╡
│ a   ┆ 1   ┆ C        ┆ 10    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ b   ┆ 3   ┆ C        ┆ 11    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ a   ┆ 5   ┆ C        ┆ 12    │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ a   ┆ 1   ┆ D        ┆ 2     │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ b   ┆ 3   ┆ D        ┆ 4     │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ a   ┆ 5   ┆ D        ┆ 6     │
└─────┴─────┴──────────┴───────┘
</code></pre>
<h1 id="pivots"><a class="header" href="#pivots">Pivots</a></h1>
<p>Pivot a column in a <code>DataFrame</code> and perform one of the following aggregations:</p>
<ul>
<li>first</li>
<li>sum</li>
<li>min</li>
<li>max</li>
<li>mean</li>
<li>median</li>
</ul>
<p>The pivot operation consists of a group by one, or multiple columns (these will be the
new y-axis), column that will be pivoted (this will be the new x-axis) and an
aggregation.</p>
<h2 id="dataset-4"><a class="header" href="#dataset-4">Dataset</a></h2>
<pre><code class="language-python">import polars as pl

df = pl.DataFrame(
    {
        &quot;foo&quot;: [&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;],
        &quot;N&quot;: [1, 2, 2, 4, 2],
        &quot;bar&quot;: [&quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;],
    }
)
print(df)
</code></pre>
<pre><code class="language-text">shape: (5, 3)
┌─────┬─────┬─────┐
│ foo ┆ N   ┆ bar │
│ --- ┆ --- ┆ --- │
│ str ┆ i64 ┆ str │
╞═════╪═════╪═════╡
│ A   ┆ 1   ┆ k   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ A   ┆ 2   ┆ l   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ B   ┆ 2   ┆ m   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ B   ┆ 4   ┆ n   │
├╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌┤
│ C   ┆ 2   ┆ o   │
└─────┴─────┴─────┘
</code></pre>
<h2 id="eager-4"><a class="header" href="#eager-4">Eager</a></h2>
<pre><code class="language-python">
out = df.groupby(&quot;foo&quot;).pivot(pivot_column=&quot;bar&quot;, values_column=&quot;N&quot;).first()
</code></pre>
<h2 id="lazy-4"><a class="header" href="#lazy-4">Lazy</a></h2>
<p>Lazy does not have a pivot in the API, to use pivots in <code>lazy</code>, we can use a <code>map</code> to
apply an eager custom function in a <code>lazy</code> computation node.</p>
<pre><code class="language-python">
q = df.lazy().map(lambda df: df.groupby(&quot;foo&quot;).pivot(pivot_column=&quot;bar&quot;, values_column=&quot;N&quot;).first())
out = q.collect()
print(out)
</code></pre>
<pre><code class="language-text">shape: (3, 6)
┌─────┬──────┬──────┬──────┬──────┬──────┐
│ foo ┆ m    ┆ n    ┆ o    ┆ l    ┆ k    │
│ --- ┆ ---  ┆ ---  ┆ ---  ┆ ---  ┆ ---  │
│ str ┆ i64  ┆ i64  ┆ i64  ┆ i64  ┆ i64  │
╞═════╪══════╪══════╪══════╪══════╪══════╡
│ C   ┆ null ┆ null ┆ 2    ┆ null ┆ null │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ A   ┆ null ┆ null ┆ null ┆ 2    ┆ 1    │
├╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┼╌╌╌╌╌╌┤
│ B   ┆ 2    ┆ 4    ┆ null ┆ null ┆ null │
└─────┴──────┴──────┴──────┴──────┴──────┘
</code></pre>
<h1 id="io"><a class="header" href="#io">IO</a></h1>
<p>Polars support different file types and its respective parsers are amongst the fastest
out there.</p>
<p>For instance, it is faster to load a CSV file <em>via</em> <code>Polars</code> before handing it <code>Pandas</code>,
than directly using <code>Pandas</code>. (Just run a
<code>pl.read_csv(&quot;&lt;FILE&gt;&quot;, rechunk=False).to_pandas()</code> to convince yourself.)</p>
<h1 id="character-separated-values"><a class="header" href="#character-separated-values">Character-Separated Values</a></h1>
<h2 id="read--write"><a class="header" href="#read--write">Read &amp; Write</a></h2>
<p>Reading a CSV file should look familiar:</p>
<pre><code class="language-python">df = pl.read_csv(&quot;path.csv&quot;)
</code></pre>
<p>CSV files come in many different flavors, so make sure to check the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.read_csv.html"><code>read_csv()</code></a> API.</p>
<p>Writing to a CSV file can be done with the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/api/polars.DataFrame.to_csv.html"><code>to_csv()</code></a> method.</p>
<pre><code class="language-python">df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3], &quot;bar&quot;: [None, &quot;bak&quot;, &quot;baz&quot;]})
df.to_csv(&quot;path.csv&quot;)
</code></pre>
<h2 id="scan"><a class="header" href="#scan">Scan</a></h2>
<p><code>Polars</code> allows to <em>scan</em> a CSV input. Scanning delays the actual parsing of the file,
and returns instead a lazy computation holder called a <code>LazyFrame</code>.</p>
<pre><code class="language-python">df = pl.scan_csv(&quot;path.csv&quot;)
</code></pre>
<p>If you want to know why you would want this (and you do!)
<a href="howcani/io/../../optimizations/intro.html">read about the optimizations</a> run under the hood of
<code>Polars</code>.</p>
<h1 id="parquet"><a class="header" href="#parquet">Parquet</a></h1>
<p>Loading or writing <a href="https://parquet.apache.org/"><code>Parquet</code> files</a> is as fast as can be.
<code>Pandas</code> uses <a href="https://arrow.apache.org/docs/python/"><code>PyArrow</code></a> -<code>Python</code> bindings
exposed by <code>Arrow</code>- to load <code>Parquet</code> files into memory but has to copy that data into
<code>Pandas</code> own memory. With <code>Polars</code> one does not have to pay the extra price due to
copying as we read <code>Parquet</code> directly into <code>Arrow memory</code> and <em>keep it there</em>.</p>
<h2 id="read--write-1"><a class="header" href="#read--write-1">Read &amp; write</a></h2>
<pre><code class="language-python">df = pl.read_parquet(&quot;path.parquet&quot;)
</code></pre>
<pre><code class="language-python">df = pl.DataFrame({&quot;foo&quot;: [1, 2, 3], &quot;bar&quot;: [None, &quot;bak&quot;, &quot;baz&quot;]})
df.to_parquet(&quot;path.parquet&quot;)
</code></pre>
<h2 id="scan-1"><a class="header" href="#scan-1">Scan</a></h2>
<p><code>Polars</code> allows to <em>scan</em> a <code>Parquet</code> input. Scanning delays the actual parsing of the
file, and returns instead a lazy computation holder called a <code>LazyFrame</code>.</p>
<pre><code class="language-python">df = pl.scan_parquet(&quot;path.parquet&quot;)
</code></pre>
<p>If you want to know why you would want this (and you do!)
<a href="howcani/io/../../optimizations/intro.html">read about the optimizations</a> run under the hood of
<code>Polars</code>.</p>
<h1 id="read-from-mysql-postgres-sqlite-redshift-clickhouse"><a class="header" href="#read-from-mysql-postgres-sqlite-redshift-clickhouse">Read from MySQL, Postgres, Sqlite, Redshift, Clickhouse</a></h1>
<p>To read from one of the supported databases <code>connector-x</code> needs to be installed.</p>
<pre><code class="language-shell">$  pip install connectorx&gt;=0.2.0a3
</code></pre>
<pre><code class="language-python">import polars as pl

conn = &quot;postgres://username:password@server:port/database&quot;
query = &quot;SELECT * FROM foo&quot;

pl.read_sql(query, conn)
</code></pre>
<h1 id="interact-with-aws"><a class="header" href="#interact-with-aws">Interact with AWS</a></h1>
<blockquote>
<p>In redaction</p>
</blockquote>
<p>To read from or write to an AWS bucket, additional dependencies are needed:</p>
<pre><code class="language-shell">$ pip install s3fs
</code></pre>
<p>In the next few snippets, we take the example of interacting with a <code>Parquet</code> file
located on an AWS bucket.</p>
<h2 id="read"><a class="header" href="#read">Read</a></h2>
<p>One can load a <code>.parquet</code> file using:</p>
<pre><code class="language-python">import polars as pl
import pyarrow.parquet as pq
import s3fs

fs = s3fs.S3FileSystem()
bucket = &quot;&lt;YOUR_BUCKET&gt;&quot;
path = &quot;&lt;YOUR_PATH&gt;&quot;

dataset = pq.ParquetDataset(f&quot;s3://{bucket}/{path}&quot;, filesystem=fs)
df = pl.from_arrow(dataset.read())
</code></pre>
<h2 id="write"><a class="header" href="#write">Write</a></h2>
<h1 id="interact-with-google-bigquery"><a class="header" href="#interact-with-google-bigquery">Interact with Google BigQuery</a></h1>
<p>To read/write form GBQ, additional dependencies are needed:</p>
<pre><code class="language-shell">$ pip install google-cloud-bigquery
</code></pre>
<h2 id="read-1"><a class="header" href="#read-1">Read</a></h2>
<p>We can load a query into a DataFrame like this:</p>
<pre><code class="language-python">import polars as pl
from google.cloud import bigquery

client = bigquery.Client()

# Perform a query.
QUERY = (
    'SELECT name FROM `bigquery-public-data.usa_names.usa_1910_2013` '
    'WHERE state = &quot;TX&quot; '
    'LIMIT 100')
query_job = client.query(QUERY)  # API request
rows = query_job.result()  # Waits for query to finish

df = pl.from_arrow(rows.to_arrow())
</code></pre>
<h2 id="write-1"><a class="header" href="#write-1">Write</a></h2>
<blockquote>
<p>In redaction</p>
</blockquote>
<h1 id="interact-with-postgres"><a class="header" href="#interact-with-postgres">Interact with Postgres</a></h1>
<h2 id="read-2"><a class="header" href="#read-2">Read</a></h2>
<p>To read from postgres, additional dependencies are needed:</p>
<pre><code class="language-shell">$  pip install connectorx&gt;=0.2.0a3
</code></pre>
<pre><code class="language-python">import polars as pl

conn = &quot;postgresql://username:password@server:port/database&quot;
query = &quot;SELECT * FROM foo&quot;

pl.read_sql(query, conn)
</code></pre>
<h2 id="write-2"><a class="header" href="#write-2">Write</a></h2>
<p>To write to postgres, additional dependencies are needed:</p>
<pre><code class="language-shell">$ pip install psycopg2-binary
</code></pre>
<p>For writing to a postgres database with <code>psycopg2</code>, we utilize <code>execute_batch</code>. This will limit the needed round trips
to the server.</p>
<p>We first make sure that all our dtypes are in a format that <code>psycopg2</code> recognizes, and then we use <code>DataFrame.rows</code> to
easily transform the columnar data to rows that the database driver can work with.</p>
<pre><code class="language-python">from psycopg2 import sql
import psycopg2.extras
import polars as pl

# let's assume we have a DataFrame with some floats, integers, strings, and date64 columns.
df = pl.read_parquet(&quot;somefile.parquet&quot;)

# first me convert polars date64 representation to python datetime objects 
for col in df:
    # only for date64
    if col.dtype == pl.Date64:
        df = df.with_column(col.dt.to_python_datetime())

# create sql identifiers for the column names
# we do this to safely insert this into a sql query
columns = sql.SQL(&quot;,&quot;).join(sql.Identifier(name) for name in df.columns)

# create placeholders for the values. These will be filled later
values = sql.SQL(&quot;,&quot;).join([sql.Placeholder() for _ in df.columns])

table_id = &quot;mytable&quot;

# prepare the insert query
insert_stmt = sql.SQL(&quot;INSERT INTO ({}) VALUES({});&quot;).format(
    sql.Identifier(table_id), columns, values
)

# make a connection
conn = psycopg2.connect()
cur = conn.cursort()

# do the insert
psycopg2.extras.execute_batch(cur, insert_stmt, df.rows())
conn.commit()
</code></pre>
<h1 id="interoperability"><a class="header" href="#interoperability">Interoperability</a></h1>
<h1 id="arrow"><a class="header" href="#arrow">Arrow</a></h1>
<p><code>Arrow</code> is rapidly becoming the <em>de facto</em> standard for columnar data. This means that
support for <code>Arrow</code> is growing rapidly, in languages and in tools. Due to the great
effort that is being put in the format, using <code>Arrow</code> is now likely the fastest way to:</p>
<ul>
<li>Read and write <code>Parquet</code> formatted files.</li>
<li>Read CSV into columnar data.</li>
<li>Exchanging columnar data.</li>
</ul>
<p><code>Polars</code> uses <code>Arrow</code> memory buffer as the most basic building block for <code>Polars</code>
<code>Series</code>. This means that we exchange data between <code>Polars</code> and <code>Arrow</code> <strong>without
copying</strong> it. It also means that where <code>Arrow</code> performs well, <code>Polars</code> does.</p>
<p>One can convert a <code>Polars</code> <code>DataFrame</code> or <code>Series</code> to <code>Arrow</code> using the <code>.to_arrow()</code>
method. Similarly, importing from <code>Arrow</code> data structure can be performed with the
<code>.from_arrow()</code> functions.</p>
<h1 id="numpy"><a class="header" href="#numpy">NumPy</a></h1>
<p><code>Polars</code> <code>Series</code> have support for <code>NumPy</code>
<a href="https://numpy.org/doc/stable/reference/ufuncs.html">universal functions (ufuncs)</a>.
Element-wise function such as <code>np.exp()</code>, <code>np.cos()</code>, <code>np.div()</code>, <em>etc.</em> all work with
almost zero overhead.</p>
<p>A <code>Polars</code>-specific remark however: missing values are a separate bitmask and are not
visible by <code>NumPy</code>. It can yield to a window function or a <code>np.convolve()</code> giving
flawed/incomplete results.</p>
<p>One can convert a <code>Polars</code> <code>Series</code> to a <code>NumPy</code> array with the <code>.to_numpy()</code> method.
Missing values will be replaced by <code>np.nan</code> during the conversion. If the <code>Series</code> does
not include missing values, or those values are not desired anymore, the <code>.view()</code>
method can be used instead, providing a zero-copy <code>NumPy</code> array of the data.</p>
<h1 id="data-handling"><a class="header" href="#data-handling">Data handling</a></h1>
<h1 id="process-strings"><a class="header" href="#process-strings">Process strings</a></h1>
<p>Thanks to its <code>Arrow</code> backend <code>Polars</code> string operations are much faster compared to the
same operations performed with <code>NumPy</code> or <code>Pandas</code>. In the latter, strings are stored as
<code>Python</code> objects and while traversing the <code>np.array</code> or the <code>pd.Series</code> the CPU needs to
follow all the string pointers, and jump to many random memory locations; which
is very cache inefficient. In <code>Polars</code> (<em>e.g.</em>, <code>Arrow</code> data
structure) strings are contiguous in memory and traversing is cache-optimal and
predictable for the CPU.</p>
<p>The string processing functions available in <code>Polars</code> are available in the
<a href="https://pola-rs.github.io/polars/py-polars/html/reference/series.html#strings"><code>str</code> namespace</a></p>
<p>A few examples below. To compute string lengths:</p>
<pre><code class="language-python">import polars as pl

df = pl.DataFrame({&quot;shakespeare&quot;: &quot;All that glitters is not gold&quot;.split(&quot; &quot;)})

df = df.with_column(pl.col(&quot;shakespeare&quot;).str.lengths().alias(&quot;letter_count&quot;))
</code></pre>
<p>returning:</p>
<pre><code class="language-text">shape: (6, 2)
┌─────────────┬──────────────┐
│ shakespeare ┆ letter_count │
│ ---         ┆ ---          │
│ str         ┆ u32          │
╞═════════════╪══════════════╡
│ All         ┆ 3            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ that        ┆ 4            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ glitters    ┆ 8            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ is          ┆ 2            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ not         ┆ 3            │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ gold        ┆ 4            │
└─────────────┴──────────────┘
</code></pre>
<p>And below a regex pattern to filter out articles (<code>the</code>, <code>a</code>, <code>and</code>, <em>etc.</em>) from a
sentence:</p>
<pre><code class="language-python">import polars as pl

df = pl.DataFrame({&quot;a&quot;: &quot;The man that ate a whole cake&quot;.split(&quot; &quot;)})

df = df.filter(pl.col(&quot;a&quot;).str.contains(r&quot;(?i)^the$|^a$&quot;).is_not())
</code></pre>
<p>yielding:</p>
<pre><code class="language-text">shape: (5, 1)
┌───────┐
│ a     │
│ ---   │
│ str   │
╞═══════╡
│ man   │
├╌╌╌╌╌╌╌┤
│ that  │
├╌╌╌╌╌╌╌┤
│ ate   │
├╌╌╌╌╌╌╌┤
│ whole │
├╌╌╌╌╌╌╌┤
│ cake  │
└───────┘
</code></pre>
<h1 id="timestamp-parsing"><a class="header" href="#timestamp-parsing">Timestamp parsing</a></h1>
<p><code>Polars</code> offers two time datatypes:</p>
<ul>
<li><code>pl.Date</code>, to be used for <strong>date</strong> objects: the number of days since the UNIX epoch as
a 32 bit signed integer.</li>
<li><code>pl.Datetime</code>, to be used of <strong>datetime</strong> ojects: the number of milliseconds since the
UNIX epoch as a 64 bit signed integer.</li>
</ul>
<p><code>Polars</code> string (<code>pl.Utf8</code>) datatypes can be parsed as either of them. One can let
<code>Polars</code> try to guess the format of the date[time], or explicitly provide a <code>fmt</code>
rule.</p>
<p>For instance (check <a href="https://strftime.org/">this link</a> for an comprehensive list):</p>
<ul>
<li><code>&quot;%Y-%m-%d&quot;</code> for <code>&quot;2020-12-31&quot;</code></li>
<li><code>&quot;%Y/%B/%d&quot;</code> for <code>&quot;2020/December/31&quot;</code></li>
<li><code>&quot;%B %y&quot;</code> for <code>&quot;December 20&quot;</code></li>
</ul>
<p>Below a quick example:</p>
<pre><code class="language-python">import polars as pl

dataset = pl.DataFrame({&quot;date&quot;: [&quot;2020-01-02&quot;, &quot;2020-01-03&quot;, &quot;2020-01-04&quot;], &quot;index&quot;: [1, 2, 3]})

q = dataset.lazy().with_column(pl.col(&quot;date&quot;).str.strptime(pl.Date, &quot;%Y-%m-%d&quot;))

df = q.collect()
</code></pre>
<p>returning:</p>
<pre><code class="language-text">shape: (3, 2)
┌────────────┬───────┐
│ date       ┆ index │
│ ---        ┆ ---   │
│ date       ┆ i64   │
╞════════════╪═══════╡
│ 2020-01-02 ┆ 1     │
├╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2020-01-03 ┆ 2     │
├╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌┤
│ 2020-01-04 ┆ 3     │
└────────────┴───────┘
</code></pre>
<p>All datetime functionality is shown in the <a href="https://pola-rs.github.io/polars/py-polars/html/reference/series.html#timeseries"><code>dt</code> namespace</a>.</p>
<h1 id="apply"><a class="header" href="#apply">Apply</a></h1>
<h1 id="apply-custom-functions"><a class="header" href="#apply-custom-functions">Apply custom functions</a></h1>
<p>There will always be an operation that is so particular that one cannot do it with the public API of
<code>Polars</code>. Luckily polars allows you to apply custom functions. This means one can
define a <code>Python</code> function (or <code>lambda</code>) and pass it to the logical plan.</p>
<p>Let's say we want to apply a mapping operation to a <code>Polars</code> <code>Series</code> in a eager
fashion. This could be done as shown below:</p>
<pre><code class="language-python">import polars as pl

my_map = {1: &quot;foo&quot;, 2: &quot;bar&quot;, 3: &quot;ham&quot;, 4: &quot;spam&quot;, 5: &quot;eggs&quot;}

s = pl.Series(&quot;a&quot;, [1, 2, 3, 4, 5])
s = s.apply(lambda x: my_map[x])
</code></pre>
<p>returning:</p>
<pre><code class="language-text">shape: (5,)
Series: 'a' [str]
[
	&quot;foo&quot;
	&quot;bar&quot;
	&quot;ham&quot;
	&quot;spam&quot;
	&quot;eggs&quot;
]
</code></pre>
<p>There are a few gotchas however, due to the fact <code>Polars</code> <code>Series</code> can only contain a
single datatype.</p>
<p>In the <code>.apply()</code> method above we did not specify the datatype the <code>Series</code> should
contain. <code>Polars</code> tries to infer the output datatype beforehand by calling the provided
function itself. If it later gets a datatype that does not match the initially inferred
type, the value will be indicated as missing (<code>null</code>).</p>
<p>If the output dtype is already known, it is thus recommended to provide that information to <code>Polars</code> (via
the <code>dtype</code> option of <code>.apply()</code>).</p>
<p>Note it is possible to change datatype as a result of applying a function: the <code>lambda</code>
we used above got an integer as input and returned a string (<code>pl.Utf8</code>) after finding
the right key in the <code>my_map</code> dictionary.</p>
<h1 id="to-map-or-to-apply"><a class="header" href="#to-map-or-to-apply">to map or to apply?</a></h1>
<p>There are two way to use custom function, either by using <code>map</code>, or by using <code>apply</code>. Which one you need depends on
the context where the custom functions are used:</p>
<ul>
<li>
<p><code>apply</code></p>
<ul>
<li>selection context: the custom function is applied over all values <code>Fn(value) -&gt; y</code></li>
<li>groupby context: the custom function is applied over all groups <code>Fn([group_value_1, ... group_value_n]) -&gt; y</code></li>
</ul>
</li>
<li>
<p><code>map</code></p>
<ul>
<li>selection context: the custom function is applied <code>Series</code> and must produce a new <code>Series</code> <code>Fn(Series) -&gt; Series</code></li>
<li>groupby context: the custom function is applied <code>Series</code> and must produce a new <code>Series</code> <code>Fn(Series) -&gt; Series</code></li>
</ul>
</li>
</ul>
<h1 id="apply-window-functions"><a class="header" href="#apply-window-functions">Apply window functions</a></h1>
<p><code>Polars</code> supports window functions inspired by
<a href="https://www.postgresql.org/docs/current/tutorial-window.html">PostgreSQL</a>. <code>Pandas</code>
users may recognize these as a <code>groupby.transform(aggregation)</code>.</p>
<p><code>Polars</code> window functions are much more elegant than <code>Pandas</code> transform. We can apply
multiple functions over multiple columns in a single expression!</p>
<pre><code class="language-python">import polars as pl

dataset = pl.DataFrame(
    {
        &quot;A&quot;: [1, 2, 3, 4, 5],
        &quot;fruits&quot;: [&quot;banana&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;apple&quot;, &quot;banana&quot;],
        &quot;B&quot;: [5, 4, 3, 2, 1],
        &quot;cars&quot;: [&quot;beetle&quot;, &quot;audi&quot;, &quot;beetle&quot;, &quot;beetle&quot;, &quot;beetle&quot;],
    }
)

q = dataset.lazy().with_columns(
    [
        pl.sum(&quot;A&quot;).over(&quot;fruits&quot;).alias(&quot;fruit_sum_A&quot;),
        pl.first(&quot;B&quot;).over(&quot;fruits&quot;).alias(&quot;fruit_first_B&quot;),
        pl.max(&quot;B&quot;).over(&quot;cars&quot;).alias(&quot;cars_max_B&quot;),
    ]
)

df = q.collect()
</code></pre>
<pre><code class="language-text">shape: (5, 7)
┌─────┬────────┬─────┬────────┬─────────────┬───────────────┬────────────┐
│ A   ┆ fruits ┆ B   ┆ cars   ┆ fruit_sum_A ┆ fruit_first_B ┆ cars_max_B │
│ --- ┆ ---    ┆ --- ┆ ---    ┆ ---         ┆ ---           ┆ ---        │
│ i64 ┆ str    ┆ i64 ┆ str    ┆ i64         ┆ i64           ┆ i64        │
╞═════╪════════╪═════╪════════╪═════════════╪═══════════════╪════════════╡
│ 1   ┆ banana ┆ 5   ┆ beetle ┆ 8           ┆ 5             ┆ 5          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ banana ┆ 4   ┆ audi   ┆ 8           ┆ 5             ┆ 4          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ apple  ┆ 3   ┆ beetle ┆ 7           ┆ 3             ┆ 5          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ apple  ┆ 2   ┆ beetle ┆ 7           ┆ 3             ┆ 5          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ banana ┆ 1   ┆ beetle ┆ 8           ┆ 5             ┆ 5          │
└─────┴────────┴─────┴────────┴─────────────┴───────────────┴────────────┘
</code></pre>
<h1 id="performance"><a class="header" href="#performance">Performance</a></h1>
<p>This chapter handles some gotcha's needed to get maximum performance out of Polars.
When used properly, Polars can run at blazing speeds. Take a look at the results in
<a href="https://h2oai.github.io/db-benchmark/">H2O AI database benchmark</a>.</p>
<h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Understanding the memory format used by <code>Arrow</code>/<code>Polars</code> can really increase performance
of your queries. This is especially true for large string data. The figure below shows
how an <code>Arrow</code> <code>UTF8</code> array is laid out in memory.</p>
<p>The array <code>[&quot;foo&quot;, &quot;bar&quot;, &quot;ham&quot;]</code> is encoded by :</p>
<ul>
<li>a concatenated string <code>&quot;foobarham&quot;</code>,</li>
<li>an offset array indicating the start (and end) of each string <code>[0, 2, 5, 8]</code>,</li>
<li>a null bitmap, indicating null values.</li>
</ul>
<p><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/docs/arrow-string.svg" alt="" /></p>
<p>This memory structure is very cache-efficient if we are to read the string values.
Especially if we compare it to a <code>Vec&lt;String&gt;</code> (an array of heap allocated string data
in <code>Rust</code>).</p>
<p><img src="https://raw.githubusercontent.com/pola-rs/polars-static/master/docs/pandas-string.svg" alt="" /></p>
<p>However, if we need to reorder the <code>Arrow</code> <code>UTF8</code> array, we need to swap around all the
bytes of the string values, which can become very expensive when dealing with large
strings. On the other hand, for the <code>Vec&lt;String&gt;</code>, we only need to swap pointers around
which is only 8 bytes data that have to be moved with little cost.</p>
<p>Reordering a <code>DataFrame</code> embedding a large number of <code>Utf8</code> <code>Series</code> due to an operation
(filtering, joining, grouping, <em>etc.</em>) can quickly become quite expensive.</p>
<h2 id="categorical-type"><a class="header" href="#categorical-type">Categorical type</a></h2>
<p>For this reason <code>Polars</code> has a <code>CategoricalType</code>. A <code>Categorical</code> <code>Series</code> is an array
filled with <code>u32</code> values that each represent a unique string value. Thereby maintaining
cache efficiency, whilst keeping cheap to move values around.</p>
<p>In the example below we show how you can cast an <code>Utf8</code> <code>Series</code> column to a
<code>Categorical</code> <code>Series</code>.</p>
<pre><code class="language-python">import polars as pl

df[&quot;utf8-column&quot;].cast(pl.Categorical)
</code></pre>
<h3 id="eager-join-multiple-dataframes-on-categorical-data"><a class="header" href="#eager-join-multiple-dataframes-on-categorical-data">Eager join multiple DataFrames on Categorical data</a></h3>
<p>When two DataFrames need to be joined based on string data the <code>Categorical</code> data needs
to be synchronized (data in column <code>A</code> of <code>df1</code> needs to point to the same underlying
string data as column <code>B</code> in <code>df2</code>). One can do so by casting data in the <code>StringCache</code>
context manager. This will synchronize all seen string values for the duration of that
context manager. If you want the global string cache to be existent during the whole
run, you can set <code>toggle_string_cache</code> to <code>True</code>.</p>
<pre><code class="language-python">import polars as pl

df1 = pl.DataFrame({&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, &quot;ham&quot;], &quot;b&quot;: [1, 2, 3]})
df2 = pl.DataFrame({&quot;a&quot;: [&quot;foo&quot;, &quot;spam&quot;, &quot;eggs&quot;], &quot;c&quot;: [3, 2, 2]})

with pl.StringCache():
    df1.with_column(pl.col(&quot;a&quot;).cast(pl.Categorical))
    df2.with_column(pl.col(&quot;a&quot;).cast(pl.Categorical))
</code></pre>
<h3 id="lazy-join-multiple-dataframes-on-categorical-data"><a class="header" href="#lazy-join-multiple-dataframes-on-categorical-data">Lazy join multiple DataFrames on Categorical data</a></h3>
<p>A lazy query always has a global string cache (unless you opt-out) for the duration of
that query (until <code>.collect()</code> is called). The example below shows how you could join
two DataFrames with <code>Categorical</code> types.</p>
<pre><code class="language-python">import polars as pl

df1 = pl.DataFrame({&quot;a&quot;: [&quot;foo&quot;, &quot;bar&quot;, &quot;ham&quot;], &quot;b&quot;: [1, 2, 3]}).lazy()
df2 = pl.DataFrame({&quot;a&quot;: [&quot;foo&quot;, &quot;spam&quot;, &quot;eggs&quot;], &quot;c&quot;: [3, 2, 2]}).lazy()

df1 = df1.with_column(pl.col(&quot;a&quot;).cast(pl.Categorical))
df2 = df2.with_column(pl.col(&quot;a&quot;).cast(pl.Categorical))

df1.join(df2, on=&quot;a&quot;, how=&quot;inner&quot;)
</code></pre>
<h1 id="optimizations"><a class="header" href="#optimizations">Optimizations</a></h1>
<p>This chapter will investigate some of the optimizations that are applied by the Polars
query optimizer by going through some examples and see how Polars modifies the original query plan.</p>
<h1 id="lazy-api-1"><a class="header" href="#lazy-api-1">Lazy API</a></h1>
<blockquote>
<p>In redaction</p>
</blockquote>
<p>To demonstrate the lazy <code>Polars</code> capabilities we suggest to explore two medium-large
datasets of usernames:</p>
<p><a href="https://www.reddit.com/r/datasets/comments/9i8s5j/dataset_metadata_for_69_million_reddit_users_in/">Reddit usernames dataset</a>
containing 69+ million rows,</p>
<pre><code class="language-python">import polars as pl

from ..paths import DATA_DIR

dataset = pl.read_csv(f&quot;{DATA_DIR}/reddit.csv&quot;, stop_after_n_rows=10)
</code></pre>
<pre><code class="language-text">shape: (5, 6)
┌─────┬──────────────────────────┬─────────────┬────────────┬───────────────┬────────────┐
│ id  ┆ name                     ┆ created_utc ┆ updated_on ┆ comment_karma ┆ link_karma │
│ --- ┆ ---                      ┆ ---         ┆ ---        ┆ ---           ┆ ---        │
│ i64 ┆ str                      ┆ i64         ┆ i64        ┆ i64           ┆ i64        │
╞═════╪══════════════════════════╪═════════════╪════════════╪═══════════════╪════════════╡
│ 1   ┆ truman48lamb_jasonbroken ┆ 1397113470  ┆ 1536527864 ┆ 0             ┆ 0          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 2   ┆ johnethen06_jasonbroken  ┆ 1397113483  ┆ 1536527864 ┆ 0             ┆ 0          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 3   ┆ yaseinrez_jasonbroken    ┆ 1397113483  ┆ 1536527864 ┆ 0             ┆ 1          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 4   ┆ Valve92_jasonbroken      ┆ 1397113503  ┆ 1536527864 ┆ 0             ┆ 0          │
├╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 5   ┆ srbhuyan_jasonbroken     ┆ 1397113506  ┆ 1536527864 ┆ 0             ┆ 0          │
└─────┴──────────────────────────┴─────────────┴────────────┴───────────────┴────────────┘
</code></pre>
<p>and the <a href="https://github.com/RuneStar/name-cleanup-2014">Runescape username dataset</a>
containing about 55+ million records.</p>
<pre><code class="language-python">import polars as pl

from ..paths import DATA_DIR

dataset = pl.read_csv(f&quot;{DATA_DIR}/runescape.csv&quot;, has_headers=False, stop_after_n_rows=10)
</code></pre>
<pre><code class="language-text">shape: (5, 1)
┌─────────────┐
│ column_1    │
│ ---         │
│ str         │
╞═════════════╡
│ a000        │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ a0000       │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ a000000     │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ a0000000    │
├╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ a0000000000 │
└─────────────┘
</code></pre>
<h1 id="predicate-pushdown"><a class="header" href="#predicate-pushdown">Predicate pushdown</a></h1>
<blockquote>
<p>In redaction</p>
</blockquote>
<p>Predicate pushdown is an optimization Polars does that reduces query times and memory
usage. A predicate is database jargon for applying a filter on some table and thereby
reducing number the number of rows on that table.</p>
<p>So let's see if we can load some Reddit data and filter on a few predicates.</p>
<pre><code class="language-python">import polars as pl

from ..paths import DATA_DIR

q = (
    pl.scan_csv(f&quot;{DATA_DIR}/reddit.csv&quot;)
    .filter(pl.col(&quot;comment_karma&quot;) &gt; 0)
    .filter(pl.col(&quot;link_karma&quot;) &gt; 0)
    .filter(pl.col(&quot;name&quot;).str.contains(r&quot;^a&quot;))  # filter name that start with an &quot;a&quot;
)

df1 = q.fetch(int(1e7))
df2 = q.fetch(int(1e7), predicate_pushdown=True)
</code></pre>
<p>If we were to run this query above, nothing would happen! This due to the lazyness,
nothing will happend until specifically requested. This allows Polars to see the whole
context of a query and optimize just in time for execution.</p>
<p>Execution is requested by the <code>.collect</code> method. This would query all available data.
During writing/ optimizing/ checking your query this is often not what you want. Another
method that calls for execution is the <code>.fetch</code> method. <code>.fetch</code> takes a parameter
<code>n_rows</code> and tries to 'fetch' that number of rows at the data source (no guarantees are
given though).</p>
<p>So let's &quot;fetch&quot; ~10 Million rows from the source file and apply the predicates.</p>
<pre><code class="language-python">reddit.fetch(n_rows=int(1e7))
</code></pre>
<pre><code class="language-text">shape: (656, 6)
┌─────────┬──────────────────┬─────────────┬────────────┬───────────────┬────────────┐
│ id      ┆ name             ┆ created_utc ┆ updated_on ┆ comment_karma ┆ link_karma │
│ ---     ┆ ---              ┆ ---         ┆ ---        ┆ ---           ┆ ---        │
│ i64     ┆ str              ┆ i64         ┆ i64        ┆ i64           ┆ i64        │
╞═════════╪══════════════════╪═════════════╪════════════╪═══════════════╪════════════╡
│ 77860   ┆ aquarin          ┆ 1137474000  ┆ 1536528294 ┆ 150           ┆ 11         │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 77974   ┆ aadvaark         ┆ 1137301200  ┆ 1536528294 ┆ 26            ┆ 47         │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 78004   ┆ apoisel          ┆ 1137301200  ┆ 1536497404 ┆ 42            ┆ 2549       │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 78041   ┆ aonic            ┆ 1137301200  ┆ 1536497404 ┆ 2931          ┆ 2095       │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ ...     ┆ ...              ┆ ...         ┆ ...        ┆ ...           ┆ ...        │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1186942 ┆ anonymous-coward ┆ 1162674522  ┆ 1536532928 ┆ 159429        ┆ 31640      │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1192656 ┆ atothedrian      ┆ 1162785880  ┆ 1536497412 ┆ 748           ┆ 585        │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1204607 ┆ akbusiness       ┆ 1162899425  ┆ 1536532995 ┆ 73            ┆ 512        │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1214809 ┆ aaminics         ┆ 1162969322  ┆ 1536533034 ┆ 22            ┆ 6          │
├╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 1225341 ┆ antonulrich      ┆ 1163110623  ┆ 1536497412 ┆ 9304          ┆ 1782       │
└─────────┴──────────────────┴─────────────┴────────────┴───────────────┴────────────┘
</code></pre>
<p>Above we see that from the 10 Million rows, 61503 rows match our predicate.</p>
<h2 id="break-it-down"><a class="header" href="#break-it-down">Break it down</a></h2>
<p>In Polars we can visualize the query plan. Let's take a look.</p>
<pre><code class="language-python">reddit.show_graph(optimized=False)
</code></pre>
<p><img src="optimizations/lazy/../../outputs/predicate_pushdown/graph1.png" alt="" /></p>
<p>The astute reader maybe would notice that our query is not very optimal because we have
3 separate <em>FILTER</em> nodes. That means that after every <em>FILTER</em> a new DataFrame is
allocated, which will be input to the next <em>FILTER</em> and then deleted from memory, that
must be redundant. And you know what.. He/she is right, the predicates should be
combined, we should have written this query:</p>
<pre><code class="language-python">import polars as pl

from ..paths import DATA_DIR

q = pl.scan_csv(f&quot;{DATA_DIR}/reddit.csv&quot;).filter(
    (pl.col(&quot;comment_karma&quot;) &gt; 0) &amp; (pl.col(&quot;link_karma&quot;) &gt; 0) &amp; (pl.col(&quot;name&quot;).str.contains(r&quot;^a&quot;))
)

df = q.fetch(int(1e7))
</code></pre>
<p>That would translate to:</p>
<pre><code class="language-python">reddit_2.show_graph(optimized=False)
</code></pre>
<p><img src="optimizations/lazy/../../outputs/predicate_pushdown/graph2.png" alt="" /></p>
<p>As we can see the predicates are combined. This would lead to less copying of data</p>
<h2 id="in-comes-optimization"><a class="header" href="#in-comes-optimization">In comes optimization</a></h2>
<p>Polars tries to save that mental overhead from the query writer and combines predicates
for you. Besides that, it pushes predicates down to the scan level! Let's see how our
optimized query looks.</p>
<pre><code class="language-python">reddit.show_graph(optimized=True)
</code></pre>
<p><img src="optimizations/lazy/../../outputs/predicate_pushdown/graph1-optimized.png" alt="" /></p>
<p>It may be hard to see, but what is clear is that there is only a single node; the <em>CSV
SCAN</em>. The predicate filtering is done during the reading of the csv. This means that
this query's memory overhead is reduced by filtering factor! This makes a huge impact.</p>
<h3 id="memory"><a class="header" href="#memory">Memory</a></h3>
<p>As we have seen there were ~ 62,000 rows left after the <em>FILTER</em>. That means that (aside
for some memory overhead of the batch size and filter operations) we use \(
\frac{6.2\text{e-}4}{1\text{e-}7} \sim 0.6 \text{%} \) of the memory we would
during an eager evaluation where we first would read the whole table in memory before
applying a filter.</p>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<p>At the time of writing this, the predicate pushdown also increased the query time
performance.</p>
<p><strong>Without optimization</strong>, <code>predicate_pushdown=False</code> flag:</p>
<pre><code class="language-text">real	0m2,401s
user	0m5,457s
sys	0m0,894s
</code></pre>
<p><strong>with optimization</strong>, <code>predicate_pushdown=True</code> flag:</p>
<pre><code class="language-text">real	0m1,597s
user	0m6,143s
sys	0m0,647s
</code></pre>
<h2 id="relational-algebra"><a class="header" href="#relational-algebra">Relational algebra</a></h2>
<p>In the visualization of the query plan, you see a \( \sigma \) symbol. This indicates
a Predicate done at the <em>SCAN</em> level. There is also a \( \pi \) symbol indicating
projection (database jargon for column selection), but we'll get to that later.</p>
<h2 id="cheaper-joins"><a class="header" href="#cheaper-joins">Cheaper joins</a></h2>
<p>Predicate pushdown optimization will generally also lead to cheaper join's. A join is
quite an expensive operation the less rows we through at a join operation, the cheaper
it becomes.</p>
<h1 id="projection-pushdown"><a class="header" href="#projection-pushdown">Projection pushdown</a></h1>
<blockquote>
<p>In redaction</p>
</blockquote>
<p>Let's expand our query from the previous section by joining the result of the <em>FILTER</em>
operation with the runescape data to see which popular Reddit username that have a
username starting with an a also played Runescape. That must be something we are all
interested in!</p>
<p>The query that does so may look like this.</p>
<pre><code class="language-python">import polars as pl

from ..paths import DATA_DIR

reddit = (
    pl.scan_csv(f&quot;{DATA_DIR}/reddit.csv&quot;)
    .filter(pl.col(&quot;comment_karma&quot;) &gt; 0)
    .filter(pl.col(&quot;link_karma&quot;) &gt; 0)
    .filter(pl.col(&quot;name&quot;).str.contains(r&quot;^a&quot;))
)

runescape = pl.scan_csv(&quot;data/runescape.csv&quot;, has_headers=False).select(pl.col(&quot;column_1&quot;).alias(&quot;name&quot;))

dataset = reddit.join(runescape, on=&quot;name&quot;, how=&quot;inner&quot;).select([&quot;name&quot;, &quot;comment_karma&quot;, &quot;link_karma&quot;])

df1 = dataset.fetch(int(1e7))
df2 = dataset.fetch(int(1e7), predicate_pushdown=True, projection_pushdown=True)
</code></pre>
<p>And yields the following DataFrame.</p>
<pre><code class="language-text">shape: (0, 3)
┌──────┬───────────────┬────────────┐
│ name ┆ comment_karma ┆ link_karma │
│ ---  ┆ ---           ┆ ---        │
│ str  ┆ i64           ┆ i64        │
╞══════╪═══════════════╪════════════╡
└──────┴───────────────┴────────────┘
</code></pre>
<h2 id="break-it-down-1"><a class="header" href="#break-it-down-1">Break it down</a></h2>
<p>Again, let's take a look the query plan.</p>
<pre><code class="language-python">dataset.show_graph(optimized=False)
</code></pre>
<p><img src="optimizations/lazy/./../outputs/projection_pushdown/graph.png" alt="" /></p>
<p>Now were focussed on the projection's indicated with π. The first node shows π 3/6,
indicating that we select 3 out of 6 columns in the DataFrame. If we look the csv scans
we see a wildcard π */6 and π */1 meaning that we select all of 6 columns of the
reddit dataset and the one and only column from the runescape dataset respectively.</p>
<p>This query is not very optimal. We select all columns from both datasets and only show
3/6 after join. That means that there were some columns computed during the join
operation that could have been ignored. There were also columns parsed during csv
scanning only to be dropped at the end. When we are dealing with DataFrame's with a
large number of columns the redundant work that is done can be huge.</p>
<h3 id="optimized-query"><a class="header" href="#optimized-query">Optimized query</a></h3>
<p>Let's see how Polars optimizes this query.</p>
<pre><code class="language-python">dataset.show_graph(optimized=True)
</code></pre>
<p><img src="optimizations/lazy/./../outputs/projection_pushdown/graph-optimized.png" alt="" /></p>
<p>The projections are pushed down the join operation all the way to the csv scans. This
means that both the scanning and join operation have become cheaper due to the query
optimization.</p>
<h2 id="performance-2"><a class="header" href="#performance-2">Performance</a></h2>
<p>Let's time the result before and after optimization.</p>
<p><strong>without optimization</strong>, <code>predicate_pushdown=False</code> and <code>projection_pushdown=False</code>.</p>
<pre><code class="language-text">real	0m3,273s
user	0m9,284s
sys	0m1,081s
</code></pre>
<p><strong>with optimization</strong>, <code>predicate_pushdown</code> and <code>projection_pushdown</code> flags both to
<code>True</code>.</p>
<pre><code class="language-text">real	0m1,732s
user	0m7,581s
sys	0m0,783s
</code></pre>
<p>We can see that we almost reduced query time by half on this simple query. With real
business data often comprising of many column, filtering missing data, doing complex
groupby and joins we expect this difference between unoptimized queries and optimized
queries to only grow.</p>
<h1 id="other-optimizations"><a class="header" href="#other-optimizations">Other optimizations</a></h1>
<blockquote>
<p>In redaction</p>
</blockquote>
<p>Besides predicate and projection pushdown, Polars does other optimizations.</p>
<p>One important one is optional caching and parallelization. One can imagine having two
different DataFrame computations that lead to a scan of the same file. Polars may cache
the scanned file to prevent scanning the same file twice. However, if you want to, you
may override this behavior and force polars to read the same file. This could be faster
because the scan could be done in parallel.</p>
<h2 id="join-parallelization"><a class="header" href="#join-parallelization">Join parallelization</a></h2>
<p>If we look at the previous query, we see that the join operation has as input a
computation path with <code>data/reddit.csv</code> as root and one path with <code>data/runescape.csv</code>
as root. Polars can observe that there are no dependencies between the two DataFrame and
will read both files in parallel. If other operations are done before the join (e.g.
groupby, filters, etc.) they are also executed in parallel.</p>
<p><img src="optimizations/lazy/../../outputs/projection_pushdown/graph-optimized.png" alt="" /></p>
<h2 id="simplify-expressions"><a class="header" href="#simplify-expressions">Simplify expressions</a></h2>
<p>Some other optimizations that are done are expression simplifications. The impact of
these optimizations is less than that of predicate and projection pushdown, but they
likely add up. You can
<a href="https://github.com/pola-rs/polars/issues/139">track this issue</a> to see the latest
status of those.</p>
<h1 id="reference-guide"><a class="header" href="#reference-guide">Reference guide</a></h1>
<p>Need to see all available methods/functions of <code>Polars</code>? Choose the right documentation
entrypoint below:</p>
<ul>
<li><a href="https://docs.rs/polars"><code>Rust</code> release</a></li>
<li><a href="https://pola-rs.github.io/polars/py-polars/html/reference"><code>Python</code> API</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
